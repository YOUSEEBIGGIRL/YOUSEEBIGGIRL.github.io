<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>K8s 控制节点高可用实践 [draft]</title>
    <link href="/2023/06/18/k8s-master-ha/"/>
    <url>/2023/06/18/k8s-master-ha/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是控制节点高可用"><a href="#什么是控制节点高可用" class="headerlink" title="什么是控制节点高可用"></a>什么是控制节点高可用</h1><p>控制节点，也可以叫做 k8s master 节点，负责管理和控制整个集群的运行。控制节点上运行着 k8s 控制平面组件，其中包括了负责集群内外通信的超核心的组件  —— api-server，这代表着如果控制节点挂掉了，那么整个集群都会因为 ”群龙无首“ 而不可用，所以在实际的生产环境中，k8s 集群一定会部署多个控制节点，这样可以保证某个节点挂掉后，其他节点还能继续提供服务，即 ”高可用“。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在本文中，为了实现高可用，使用了 <code>HAproxy</code> 和 <code>Keepalived</code> 这两个组件，其中：</p><ul><li><code>HAproxy</code> 负责反向代理和负载均衡，有点类似 <code>Nginx</code>，其代理实际的 k8s master 节点地址，当用户访问 HAproxy 时，HAproxy 会通过负载均衡的方式，将用户的请求转发给 k8s master 节点。</li><li>Keepalived 为 <code>HAproxy</code> 提供高可用。HAproxy 提供了反向代理服务，如果 HAproxy 挂掉了，那么用户的请求就到不了 master 节点，一样会导致服务不可用，所以同样也需要为 HAproxy 提供高可用保证。Keepalived 会先创建一个固定的 VIP（VIP，即虚拟 IP），并将其绑定到某个运行了 HAproxy 的节点（也可以称之为 LB 节点）的某张网卡上，用户只需要访问这个 VIP，即可访问到这个 VIP 绑定的节点的 HAproxy，如果这个节点的 HAproxy 挂掉了，或者干脆这个节点都挂掉了，那么 Keepalived 检测到后，会进行 VIP 漂移的操作，将这个 VIP 绑定到另一个 LB 节点的某个网卡上，用户依然访问这个 VIP 即可，完全不受任何影响。</li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>在本次实践中，我们使用的是外部负载均衡器的方式，即 HAproxy 单独部署在非 k8s 集群的机器上。</p><ul><li>两台主机，用来作为负载均衡服务器，其中一台为 master（主），另一台 backup（备），正常情况下会由 master 提供负载均衡服务，如果 master 挂掉了，则转而由 backup 提供。</li></ul><h2 id="安装-haproxy-和-keepalived"><a href="#安装-haproxy-和-keepalived" class="headerlink" title="安装 haproxy 和 keepalived"></a>安装 haproxy 和 keepalived</h2><p>分别在两台负载均衡主机上安装 haproxy 和 keepalived：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install haproxy keepalived -y<br></code></pre></td></tr></table></figure><h2 id="配置-Keepalived"><a href="#配置-Keepalived" class="headerlink" title="配置 Keepalived"></a>配置 Keepalived</h2><p>然后，分别给两台主机配置 keepalived 配置文件，该配置文件位于 <code>/etc/keepalived/keepalived.conf</code>，下面是模版：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">! <span class="hljs-regexp">/etc/</span>keepalived/keepalived.conf<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>    router_id LVS_DEVEL<br>    script_user root<br>    enable_script_security<br>&#125;<br><br>vrrp_script chk_haproxy &#123;<br>    script  <span class="hljs-string">&quot;killall -0 haproxy&quot;</span><br>    interval  <span class="hljs-number">2</span><br>    weight  <span class="hljs-number">2</span><br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state  <span class="hljs-variable">$&#123;STATE&#125;</span> <br>    interface <span class="hljs-variable">$&#123;INTERFACE&#125;</span><br>    virtual_router_id  <span class="hljs-variable">$&#123;ROUTER_ID&#125;</span><br>    priority <span class="hljs-variable">$&#123;PRIORITY&#125;</span><br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass <span class="hljs-variable">$&#123;AUTH_PASS&#125;</span><br>    &#125;<br>    virtual_ipaddress &#123;<br>        <span class="hljs-variable">$&#123;APISERVER_VIP&#125;</span><br>    &#125;<br>    track_script &#123;<br>        chk_haproxy<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的模板文件中有部分内容（用 ${} 包裹的一些变量）需要替换为自己相应的内容，详细如下：</p><table><thead><tr><th>需要替换的变量</th><th align="left">替换内容</th></tr></thead><tbody><tr><td>${STATE}</td><td align="left">如果是主节点 则为 MASTER 其他则为 BACKUP。我这里选择 lb1 这台主机 为 MASTER；lb2 为 BACKUP</td></tr><tr><td>${INTERFACE}</td><td align="left">网络接口，即服务器网卡，我的服务器均为 eth1；</td></tr><tr><td>${ROUTER_ID}</td><td align="left">这个值只要在 keepalived 集群中保持一致即可，我使用的是默认值 51；</td></tr><tr><td>${PRIORITY}</td><td align="left">优先级，优先级高的会拿到 VIP。这里需要保证 master 节点的高于 backup 节点。</td></tr><tr><td>${AUTH_PASS}</td><td align="left">这个值只要在 keepalived 集群中保持一致即可；</td></tr><tr><td>${APISERVER_VIP}</td><td align="left">就是 VIP 的地址，我的为 192.168.31.110</td></tr></tbody></table><blockquote><p>简单说明一下这段配置文件：</p><p>global_defs 块中的  <code>script_user root</code> 和 <code>enable_script_security</code> 用于解决 Keepalived 执行脚本时报错 <code>scripts are being executed but script_security not enabled.</code> 的问题，不用过多关注。</p><p>vrrp_script chk_haproxy 块有一个 script 字段，可以指定为一个 shell 文件所在路径，或者一条命令。这个块还拥有一个 weight 字段，表示脚本执行结果对当前节点优先级的影响。具体来说，Keepalived 会 <strong>定期执行这个脚本</strong>，如果脚本执行成功了，那么当前节点的优先级会增加 weight 对应的值，如果执行失败了，则会减掉相应的值，而每个节点的优先级又决定了 VIP 会绑定到谁（VIP 会绑定到优先级最高的那个节点），所以可以说，<strong>这个块可以用来作为 Keepalived 判断是否需要进行 VIP 漂移的依据</strong>。</p><p>vrrp_instance 块则代表 Keepalived 中一个具体实例，主要用来定义实例相关的配置，包括该实例是主还是备、对应网络接口、优先级、认证方式和 VIP 等信息，这个块里面还有一个 track_script 块，其指定的正是上面我们定义的 vrrp_script 的名字。</p></blockquote><div class="note note-warning">            <p>注意，master 和 backup 的配置文件会有所不同，不能直接把 master 节点的 keepalived 配置文件拷贝给 backup 节点。</p>          </div><div class="note note-warning">            <p>${PRIORITY} 这个值的设置有点名堂，不是简单的 master 大于 backup 即可，否则可能会出现 VIP 无法正确漂移的情况。简单的说，你需要确保 master 大于 backup，且二者的差值小于 vrrp_script 中的 weight。比如如果 weight 为 2，那么你需要分别设置 master 和 backup 的 priority 为 50 和 49（其他数字也行，只要二者差值小于 2 即可）。你可以阅读文章中 <strong>验证 VIP 漂移&#x2F;验证不通过</strong> 开始的章节来了解原因。</p>          </div><p><del>此外，上面的配置文件中还有一个需要注意的地方，即 vrrp_script check_apiserver 块的 script 字段，需要指定健康检查脚本的所在路径，监控检查脚本的内容如下：</del></p><p><del>保存在 <code>/etc/keepalived/check_apiserver.sh</code></del></p><p><del>#bin&#x2F;sh</del></p><p><del>errorExit() {</del><br>    <del>echo “*** $*” 1&gt;&amp;2</del><br>    <del>exit 1</del><br><del>}</del></p><p><del>APISERVER_VIP&#x3D;192.168.31.110</del><br><del>APISERVER_DEST_PORT&#x3D;6443</del></p><p><del>curl –silent –max-time 2 –insecure <a href="https://localhost:${APISERVER_DEST_PORT}/">https://localhost:${APISERVER_DEST_PORT}/</a> -o &#x2F;dev&#x2F;null || errorExit “Error GET <a href="https://localhost:${APISERVER_DEST_PORT}/">https://localhost:${APISERVER_DEST_PORT}/</a>“</del><br><del>if ip addr | grep -q ${APISERVER_VIP}; then</del><br>    <del>curl –silent –max-time 2 –insecure https:&#x2F;&#x2F;${APISERVER_VIP}:${APISERVER_DEST_PORT}&#x2F; -o &#x2F;dev&#x2F;null || errorExit “Error GET https:&#x2F;&#x2F;${APISERVER_VIP}:${APISERVER_DEST_PORT}&#x2F;“</del><br><del>fi</del></p><table><thead><tr><th><del>需要替换的变量</del></th><th><del>替换内容</del></th></tr></thead><tbody><tr><td><del>${APISERVER_VIP}</del></td><td><del>VIP 的地址</del></td></tr><tr><td><del>${APISERVER_DEST_PORT}</del></td><td><del>定义 API Server 交互的负载均衡端口，其实就是 HAProxy 绑定前端负载均衡的端口号</del></td></tr></tbody></table><p>下面是我配置好的 master 和 backup 的配置文件，可以参考一下：</p><p><strong>master</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">&quot;keepalived.conf&quot;</span> <span class="hljs-number">27</span>L, <span class="hljs-number">485</span>B                                                  <span class="hljs-number">22</span>,<span class="hljs-number">24</span>         All<br>! /etc/keepalived/keepalived.conf<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>    router_id LVS_DEVEL<br>    script_user root<br>    enable_script_security<br>&#125;<br>vrrp_script chk_haproxy &#123;<br>    script  <span class="hljs-string">&quot;killall -0 haproxy&quot;</span><br>    <span class="hljs-built_in">int</span>erval  <span class="hljs-number">2</span><br>    weight  <span class="hljs-number">2</span><br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state MASTER<br>    <span class="hljs-keyword">interface</span> <span class="hljs-symbol">eth1</span><br>    <span class="hljs-symbol">virtual_router_id</span> <span class="hljs-symbol">51</span><br>    <span class="hljs-symbol">priority</span> <span class="hljs-symbol">50</span><br>    <span class="hljs-symbol">authentication</span> &#123;<br>        auth_type PASS<br>        auth_pass pwd12345<br>    &#125;<br>    virtual_ipaddress &#123;<br>       <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.110</span>/<span class="hljs-number">24</span><br>    &#125;<br>    track_script &#123;<br>        chk_haproxy<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>backup</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">! /etc/keepalived/keepalived.conf<br>! Configuration File <span class="hljs-keyword">for</span> keepalived<br>global_defs &#123;<br>    router_id LVS_DEVEL<br>    script_user root<br>    enable_script_security<br>&#125;<br>vrrp_script chk_haproxy &#123;<br>    script  <span class="hljs-string">&quot;killall -0 haproxy&quot;</span><br>    <span class="hljs-built_in">int</span>erval  <span class="hljs-number">2</span><br>    weight  <span class="hljs-number">2</span><br>&#125;<br><br>vrrp_instance VI_1 &#123;<br>    state BACKUP<br>    <span class="hljs-keyword">interface</span> <span class="hljs-symbol">eth1</span><br>    <span class="hljs-symbol">virtual_router_id</span> <span class="hljs-symbol">51</span><br>    <span class="hljs-symbol">priority</span> <span class="hljs-symbol">49</span><br>    <span class="hljs-symbol">authentication</span> &#123;<br>        auth_type PASS<br>        auth_pass pwd12345<br>    &#125;<br>    virtual_ipaddress &#123;<br>       <span class="hljs-number">192.168</span><span class="hljs-number">.31</span><span class="hljs-number">.110</span>/<span class="hljs-number">24</span><br>    &#125;<br>    track_script &#123;<br>        chk_haproxy<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置-HAproxy"><a href="#配置-HAproxy" class="headerlink" title="配置 HAproxy"></a>配置 HAproxy</h2><p>接下来继续配置 HAproxy：</p><p>该文件位于 <code>/etc/haproxy/haproxy.cfg</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># Example configuration for a possible web application.  See the</span><br><span class="hljs-comment"># full configuration options online.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   http://haproxy.1wt.eu/download/1.4/doc/configuration.txt</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># Global settings</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">global</span><br>    <span class="hljs-comment"># to have these messages end up in /var/log/haproxy.log you will</span><br>    <span class="hljs-comment"># need to:</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># 1) configure syslog to accept network log events.  This is done</span><br>    <span class="hljs-comment">#    by adding the &#x27;-r&#x27; option to the SYSLOGD_OPTIONS in</span><br>    <span class="hljs-comment">#    /etc/sysconfig/syslog</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment"># 2) configure local2 events to go to the /var/log/haproxy.log</span><br>    <span class="hljs-comment">#   file. A line like the following can be added to</span><br>    <span class="hljs-comment">#   /etc/sysconfig/syslog</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#    local2.*                       /var/log/haproxy.log</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-attribute">log</span>         <span class="hljs-number">127.0.0.1</span> local2<br><br>    <span class="hljs-attribute">chroot</span>      /var/lib/haproxy<br>    <span class="hljs-attribute">pidfile</span>     /var/run/haproxy.pid<br>    <span class="hljs-attribute">maxconn</span>     <span class="hljs-number">4000</span><br>    <span class="hljs-attribute">user</span>        haproxy<br>    <span class="hljs-attribute">group</span>       haproxy<br>    <span class="hljs-attribute">daemon</span><br><br>    <span class="hljs-comment"># turn on stats unix socket</span><br>    <span class="hljs-attribute">stats</span> socket /var/lib/haproxy/stats<br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># common defaults that all the &#x27;listen&#x27; and &#x27;backend&#x27; sections will</span><br><span class="hljs-comment"># use if not designated in their block</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">defaults</span><br>    <span class="hljs-attribute">mode</span>                    http<br>    <span class="hljs-attribute">log</span>                     global<br>    <span class="hljs-attribute">option</span>                  httplog<br>    <span class="hljs-attribute">option</span>                  dontlognull<br>    <span class="hljs-attribute">option</span> http-server-close<br>    <span class="hljs-attribute">option</span> forwardfor       except <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">8</span><br>    <span class="hljs-attribute">option</span>                  redispatch<br>    <span class="hljs-attribute">retries</span>                 <span class="hljs-number">3</span><br>    <span class="hljs-attribute">timeout</span> http-request    <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">timeout</span> queue           <span class="hljs-number">1</span>m<br>    <span class="hljs-attribute">timeout</span> connect         <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">timeout</span> client          <span class="hljs-number">1</span>m<br>    <span class="hljs-attribute">timeout</span> server          <span class="hljs-number">1</span>m<br>    <span class="hljs-attribute">timeout</span> http-keep-alive <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">timeout</span> check           <span class="hljs-number">10</span>s<br>    <span class="hljs-attribute">maxconn</span>                 <span class="hljs-number">3000</span><br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># apiserver frontend which proxys to the masters</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">frontend</span> apiserver<br>    <span class="hljs-attribute">bind</span> *:<span class="hljs-number">6443</span>   ## 注意这里的端口，其实就是 haproxy 的端口，后面加入集群的时候需要用到<br>    <span class="hljs-attribute">mode</span> tcp<br>    <span class="hljs-attribute">option</span> tcplog<br>    <span class="hljs-attribute">default_backend</span> apiserver<br><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-comment"># round robin balancing for apiserver</span><br><span class="hljs-comment">#---------------------------------------------------------------------</span><br><span class="hljs-attribute">backend</span> apiserver<br>    <span class="hljs-attribute">option</span> httpchk GET /healthz<br>    <span class="hljs-attribute">http</span>-check expect status <span class="hljs-number">200</span><br>    <span class="hljs-attribute">mode</span> tcp<br>    <span class="hljs-attribute">option</span> ssl-hello-chk<br>    <span class="hljs-attribute">balance</span>     roundrobin<br>        <span class="hljs-attribute">server</span> k8s-master1 <span class="hljs-number">192.168.31.86:6443</span> check<br>        <span class="hljs-attribute">server</span> k8s-master2 <span class="hljs-number">192.168.31.82:6443</span> check<br>        <span class="hljs-attribute">server</span> k8s-master3 <span class="hljs-number">192.168.31.83:6443</span> check<br></code></pre></td></tr></table></figure><p>这里主要关注两个地方，一个是 frontend apiserver 下的 bind，该字段用于定义 HAproxy 监听的地址；另一个是 backend apiserver 下的 balance     roundrobin 字段，这里指定为你的 k8s master 节点的 IP 地址。</p><p>HAproxy 的配置文件是通用的，所以可以直接拷贝到另一台 LB 主机（当然手动复制粘贴问题也不大，毕竟只有 2 个节点）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp /etc/haproxy/haproxy.cfg  root@192.168.31.91:/etc/haproxy<br></code></pre></td></tr></table></figure><h2 id="启动服务并配置开机自启"><a href="#启动服务并配置开机自启" class="headerlink" title="启动服务并配置开机自启"></a>启动服务并配置开机自启</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable haproxy --now<br>systemctl enable keepalived --now<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>我在执行这一步时，遇到了 haproxy 进程已经启动（ps -rf | grep haproxy），但却没有监听对应端口的情况（lsof -i :6443），最终通过 <code>systemctl restart haproxy</code> 重启 HAproxy 解决了。</p>          </div><h2 id="验证-VIP-漂移"><a href="#验证-VIP-漂移" class="headerlink" title="验证 VIP 漂移"></a>验证 VIP 漂移</h2><p>看一下这两台主机的网卡情况，首先看一下 lb1 这台作为 master 节点的主机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br>// .... 省略其他网卡，我在配置文件里指定的是 eth1 这种网卡<br>3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 52:54:00:47:ec:3f brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.31.90/24 brd 192.168.31.255 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet 192.168.31.110/32 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5054:ff:fe47:ec3f/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以看到这张网卡有两个 IPv4 地址，其中 192.168.31.110&#x2F;32 就是我们定义的 keepalived VIP。</p><p>再看一下作为备节点的这台主机的网卡情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr<br>// .... 省略其他网卡<br>3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 52:54:00:56:20:5e brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.31.91/24 brd 192.168.31.255 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5054:ff:fe56:205e/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>这台主机的 eth1 网卡并没有绑定 VIP</p><p>然后我停掉 master 节点的 HAproxy 进程，看看 VIP 会不会漂移到 backup 节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 master 节点上执行，停止这台机器上的 haproxy 进程</span><br>systemctl stop haproxy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查一下</span><br>ps -ef | grep haproxy<br>root       12382   11336  0 22:34 pts/1    00:00:00 grep --color=auto haproxy # 这个进程是 grep 的，与 haproxy 本身无关<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后看一下 IP：</span><br>ip addr<br>3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000<br>    link/ether 52:54:00:47:ec:3f brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.31.90/24 brd 192.168.31.255 scope global eth1<br>       valid_lft forever preferred_lft forever<br>    inet 192.168.31.110/24 scope global secondary eth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::5054:ff:fe47:ec3f/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><h3 id="验证不通过"><a href="#验证不通过" class="headerlink" title="验证不通过"></a>验证不通过</h3><p>发现 VIP 并没有漂移！并且我已经检查过，backup 节点的 HAproxy 是正常运行的，然后我又试了下 stop master 节点的 keepalived 进程，发现此时 VIP 会漂移到 backup 节点，但是一旦重新启动 master 节点上的 keepalived，那么 VIP 又会重新漂移到 master 节点，这显然不符预期啊？我们期望的是用 keepalived 对 HAproxy 做高可用，如果某个节点上的 HAproxy 都已经挂掉了，VIP 却还停留在该节点上，那到时候 k8s 还是会请求到这个节点，但是又无法转发给实际的 k8s 控制节点，导致无法工作。不知道为啥会出现这种情况</p><p>我在 <a href="https://serverfault.com/questions/764557/keepalived-registers-failure-but-wont-failover">serverfault </a>上找到了一个情况相同的问题，但是并没有人给出靠谱的解决方法</p><h3 id="终于解决了"><a href="#终于解决了" class="headerlink" title="终于解决了"></a>终于解决了</h3><p>我尝试使用英文，在谷歌上搜索 <a href="https://serverfault.com/questions/718132/keepalived-vrrp-script-not-failing-over">keepalived VRRP_script not failing over</a>，最终找到了这个靠谱的回答。</p><p>原因出在 keepalived 配置中的 priority，即优先级，貌似 keepalived 是严格按照 priority 来决定谁拥有 VIP 的，也就是说，只有在 <strong>另一台主机的 priority 高于当前拥有 VIP 的主机的 priority 的情况下，VIP 才会进行漂移</strong>。在上面的配置中，我们给 master 节点的 priority 设置成了 100，而 backup 节点的 priority 设置为了 50，两者相差 50！而我们在 <code>vrrp_script chk_haproxy</code> 中定义的 <code>weight</code> 值为 2，也就是当前节点如果成功执行脚本且没有返回错误，则给当前节点的 priority + 2（这里貌似是只有第一次执行成功会 +2，之后再执行成功就不会 +2 了？不太确定），然后现在的情况是：master 执行失败，priority 保持原样 &#x3D; 100，backup 执行成功，priority + 2 &#x3D; 52，backup 的 priority 依然远小于 master，所以 VIP 依然保持在 master 节点，不会漂移到  backup 节点。</p><p><strong>解决这个问题的方法也很简单，我修改了一下 master 节点的 priority，将其改为 50，而 backup 的 priority 我改成了 49，这样二者只相差 1</strong>，如果 backup 执行脚本成功，则其 priority 变为 51，master 执行失败，则依然为 50，这样就可以保证 backup 的优先级大于 master，从而实现 VIP 的漂移。而如果 master 上的 haproxy 恢复正常了，则脚本执行成功， priority 又会变成 50 + 2 &#x3D; 52，大于 backup 的 priority，所以 VIP 的掌控权又会回到 master 手中，符合我们的需求。</p><div class="note note-success">            <p>经过我的测试，发现 priority 的增减逻辑是这样的：</p><ul><li><p>如果 <code>vrrp_script</code> 执行成功，且是第一次执行成功，则 priority + 2</p></li><li><p>如果 <code>vrrp_script</code> 执行失败，且是第一次执行失败，则 priority - 2</p><p>可以通过日志佐证这一点，这是 master 节点的日志，可以通过 <code>journalctl -u keepalived.service</code> 查看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: Script `chk_haproxy` now returning <span class="hljs-number">0</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: VRRP_Script(chk_haproxy) succeeded<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Changing effective priority from <span class="hljs-number">50</span> to <span class="hljs-number">52</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">55</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) received lower priority (<span class="hljs-number">51</span>) advert from <span class="hljs-number">19</span>&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">56</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) received lower priority (<span class="hljs-number">51</span>) advert from <span class="hljs-number">19</span>&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">57</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) received lower priority (<span class="hljs-number">51</span>) advert from <span class="hljs-number">19</span>&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">23</span> <span class="hljs-number">23</span>:<span class="hljs-number">56</span>:<span class="hljs-number">58</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Entering MASTER STATE<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">33</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: Script `chk_haproxy` now returning <span class="hljs-number">1</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">33</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: VRRP_Script(chk_haproxy) failed (exited with statu&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">33</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Changing effective priority from <span class="hljs-number">52</span> to <span class="hljs-number">50</span><br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">36</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Master received advert from <span class="hljs-number">192.168.31.91</span> w&gt;<br><span class="hljs-attribute">Jun</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">36</span> lb1 Keepalived_vrrp[<span class="hljs-number">1905</span>]: (VI_1) Entering BACKUP STATE<br></code></pre></td></tr></table></figure><p>23:56:57 时，我重启了 master 节点的 haproxy ，所以脚本执行成功，日志输出 <code>VRRP_Script(chk_haproxy) succeeded</code> ，对应的会 <code>Changing effective priority from 52 to 50</code>，并且只 + 2 了一次，之后都没有变化了，这代表只有第一次成功时会增加。在 00:00:33 的时候，我 stop 了 master 节点的 haproxy，导致脚本执行失败，日志输出 <code>VRRP_Script(chk_haproxy) failed (exited with statu&gt;</code>，然后 <code>(VI_1) Changing effective priority from 52 to 50</code>。</p></li></ul>          </div><p>除此之外，好像也可以修改 <code>vrrp_script</code> 的 weight 为负数，这样执行失败就会扣除对应节点的优先级？这种方法我这里就先不尝试了。</p><div class="note note-success">            <p>Tips：<br>可以使用 <code>kill -HUP $(cat /var/run/keepalived.pid)</code> 命令，让 keepalived 重载配置文件。<br>使用 <code>journalctl -u keepalived.service</code> 查看 keepalived 的日志。</p>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 滑动窗口与流量控制</title>
    <link href="/2023/06/06/tcp-liu-liang-kong-zhi/"/>
    <url>/2023/06/06/tcp-liu-liang-kong-zhi/</url>
    
    <content type="html"><![CDATA[<h1 id="流量控制与滑动窗口图解"><a href="#流量控制与滑动窗口图解" class="headerlink" title="流量控制与滑动窗口图解"></a>流量控制与滑动窗口图解</h1><blockquote><p>ps: 下面的图片皆源自 B 站课程 <a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60&vd_source=2ff613424b86c58a71ba91b7304ffe9b">计算机网络微课堂（有字幕无背景音乐版）</a></p></blockquote><p>当主机 A 与 B 建立 TCP 连接时，B（接收方）告诉 A（发送方），自己的接收窗口大小为 400。</p><p>这意味着主机 A 就可以一口气发送 400 字节的数据，而无需等待 B 确认。</p><p>如下图所示，A 的发送窗口为 400，这表示在窗口填满以前，A 都可以直接发送报文，而无需等待 B 的确认，所以 A 将 1-100，101-200，201-300 以及 301-400 的数据都发送出去了。</p><p>但不巧的是，201-300 的报文丢失了，所以 B 的响应 ack 值的 201，<strong>表示我现在期望收到从 201 开始的报文，即：201 以前的报文我都已经收到了</strong>，这便是 TCP 的 <strong>累计确认</strong>。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_liu_liang_kong_zhi1.jpg"></p><p>主机 A 知道这个消息以后，就可以开始 <strong>滑动窗口</strong> 了，滑动的正是已经被主机 B 接收到的报文，即 1-200，这部分既然已经被对方成功接收到了，自然就可以从窗口中移除了，如下图所示，1-100 和 101-200 这两部分已经从窗口滑出了。</p><p>同时，B 还通知 A，我的接收窗口有变，之前能接受 400 字节的数据，但是现在只能接收 300 字节了，主机 A 收到这个消息后，也会同样调整自己的发送窗口大小，使其与主机 B 的接收窗口大小相同。<strong>这便是主机 B 对主机 A 的流量控制</strong>。</p><p>所以现在，窗口还剩 200 字节的空位，这意味着 A 还能继续发送 301-400 和 401-500 两个报文，而 201-300 这个报文因为还未被对方接收到，所以依然停留在窗口内。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_llkz2.jpg"></p><p>现在，A 一共发送了序号 201-500 一共 3 个报文，但是这其中的 201-300 的报文在发送后的一段时间内，没有收到对方的 ack 回复，因此会触发超时重传，A 会判定该报文可能已丢失，重新发送。</p><p>这次 B 成功收到 201-300 这个报文了，此外，先前发送的 301-400 和 401-500 这两个报文，也被 B 成功接收了，所以 B 回复的 ack 值就会是 501，表示 501 以前的包我都已经收到了，现在我期望收到的下一个包从序号 501 开始。</p><p>此外，B 在响应内容中，又对自己的接收窗口进行了调整，调整为了 100，这是 B 对 A 的 <strong>第二次流量控制</strong>。如下图所示。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_llkz3.jpg"></p><p>现在，A 可以将序号为 201-500 这几个已经被 B 接收到的报文，从自己的发送窗口中滑出了，同时对自己的窗口进行调整，使其大小为 100。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp_llkz4.jpg"></p><p>通过上面的演示，应该对滑动窗口和流量控制有了比较清晰的认识了。</p><h1 id="TODO-窗口死锁"><a href="#TODO-窗口死锁" class="headerlink" title="TODO 窗口死锁"></a>TODO 窗口死锁</h1>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Istio Bookinfo</title>
    <link href="/2023/05/27/istio-bookinfo/"/>
    <url>/2023/05/27/istio-bookinfo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Bookinfo 是 istio 官方提供的一个演示应用，并且官方也给出了详细的功能描述：</p><blockquote><p>这个应用模仿在线书店的一个分类，显示一本书的信息。 页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。</p><p>Bookinfo 应用分为四个单独的微服务：</p><ul><li><code>productpage</code>. 这个微服务会调用 <code>details</code> 和 <code>reviews</code> 两个微服务，用来生成页面。</li><li><code>details</code>. 这个微服务中包含了书籍的信息。</li><li><code>reviews</code>. 这个微服务中包含了书籍相关的评论。它还会调用 <code>ratings</code> 微服务。</li><li><code>ratings</code>. 这个微服务中包含了由书籍评价组成的评级信息。</li></ul><p><code>reviews</code> 微服务有 3 个版本：</p><ul><li>v1 版本不会调用 <code>ratings</code> 服务。</li><li>v2 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。</li><li>v3 版本会调用 <code>ratings</code> 服务，并使用 1 到 5 个红色星形图标来显示评分信息。</li></ul></blockquote><p>我们可以通过 bookinfo 了解到 istio 的</p><p>首先看看创建 bookinfo 用到的几个 yaml 文件</p><h2 id="bookinfo-yaml"><a href="#bookinfo-yaml" class="headerlink" title="bookinfo.yaml"></a>bookinfo.yaml</h2><p>这个 yaml 定义了一些 bookinfo 相关的 Deploy，Service，ServiceAccount，没什么好说的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Copyright Istio Authors</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">#   you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">#   You may obtain a copy of the License at</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment">#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment">#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment">#   See the License for the specific language governing permissions and</span><br><span class="hljs-comment">#   limitations under the License.</span><br><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># This file defines the services, service accounts, and deployments for the Bookinfo sample.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To apply all 4 Bookinfo services, their corresponding service accounts, and deployments:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Alternatively, you can deploy any resource separately:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml -l service=reviews # reviews Service</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml -l account=reviews # reviews ServiceAccount</span><br><span class="hljs-comment">#   kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml -l app=reviews,version=v3 # reviews-v3 Deployment</span><br><span class="hljs-comment">##################################################################################################</span><br><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Details service</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">details</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">details</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-details</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">details</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">details-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">details</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-details</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">details</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-details-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Ratings service</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ratings</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">ratings</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-ratings</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">ratings</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ratings-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">ratings</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-ratings</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ratings</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-ratings-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Reviews service</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">reviews</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-reviews</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">reviews</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-reviews</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-reviews-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_DIR</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/tmp/logs&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/opt/ibm/wlp/output</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-v2</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-reviews</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-reviews-v2:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_DIR</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/tmp/logs&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/opt/ibm/wlp/output</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-v3</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-reviews</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-reviews-v3:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LOG_DIR</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/tmp/logs&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/opt/ibm/wlp/output</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wlp-output</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-comment"># Productpage services</span><br><span class="hljs-comment">##################################################################################################</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">productpage</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">productpage</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9080</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-productpage</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">account:</span> <span class="hljs-string">productpage</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">productpage-v1</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">bookinfo-productpage</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.io/istio/examples-bookinfo-productpage-v1:1.17.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><h2 id="bookinfo-gateway-yaml"><a href="#bookinfo-gateway-yaml" class="headerlink" title="bookinfo-gateway.yaml"></a>bookinfo-gateway.yaml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo-gateway</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span> <span class="hljs-comment"># use istio default controller</span><br>  <span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br>    <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*&quot;</span><br>  <span class="hljs-attr">gateways:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bookinfo-gateway</span><br>  <span class="hljs-attr">http:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/productpage</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/static</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/login</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/logout</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api/v1/products</span><br>    <span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">port:</span><br>          <span class="hljs-attr">number:</span> <span class="hljs-number">9080</span><br><br></code></pre></td></tr></table></figure><p>这个 yaml 里面包括了<code>Gateway</code> （注意是其 apiVersion 是 istio，不是 k8s 原生的 Gateway 资源 ）和 <code>VirtualService</code> 两种资源，下面来简单说明一下这两个资源。</p><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p><code>Gateway</code> 在网格边缘接收外部访问，并将流量转发到网格内的服务。<code>Gateway</code> 一般需要和 <code>VirtualService</code> 配合使用，其中 <code>Gateway</code> 定义了服务怎样从外面访问，而 <code>VirtualService</code> 定义了请求进入到内部后，其流量如何流转。</p><p>在这个 yaml 里，<code>Gateway</code> 包含了 <code>selector</code> 和 <code>servers</code> 两个字段，下面对这两个字段的作用进行一下记录。</p><h4 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h4><p>Gateway 的  <code>spec.selector</code> 字段用于指定入口处运行了 Envoy 的 Pod，这些 Pod 会执行 Gateway 定义的规则。在 bookinfo 里指定的是<code>istio: ingressgateway</code> ，即所有拥有 <code>istio: ingressgateway</code> label 的 Pod。这些 Pod 由 istio-system namespace 下的名为  istio-ingressgateway 的 Deploy 创建，可以看一下这个 Deploy 的定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">k describe -n istio-system deploy istio-ingressgateway<br><br>spec:<br>  template:<br>    metadata:<br>    # .... 省略<br>      labels:<br>        app: istio-ingressgateway<br>        istio: ingressgateway # 这里<br>    spec:<br>      image: docker.io/istio/proxyv2:1.17.2<br>      imagePullPolicy: IfNotPresent<br>      name: istio-proxy<br></code></pre></td></tr></table></figure><p>可以看到在 label 这里定义了这个 <code>istio: ingressgateway</code> label，同时还注意到其使用的镜像是 <code>docker.io/istio/proxyv2:1.17.2</code>，<code>docker.io/istio/proxyv2</code> 是 Istio 中的 Envoy 代理镜像，表明其创建的 Pod 运行的都是 Envoy，用于接收外部请求并将其转发到 Istio 网格中的适当服务。</p><h4 id="servers"><a href="#servers" class="headerlink" title="servers"></a>servers</h4><p>TODO：spec.servers</p><p>TODO：Gateway 貌似需要通过定义一个 service 来进行访问，验证这个猜想</p><p>发现在 istio-system 命名空间下有一个 istio-ingressgateway service，貌似是安装 istio 后自动创建的？不太清楚，并且监听了这些端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">15021</span>/TCP,<span class="hljs-number">80</span>/TCP,<span class="hljs-number">443</span>/TCP,<span class="hljs-number">31400</span>/TCP,<span class="hljs-number">15443</span>/TCP<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">k</span> <span class="hljs-string">describe</span> <span class="hljs-string">svc</span> <span class="hljs-string">-n</span> <span class="hljs-string">istio-system</span>                   <span class="hljs-string">istio-ingressgateway</span><br><span class="hljs-attr">Name:</span>                     <span class="hljs-string">istio-ingressgateway</span><br><span class="hljs-attr">Namespace:</span>                <span class="hljs-string">istio-system</span><br><span class="hljs-attr">Labels:</span>                   <span class="hljs-string">app=istio-ingressgateway</span><br>                          <span class="hljs-string">install.operator.istio.io/owning-resource=unknown</span><br>                          <span class="hljs-string">install.operator.istio.io/owning-resource-namespace=istio-system</span><br>                          <span class="hljs-string">istio=ingressgateway</span> <span class="hljs-comment"># 注意这里？代理了 ingress Envoy pod ？</span><br></code></pre></td></tr></table></figure><h3 id="VirtualService"><a href="#VirtualService" class="headerlink" title="VirtualService"></a>VirtualService</h3><p><code>VirtualService</code> 定义了对特定目标服务的一组流量规则，即满足什么条件的流量被哪个后端处理。</p><p>先来看看 <code>VirtualService</code> 有哪些字段</p><h4 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h4><p>这里的 hosts 定义貌似和 Gateway 中某个 servers 中定义的 Host 有关系，会判断二者的 hosts 是否匹配，如果匹配，则代表当你访问该 Gateway servers 时，会进一步走 VirtualService 定义的流量规则，为了验证这个猜想是否正确，可以手动实践一下：</p><p>首先需要在 &#x2F;etc&#x2F;hosts 中配置一下我们将要添加的域名，其中 IP 从 istio-ingressgateway 这个 service 中获得，因为我使用的是 NodePort 类型的，所以这里的 IP 可以设置为集群内任意一个节点的 IP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 192.168.31.108 test.com &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p>修改 Gateway Resource 的声明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">k edit gw -n meshapp bookinfo-gateway<br></code></pre></td></tr></table></figure><p>添加一个 server，声明如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span><br>  <span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br>  <span class="hljs-comment"># 新添加的 server</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">test.com</span><br>    <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http1</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">9527</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br></code></pre></td></tr></table></figure><p>这里我添加的新的 server 将通过 test.com 作为 host 来访问（似乎必须这样，如果用 IP 访问会 404），当然还要加上对应的端口号（比如 <a href="http://test.com:31225/login%EF%BC%89%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E5%AE%9A%E4%B9%89%E4%B8%BA">http://test.com:31225/login），这里我定义为</a> 9527 这个端口。</p><p>然后我们再添加一个新的 VirtualService ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bookinfo1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test.com</span> <span class="hljs-comment"># 与 gateway 新添加的 server 的 hosts 相匹配</span><br>  <span class="hljs-attr">gateways:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">bookinfo-gateway</span><br>  <span class="hljs-attr">http:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/productpage</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/static</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/login</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">/logout</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api/v1/products</span><br>    <span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>        <span class="hljs-attr">port:</span><br>          <span class="hljs-attr">number:</span> <span class="hljs-number">9080</span><br></code></pre></td></tr></table></figure><p>修改 service，新暴露一个端口，让其指向我们新创建的 Gateway server 的 port（即 targetPort），也就是 9527，并且该 server 也监听在 9527 端口，然后通过 NodePort 31225 暴露给外界。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http3</span><br>  <span class="hljs-attr">nodePort:</span> <span class="hljs-number">31225</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span><br>  <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9527</span><br></code></pre></td></tr></table></figure><p>现在我们就可以尝试通过 serviceIP + nodePort 来访问这个新定义的服务了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://test.com:31225/productpage<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;Simple Bookstore App&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>可以看到我们可以成功访问这个 server。</p><blockquote><p>❓为什么明明是一样的 URL，但是通过 curl 可以访问，chrome 访问却会报错 404？</p><p>好吧，发现是开了代理的原因，把 clash 关了就好了</p><p>如果你尝试使用 Postman 访问，哪些需要取消勾选请求头中默认的 Host，然后自己创建一个 Host，指定值为 <code>test.com</code> 或者 <code>test.com:31225</code>，似乎 curl 和 chrome 访问时都会默认加上这个请求头</p></blockquote><h2 id="destination-rule-all-yaml"><a href="#destination-rule-all-yaml" class="headerlink" title="destination-rule-all.yaml"></a>destination-rule-all.yaml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">productpage</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">productpage</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">reviews</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v3</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v3</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ratings</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">ratings</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2-mysql</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2-mysql</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2-mysql-vm</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2-mysql-vm</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">details</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">details</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><h3 id="DestinationRule"><a href="#DestinationRule" class="headerlink" title="DestinationRule"></a>DestinationRule</h3><p><code>VirtualService</code> 和 <code>DestinationRule</code> 有什么区别？</p>]]></content>
    
    
    
    <tags>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Multipass 快速搭建虚拟机</title>
    <link href="/2023/05/19/multipass-create-vm-so-easy/"/>
    <url>/2023/05/19/multipass-create-vm-so-easy/</url>
    
    <content type="html"><![CDATA[<p>之前搭建 k8s 集群一直使用的是 Vmware，虽然总的来说用起来还算 OK，但是总感觉比较重，安装系统什么的也比较耗时（后来发现可以先创建好一台，然后克隆），加上 k8s 老被我搞坏，每次搞坏又都要重新创建集群（貌似可以做一个快照），搞得有点烦，就想看看有没有什么别的虚机工具，能够方便且快速的搭建虚机，最好还能支持命令行操作，找来找去，最终还是找到了之前用过的老朋友 multipass</p><h1 id="开始创建"><a href="#开始创建" class="headerlink" title="开始创建"></a>开始创建</h1><p>只需要使用一行命令即可快速搭建一台虚机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --name vm<br></code></pre></td></tr></table></figure><p>PS：如果是第一次创建需要拉取镜像，会稍微慢一些，之后创建就很快了。</p><h1 id="创建时指定配置"><a href="#创建时指定配置" class="headerlink" title="创建时指定配置"></a>创建时指定配置</h1><p>此外，你还可以在创建时指定虚机的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --name vm --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure><h1 id="创建桥接模式的虚机"><a href="#创建桥接模式的虚机" class="headerlink" title="创建桥接模式的虚机"></a>创建桥接模式的虚机</h1><p>默认情况下，使用 multipass 创建出来的虚机只能被宿主机访问，同局域网的其他机器无法访问，如果你想创建类似 Vmware 桥接模式的虚机，让同局域网任意机器访问，可以在创建时指定 <code>--network</code> 参数实现。</p><p>首先执行 <code>multipass networks</code> 查看一下宿主机的网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass networks<br>Name              Type      Description<br>Default Switch    switch    Virtual Switch with internal networking<br>ExtSwitch (WLAN)  switch    Virtual Switch with external networking via &quot;WLAN&quot; (Created by Multipass)<br>WLAN              wifi      Intel(R) Wi-Fi 6E AX210 160MHz<br>��̫��             ethernet  Intel(R) Ethernet Connection (17) I219-V<br></code></pre></td></tr></table></figure><p>然后选择一张物理网卡作为 –network 的值，这里我选择 WLAN 这张：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --name vm --network WLAN --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure><p>然后创建出来的虚拟机会分配一个局域网 IP，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass list<br>Name                    State             IPv4             Image<br>kmaster1                Running           172.21.137.51    Ubuntu 22.04 LTS<br>                                          192.168.31.108<br>kmaster2                Running           172.21.135.58    Ubuntu 22.04 LTS<br>                                          192.168.31.63<br>kmaster3                Running           172.21.129.190   Ubuntu 22.04 LTS<br>                                          192.168.31.125<br>kworker1                Running           172.21.130.113   Ubuntu 22.04 LTS<br>                                          192.168.31.171<br>kworker2                Running           172.21.131.101   Ubuntu 22.04 LTS<br>                                          192.168.31.73<br>kworker3                Running           172.21.137.108   Ubuntu 22.04 LTS<br>                                          192.168.31.253<br></code></pre></td></tr></table></figure><p>可以看到，每台虚机都分配了一个 192.168.31.0 网段的 IP，现在你就可以使用同局域网的任意一台机器，对这些虚机进行访问了。</p><p>而且这个东西最 NB 的是，宿主机的 clash tun 模式对这些虚机也有效，我之前使用 Vmware 桥接模式搭建的虚机是无效的，不知道怎么做到的</p><h1 id="创建时指定配置-1"><a href="#创建时指定配置-1" class="headerlink" title="创建时指定配置"></a>创建时指定配置</h1><p>我们创建虚机后，往往都需要做一些配置，比如设置 root 用户，配置 ssh 允许以 root 身份登录，安装一些包等等，有点麻烦，更麻烦的是如果要搭建的是集群，那么就要在每台虚拟机上都执行这一系列操作，想想就蛋疼，有没有一种可能，通过配置文件定义好这些配置行为，然后创建时通过指定配置文件的方式，自动执行这一系列行为呢？看了一下官方文档，发现 multipass 还真支持</p><p>根据我的要求，我的配置文件定义如下（配置文件的具体参数，可以查阅官方文档）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#cloud-config</span><br><span class="hljs-attr">users:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">lock_passwd:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">plain_text_passwd:</span> <span class="hljs-string">&quot;root&quot;</span><br>    <span class="hljs-attr">sudo:</span> <span class="hljs-string">ALL=(ALL)</span> <span class="hljs-string">NOPASSWD:ALL</span><br>    <span class="hljs-attr">shell:</span> <span class="hljs-string">/bin/bash</span><br><br><span class="hljs-attr">ssh_pwauth:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">write_files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/ssh/sshd_config.d/99-allow-root-login.conf</span><br>    <span class="hljs-attr">content:</span> <span class="hljs-string">|</span><br><span class="hljs-string">      PermitRootLogin yes</span><br><span class="hljs-string"></span><br><span class="hljs-attr">packages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">socat</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">conntrack</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ebtables</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ipset</span><br><br></code></pre></td></tr></table></figure><blockquote><p><strong>&#x2F;etc&#x2F;ssh&#x2F;sshd_config.d&#x2F;99-allow-root-login.conf 是什么文件？和 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 有什么区别 ?</strong></p><p>文件 <code>/etc/ssh/sshd_config.d/99-allow-root-login.conf</code> 是 OpenSSH 服务器配置文件的一个片段文件，它用于存储自定义的配置选项，以覆盖主配置文件 <code>/etc/ssh/sshd_config</code> 中的默认选项。这种分离的配置文件结构使得管理和组织配置更加灵活和可扩展。</p><p>主配置文件 <code>/etc/ssh/sshd_config</code> 包含了 OpenSSH 服务器的所有配置选项。它是一个全局配置文件，影响整个服务器的行为。您可以在此文件中设置各种选项，例如监听端口、允许的认证方式、访问控制规则等。</p><p>而 <code>/etc/ssh/sshd_config.d/</code> 目录是用于存放额外的配置文件片段的目录。这些配置文件片段以 <code>.conf</code> 扩展名结尾，并按照一定的顺序加载到主配置文件中。每个片段文件包含一组相关的配置选项，可以根据需要进行添加、修改或删除。这样的分离配置文件的机制使得配置管理更加方便，可以避免直接修改主配置文件，而是通过添加或修改相应的片段文件来实现自定义配置。</p><p>例如，<code>/etc/ssh/sshd_config.d/99-allow-root-login.conf</code> 文件可以包含一条配置选项 <code>PermitRootLogin yes</code>，用于允许 root 用户通过 SSH 登录。这样的自定义配置片段文件可以方便地管理和维护，而不必直接修改主配置文件。</p></blockquote><p>然后在创建虚机时，通过 –cloud-init [filepath.yaml] 的方式，指定要应用的配置文件，非常的方便：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --cloud-init cloud-config.yaml --name vm --network WLAN --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure><p>现在想搭建一个集群就非常容易了，比如下面的命令就可以创建 6 台虚机，组成一个集群：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">multipass launch --cloud-init cloud-config.yaml --name kmaster1 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kmaster2 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kmaster3 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kworker1 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kworker2 --network WLAN --cpus 4 --disk 150G --memory 8G<br>multipass launch --cloud-init cloud-config.yaml --name kworker3 --network WLAN --cpus 4 --disk 150G --memory 8G<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>multipass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s loadbalancer —— Metallb [draft] </title>
    <link href="/2023/05/08/metallb/"/>
    <url>/2023/05/08/metallb/</url>
    
    <content type="html"><![CDATA[<h1 id="安装（Layer2-模式）"><a href="#安装（Layer2-模式）" class="headerlink" title="安装（Layer2 模式）"></a>安装（Layer2 模式）</h1><p>首先需要查看你的 kube-proxy 使用的是不是 ipvs 模式，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit configmap -n kube-system kube-proxy<br></code></pre></td></tr></table></figure><p>其中有一个配置项 mode，如果它的值是 ipvs，则表示使用的 ipvs 模式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">config.conf:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="hljs-string">    mode: ipvs # 这里</span><br></code></pre></td></tr></table></figure><p>这种情况下，你需要修改 ipvs 的配置，启用严格的 ARP，将 strictARP 设置为 true，这样 k8s 集群中的<code>kube-proxy</code> 就会停止响应<code>kube-ipvs0</code> 网卡之外的其他网卡的 arp 请求，进而让 MetalLB 接手处理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ipvs:</span><br>  <span class="hljs-attr">strictARP:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>然后执行下面的命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.9/config/manifests/metallb-native.yaml<br></code></pre></td></tr></table></figure><p>安装完成后，为了让 metallb 能够给 service 分配 IP，还需要创建一个 <code>IPAddressPool</code>CR ，并在该 CR 中定义 IP 池的范围，这样 metallb 才能知道有哪些 IP 可以分配。</p><p><strong>注意：指定的 IP 池需要和集群节点在同一网段，也就是同一局域网内。</strong></p><p>如果指定了非同一局域网的 IP 池地址，那么将收不到 ARP 响应报文，导致无法通过 EXTERNAL-IP 访问（这里还没太搞懂）</p><blockquote><p>我指定的 IP 池是 192.168.31.0&#x2F;24，结果这货直接给我的 service 分配了 192.168.31.0，有点离谱，不知道为啥</p><p>更新：</p><p>需要指定 <code>avoidBuggyIPs: true</code> 来避免分配网络地址和广播地址。</p><p>而且我不能同时指定 CIDR 和具体的 IP 范围，比如我下面指定的 192.168.31.0&#x2F;24 和 192.168.31.150-192.168.31.160，会报错</p><p>Error from server (CIDR “192.168.31.150&#x2F;31” in pool “first-pool” overlaps with already defined CIDR “192.168.31.0&#x2F;24”): error when creating “IPAddressPool.yaml”: admission webhook “ipaddresspoolvalidationwebhook.metallb.io” denied the request: CIDR “192.168.31.150&#x2F;31” in pool “first-pool” overlaps with already defined CIDR “192.168.31.0&#x2F;24”</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; IPAddressPool.yaml<br>apiVersion: metallb.io/v1beta1<br>kind: IPAddressPool<br>metadata:<br>  name: first-pool<br>  namespace: metallb-system<br>spec:<br>  addresses:<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">可分配的 IP 地址,可以指定多个，包括 ipv4、ipv6</span><br><span class="hljs-meta prompt_">  #</span><span class="language-bash">- 192.168.31.0/24</span><br>  - 192.168.31.150-192.168.31.160<br>  avoidBuggyIPs: true # 避免分配网络地址和广播地址<br>EOF<br><br>kubectl apply -f IPAddressPool.yaml<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建一个 nginx deploy 以及一个 loadbalance 类型的 svc 来测试。</p><p>使用以下命令创建 nginx deploy：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; nginx-dp.yaml</span><br><span class="hljs-string">apiVersion: apps/v1</span><br><span class="hljs-string">kind: Deployment</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: nginx-deployment</span><br><span class="hljs-string">  labels:</span><br><span class="hljs-string">    app: nginx</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  replicas: 3</span><br><span class="hljs-string">  selector:</span><br><span class="hljs-string">    matchLabels:</span><br><span class="hljs-string">      app: nginx</span><br><span class="hljs-string">  template:</span><br><span class="hljs-string">    metadata:</span><br><span class="hljs-string">      labels:</span><br><span class="hljs-string">        app: nginx</span><br><span class="hljs-string">    spec:</span><br><span class="hljs-string">      containers:</span><br><span class="hljs-string">      - name: nginx</span><br><span class="hljs-string">        image: docker.io/nginx:latest</span><br><span class="hljs-string">        ports:</span><br><span class="hljs-string">        - containerPort: 80</span><br><span class="hljs-string">EOF</span><br><br>kubectl apply -f nginx-dp.yaml<br></code></pre></td></tr></table></figure><p>使用以下命令创建 nginx-svc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; nginx-svc.yaml</span><br><span class="hljs-string">apiVersion: v1</span><br><span class="hljs-string">kind: Service</span><br><span class="hljs-string">metadata:</span><br><span class="hljs-string">  name: nginx</span><br><span class="hljs-string">  labels:</span><br><span class="hljs-string">    app: nginx</span><br><span class="hljs-string">spec:</span><br><span class="hljs-string">  selector:</span><br><span class="hljs-string">    app: nginx</span><br><span class="hljs-string">  ports:</span><br><span class="hljs-string">  - name: nginx-port</span><br><span class="hljs-string">    protocol: TCP</span><br><span class="hljs-string">    port: 80</span><br><span class="hljs-string">    targetPort: 80</span><br><span class="hljs-string">  type: LoadBalancer</span><br><span class="hljs-string">EOF</span><br><br>kubectl apply -f nginx-svc.yaml<br></code></pre></td></tr></table></figure><p>然后查看 svc，看看是不是真的分配了 ExternalIP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">kubectl get svc<br>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE<br>kubernetes   ClusterIP      10.233.0.1      &lt;none&gt;           443/TCP        3h31m<br>nginx2       LoadBalancer   10.233.61.237   192.168.31.150   80:31724/TCP   8s<br></code></pre></td></tr></table></figure><p>访问对应的 EXTERNAL-IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Bash">curl 192.168.31.150<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.org/&quot;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=<span class="hljs-string">&quot;http://nginx.com/&quot;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you <span class="hljs-keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>能够访问，说明 LB 正常工作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>loadbalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chatgpt Q&amp;A</title>
    <link href="/2023/05/07/chatgpt-QA/"/>
    <url>/2023/05/07/chatgpt-QA/</url>
    
    <content type="html"><![CDATA[<p>这个文档记录了 chatGPT 的一些有帮助的回答。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="为什么网络协议栈要分层？不能直接把应用层的东西一起放到传输层吗"><a href="#为什么网络协议栈要分层？不能直接把应用层的东西一起放到传输层吗" class="headerlink" title="为什么网络协议栈要分层？不能直接把应用层的东西一起放到传输层吗"></a>为什么网络协议栈要分层？不能直接把应用层的东西一起放到传输层吗</h2><p>网络协议栈之所以要分层，主要是为了提高网络协议的可维护性、可扩展性、互操作性以及灵活性。</p><p>具体来说，网络协议栈分层的好处包括：</p><p>模块化设计：将协议栈分成不同的层次，每一层都有明确的功能和接口，可以独立设计、测试、实现和优化，提高了系统的可维护性和可扩展性。</p><p>抽象层次：每一层都通过下一层提供的服务来实现其功能，上一层不需要了解下一层的具体实现细节，只需要知道它提供的服务即可，从而实现了协议栈的抽象层次，减少了复杂性。</p><p>互操作性：不同的厂商和组织可以通过实现相同的协议层次，实现跨平台、跨系统的互操作性，提高了网络的兼容性和可扩展性。</p><p>灵活性：协议栈的分层使得每一层都可以根据具体需求进行优化和改进，不需要影响其他层的实现，从而提高了协议栈的灵活性。</p><p>如果将应用层的东西直接放到传输层，就会导致协议栈的混乱和复杂性增加。应用层的功能通常是应用程序特定的，而传输层的功能则是提供可靠的数据传输服务。如果把这两个不同的功能合并在一起，就会导致协议栈的复杂性增加，而且应用程序就需要直接处理传输层的细节，这会使得应用程序的实现更加困难。</p><p>因此，网络协议栈分层的设计思想是十分必要的。它使得协议栈的实现更加简单、灵活、可维护，也能够提高网络的可靠性和性能。</p><h2 id="四层负载均衡和七层负载均衡的区别"><a href="#四层负载均衡和七层负载均衡的区别" class="headerlink" title="四层负载均衡和七层负载均衡的区别"></a>四层负载均衡和七层负载均衡的区别</h2><p>四层负载均衡和七层负载均衡是指负载均衡器的不同工作层次。</p><p>四层负载均衡器（L4）工作在 OSI 模型中的传输层，基于 IP 地址和端口号来进行负载均衡。它可以实现对 TCP&#x2F;UDP 等传输层协议的负载均衡，但不能实现应用层协议的负载均衡，比如 HTTP 协议等。</p><p>七层负载均衡器（L7）工作在 OSI 模型中的应用层，能够实现对 HTTP、FTP、SMTP 等应用层协议的负载均衡，同时也可以进行传输层协议的负载均衡。L7 负载均衡器可以深入到协议头部和数据内容中，对数据进行检查和修改，比如根据请求的 URL 或用户代理等信息来进行请求的路由。</p><p>总的来说，四层负载均衡器主要关注传输层的负载均衡，可以在 IP 地址和端口号等信息上进行调度和分配；而七层负载均衡器则可以更细粒度地进行负载均衡，考虑到应用层协议中更多的信息，如请求类型、URI、Cookie 等，以此进行流量的路由和控制。另外，七层负载均衡器还可以对请求进行内容处理和过滤，提高了安全性和性能。</p><p><strong>You:</strong></p><p>也就是说七层可以获得的信息更多，所以可以更加精细的进行负载均衡，而四层则只能根据 IP 和端口进行负载均衡</p><p><strong>ChatGPT:</strong></p><p>是的，七层负载均衡器可以获取到应用层协议中更多的信息，如请求类型、URI、Cookie 等，这些信息可以帮助负载均衡器更精细地进行流量的路由和控制。而四层负载均衡器则只能根据 IP 地址和端口号进行负载均衡，无法获取到应用层协议中的这些信息。因此，七层负载均衡器在应用层面上具有更高的可控性和可定制性，可以更好地适应不同的应用场景。</p><h1 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h1><h2 id="clientcmd-BuildConfigFromFlags-和-clientcmd-BuildConfigFromKubeconfigGetter-有什么区别"><a href="#clientcmd-BuildConfigFromFlags-和-clientcmd-BuildConfigFromKubeconfigGetter-有什么区别" class="headerlink" title="clientcmd.BuildConfigFromFlags 和 clientcmd.BuildConfigFromKubeconfigGetter() 有什么区别"></a>clientcmd.BuildConfigFromFlags 和 clientcmd.BuildConfigFromKubeconfigGetter() 有什么区别</h2><p><strong>You:</strong><br>clientcmd.BuildConfigFromFlags 和 clientcmd.BuildConfigFromKubeconfigGetter() 有什么区别</p><p><strong>ChatGPT:</strong><br><code>clientcmd.BuildConfigFromFlags()</code> 和 <code>clientcmd.BuildConfigFromKubeconfigGetter()</code> 都是用于创建 Kubernetes API client 的方法，但是有一些区别。</p><p><code>clientcmd.BuildConfigFromFlags()</code> 会从 command-line flags 或者环境变量中获取 kubeconfig 文件的路径，然后读取 kubeconfig 文件中的配置信息，最后返回一个 <code>*rest.Config</code> 对象。如果没有指定 kubeconfig 文件，<code>BuildConfigFromFlags()</code> 方法会使用默认路径 <code>~/.kube/config</code>。</p><p><code>clientcmd.BuildConfigFromKubeconfigGetter()</code> 也是从 kubeconfig 文件中读取配置信息，但是它需要传入一个 <code>clientcmd.KubeconfigGetter</code> 接口作为参数。这个接口定义了一个方法 <code>Get() (*clientcmdapi.Config, error)</code>，用于返回 kubeconfig 文件中的配置信息。你可以使用 <code>clientcmd.NewDefaultClientConfigLoadingRules().Load()</code> 或者 <code>clientcmd.NewNonInteractiveDeferredLoadingClientConfig()</code> 来创建一个 <code>KubeconfigGetter</code> 对象，然后将其传递给 <code>BuildConfigFromKubeconfigGetter()</code> 方法。</p><p>所以，两者的区别主要在于 <code>BuildConfigFromFlags()</code> 只需要传递 kubeconfig 文件的路径，而 <code>BuildConfigFromKubeconfigGetter()</code> 需要传递一个实现了 <code>KubeconfigGetter</code> 接口的对象。另外，<code>BuildConfigFromKubeconfigGetter()</code> 可以更灵活地控制 kubeconfig 文件的加载和解析过程。</p><p><strong>You:</strong><br>BuildConfigFromKubeconfigGetter() 可以更灵活地控制 kubeconfig 文件的加载和解析过程 为什么这么说，举个例子</p><p><strong>ChatGPT:</strong></p><p><code>BuildConfigFromKubeconfigGetter()</code>  允许您提供一个自定义的函数来获取 kubeconfig 数据，从而可以更灵活地控制 kubeconfig 文件的加载和解析过程。</p><p>举个例子，如果您的应用程序在 Kubernetes 集群内运行，并且您想要使用集群内部的 ServiceAccount 来进行身份验证，则可以使用 <code>BuildConfigFromKubeconfigGetter()</code> 函数并提供一个自定义的 kubeconfig getter 函数来加载 ServiceAccount 的 token 和 CA 证书，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getServiceAccountToken</span><span class="hljs-params">()</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// Get the service account token</span><br>    tokenPath := <span class="hljs-string">&quot;/var/run/secrets/kubernetes.io/serviceaccount/token&quot;</span><br>    tokenBytes, err := ioutil.ReadFile(tokenPath)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>    &#125;<br>    token := <span class="hljs-type">string</span>(tokenBytes)<br><br>    <span class="hljs-comment">// Get the service account CA cert</span><br>    caPath := <span class="hljs-string">&quot;/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&quot;</span><br>    caBytes, err := ioutil.ReadFile(caPath)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>    &#125;<br><br>    <span class="hljs-comment">// Return a kubeconfig with the service account token and CA cert</span><br>    <span class="hljs-keyword">return</span> clientcmd.Write(clientcmdapi.Config&#123;<br>        Clusters: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*clientcmdapi.Cluster&#123;<br>            <span class="hljs-string">&quot;default&quot;</span>: &#123;<br>                Server:                   <span class="hljs-string">&quot;https://kubernetes.default.svc&quot;</span>,<br>                CertificateAuthorityData: caBytes,<br>            &#125;,<br>        &#125;,<br>        AuthInfos: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*clientcmdapi.AuthInfo&#123;<br>            <span class="hljs-string">&quot;default&quot;</span>: &#123;<br>                Token: token,<br>            &#125;,<br>        &#125;,<br>        Contexts: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*clientcmdapi.Context&#123;<br>            <span class="hljs-string">&quot;default&quot;</span>: &#123;<br>                Cluster:  <span class="hljs-string">&quot;default&quot;</span>,<br>                AuthInfo: <span class="hljs-string">&quot;default&quot;</span>,<br>            &#125;,<br>        &#125;,<br>        CurrentContext: <span class="hljs-string">&quot;default&quot;</span>,<br>    &#125;)<br>&#125;<br><br>cfg, err := clientcmd.BuildConfigFromKubeconfigGetter(<span class="hljs-string">&quot;&quot;</span>, getServiceAccountToken)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，我们使用了 <code>ioutil</code> 包中的 <code>ReadFile()</code> 函数来获取 ServiceAccount 的 token 和 CA 证书。然后，我们构造了一个包含这些信息的 kubeconfig 对象，并将其转换为 YAML 格式的字符串。最后，我们将该字符串传递给 <code>BuildConfigFromKubeconfig()</code> 函数以获取 Kubernetes API 客户端的配置。</p><p>通过这种方式，您可以使用 ServiceAccount 的 token 和 CA 证书来进行身份验证，而不是使用默认的 kubeconfig 文件，从而更灵活地控制 kubeconfig 文件的加载和解析过程。</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="链接符号名"><a href="#链接符号名" class="headerlink" title="链接符号名"></a>链接符号名</h2><p><strong>You:</strong></p><p>在 a 文件夹下有 3 个 c++ 文件：math.h , main.cc, foo.cc，math.h 里定义了一个 add 函数，然后 main.cc 和 foo.cc 都 #include “math.h”，执行 g++ main.cc foo.cc math.h  后报错 duplicate symbol ‘__Z3addii’ in:，这是为什么？</p><p><strong>ChatGPT:</strong></p><p>这是因为在执行 g++ main.cc foo.cc math.h 时，你把 math.h 文件也当作了源文件来编译，而不是头文件。你在 main.cc 和 foo.cc 中都包含了 “math.h”，那么 add 函数就在两个文件中都被编译进去了，因此在链接阶段就会出现重复符号的错误。</p><p>解决方法是只将 math.h 文件作为头文件，源文件分别编译，最后再链接。例如：</p><p>g++ -c main.cc<br>g++ -c foo.cc<br>g++ main.o foo.o</p><p>这样，在链接阶段 add 函数的定义就只会在一个文件中出现，避免了重复符号的错误。</p><p><strong>You:</strong></p><p>g++ -c 是什么意思</p><p><strong>ChatGPT:</strong></p><p><code>g++ -c</code> 是在编译 C++ 程序时使用的一个选项，它表示只编译源代码文件，不进行链接。通常我们会先使用 <code>g++ -c</code> 对所有源文件分别进行编译，最后再使用 <code>g++</code> 对所有生成的目标文件进行链接。</p><p>这个选项对大型项目来说很有用，因为它可以让我们在修改源代码时只编译被修改的文件，然后再与其他目标文件链接，从而减少编译时间。</p><p><strong>You:</strong></p><p>duplicate symbol ‘__Z3addii’ in 为什么报错信息这么古怪？这个重复定义的函数叫 add，为什么报错提示的是 Z3addii？</p><p><strong>ChatGPT:</strong></p><p>这是因为 <code>__Z3addii</code> 是 add 函数的符号名，而不是函数名。</p><p>在 C++ 中，函数名通常是一个字符串，但是编译器并不直接使用这个字符串，而是使用一个符号名来代替它。这个符号名是一个与函数名相关的数字，用于在编译后的代码中对函数进行引用。</p><p>在 Linux 系统上，一般使用 C++ 的默认符号命名约定是 C++ 运行时符号约定，即 “C++ ABI”（Application Binary Interface）。根据 C++ ABI 规定，函数符号名的格式通常是 __Zn，其中 n 是一个数字，表示函数名称。</p><p>因此，在报错信息中出现的 <code>__Z3addii</code> 其实是 add 函数的符号名，而不是函数名。编译器把函数名编译成了符号名，以便在链接阶段进行引用，因此在报错信息中出现了符号名而不是函数名。</p><p><strong>You:</strong></p><p>那我如何分辨是哪个函数重复定义了呢，如果在一个大型项目下</p><p><strong>ChatGPT:</strong></p><p>如果您在大型项目中遇到了重复定义的问题，您可以使用一些工具来帮助您解决这个问题。</p><p>一种方法是使用 c++filt 工具。c++filt 可以将符号名转换成函数名，因此您可以使用 c++filt 来分析编译器报错信息。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ c++filt __Z3addii<br>add(int, int)<br></code></pre></td></tr></table></figure><p>还有一种方法是使用 nm 工具。nm 可以列出一个可执行文件或目标文件的符号表。您可以使用 nm 来检查每个目标文件，以确定是哪个文件定义了重复的符号。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nm main.o<br>0000000000000030 T __Z3addii<br><br>$ nm foo.o<br>0000000000000030 T __Z3addii<br></code></pre></td></tr></table></figure><p>在这个例子中，两个目标文件都定义了符号 __Z3addii，因此这两个文件都会导致重复定义的问题。</p><p>通过使用这些工具，您可以快速确定重复定义的问题所在，从而解决问题。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程的优劣"><a href="#进程的优劣" class="headerlink" title="进程的优劣"></a>进程的优劣</h2><p>进程是指操作系统中正在运行的一个程序的实例。每个进程都有自己的地址空间、内存、文件句柄等资源，它们彼此独立，但可以通过 IPC（进程间通信）机制进行通信和交互。进程有以下优点：</p><ol><li>稳定性：每个进程在其自己的地址空间中运行，不会影响其他进程的运行，这使得进程非常稳定。</li><li>灵活性：进程可以独立运行，可以有自己的权限，可以使用不同的资源。</li><li>安全性：由于每个进程都运行在其自己的地址空间中，因此其他进程无法访问该进程的内存，这提高了系统的安全性。</li><li>可移植性：进程可以在不同的系统中移植，因为它们与底层硬件无关，只需要操作系统提供支持。</li></ol><p>进程的缺点是：</p><ol><li>资源占用：每个进程都需要占用一定的内存和 CPU 资源，如果系统中运行过多的进程，就会导致资源的浪费和系统的崩溃。</li><li>上下文切换开销：当系统中有多个进程运行时，它们之间的切换会带来一定的开销，这会影响系统的性能。</li><li>进程间通信复杂：进程之间需要进行通信和同步，这需要一定的机制和代码来实现，增加了系统的复杂性。</li></ol><h2 id="为什么进程上下文切换开销大"><a href="#为什么进程上下文切换开销大" class="headerlink" title="为什么进程上下文切换开销大"></a>为什么进程上下文切换开销大</h2><p>进程的上下文切换开销大主要是因为进程拥有独立的虚拟地址空间、文件描述符、寄存器等资源，当进程进行上下文切换时需要保存当前进程的所有状态并恢复下一个进程的所有状态，这个过程需要大量的时间和计算资源。</p><p>进程上下文切换的主要步骤包括：</p><ol><li>保存当前进程的 CPU 寄存器状态；</li><li>将当前进程的程序计数器指向下一条要执行的指令；</li><li>将当前进程的程序状态字保存到内存中；</li><li>切换虚拟地址空间和内存映射关系；</li><li>切换内核栈；</li><li>恢复下一个进程的 CPU 寄存器状态；</li><li>将程序状态字设置为下一个进程的状态。</li></ol><p>上下文切换的过程中需要频繁地读写内存和寄存器，这会导致 CPU 缓存失效，从而影响 CPU 的性能。此外，进程的上下文切换还会导致 TLB（Translation Lookaside Buffer）缓存失效，从而影响内存访问速度。</p><p>因此，为了减少进程上下文切换的开销，通常可以采用以下策略：</p><ol><li>减少进程的数量：通过合理规划进程数量，尽可能地利用每个进程的资源，减少进程间的切换次数；</li><li>采用线程：线程是轻量级的进程，它们共享同一个虚拟地址空间和文件描述符等资源，因此线程的上下文切换开销通常比进程小；</li><li>采用异步 I&#x2F;O：异步 I&#x2F;O 可以避免进程在等待 I&#x2F;O 操作完成时被阻塞，从而减少进程的上下文切换次数；</li><li>采用事件驱动模型：事件驱动模型可以避免进程在等待事件完成时被阻塞，从而减少进程的上下文切换次数。</li></ol><h2 id="TLB-是什么"><a href="#TLB-是什么" class="headerlink" title="TLB 是什么"></a>TLB 是什么</h2><p>TLB（Translation Lookaside Buffer）是一种硬件缓存，用于加速虚拟内存管理中的地址翻译过程。当CPU需要访问虚拟地址时，需要将虚拟地址转换成物理地址，这个过程会访问页表。如果页表非常大，需要访问的页表项也非常多，那么地址翻译过程的开销就会很大，影响系统性能。TLB的作用就是缓存最近使用的页表项，加速地址翻译过程，从而提高系统性能。当CPU需要访问一个虚拟地址时，它首先会在TLB中查找对应的物理地址，如果TLB中没有对应的物理地址，就会触发一次页表访问，将页表项加载到TLB中，以加速后续的访问。由于TLB通常比页表小得多，因此可以极大地减少访问页表的次数，从而提高系统性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Controller-Runtime 之 Source </title>
    <link href="/2023/04/20/controller-runtime-source/"/>
    <url>/2023/04/20/controller-runtime-source/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><code>Source</code> 是 <code>Watches()</code> 的第一个参数，代表一种事件源，实际类型是一个 interface，原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Source <span class="hljs-keyword">interface</span> &#123;<br>Start(context.Context, handler.EventHandler, workqueue.RateLimitingInterface, ...predicate.Predicate) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只有一个 Start 方法</p><p>TODO: Start 方法参数的作用，在哪里被调用，如何工作</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>老实说光看注释说明还是挺懵逼的，在网上也找不到太多相关的内容，不少博客讲的都是偏概念性质的，对 Source 这个东西还是一头雾水，不知道到底是干嘛的，实际该怎么使用。感觉想要快速了解一个功能的用途，还是想办法做一个 demo 最靠谱，下面我就做了一个 demo，通过自定义一个 Source 事件源，来达到监听文件的目的，当监听的文件内容发生变动时，就会触发一次 Reconcile。</p><p>首先先定义一个 struct 来实现 Source 接口，完整代码如下：</p><h2 id="source-go"><a href="#source-go" class="headerlink" title="source.go"></a><strong>source.go</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;k8s.io/apimachinery/pkg/types&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/util/workqueue&quot;</span><br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>ctrl <span class="hljs-string">&quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/handler&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/predicate&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> FileWatch <span class="hljs-keyword">struct</span> &#123;<br>p           <span class="hljs-type">string</span><br>f           *os.File<br>q           workqueue.RateLimitingInterface<br>lastModTime time.Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFileWatch</span><span class="hljs-params">(filepath <span class="hljs-type">string</span>)</span></span> *FileWatch &#123;<br>fw := <span class="hljs-built_in">new</span>(FileWatch)<br>fw.p = filepath<br><br>f, err := os.Open(filepath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fw.f = f<br><br>stat, err := f.Stat()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fw.lastModTime = stat.ModTime()<br><br><span class="hljs-keyword">return</span> fw<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileWatch)</span></span> Sync() &#123;<br>ticket := time.NewTicker(time.Second * <span class="hljs-number">3</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticket.C:<br>modify, modTime, err := f.FileIsModify()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> modify &#123;<br><span class="hljs-comment">// Add 的参数必须是 ctrl.Request 类型的，其他类型会直接被 controller 丢弃</span><br>f.q.Add(ctrl.Request&#123;NamespacedName: types.NamespacedName&#123;Name: f.p&#125;&#125;)<br>f.lastModTime = modTime<br>&#125;<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileWatch)</span></span> FileIsModify() (<span class="hljs-type">bool</span>, time.Time, <span class="hljs-type">error</span>) &#123;<br>stat, err := os.Stat(f.p)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, time.Time&#123;&#125;, err<br>&#125;<br><span class="hljs-keyword">if</span> stat.ModTime().After(f.lastModTime) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, stat.ModTime(), <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, stat.ModTime(), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *FileWatch)</span></span> Start(ctx context.Context, h handler.EventHandler, queue workqueue.RateLimitingInterface, p ...predicate.Predicate) <span class="hljs-type">error</span> &#123;<br>klog.Info(<span class="hljs-string">&quot;fileWatch start...&quot;</span>)<br>f.q = queue<br><span class="hljs-keyword">go</span> f.Sync()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>文件监听相关的代码比较简单，这里就不说明了，也不是本文的重点，这里主要需要关注的是 Sync() 里的 <code>f.q.Add(ctrl.Request&#123;NamespacedName: types.NamespacedName&#123;Name: f.p&#125;&#125;)</code> 这一行，表示当文件发生修改时，添加一个 ctrl.Request 到队列中，Request 的 Name 是该文件的路径，然后在 Start() 里，我们运行了 Sync() 这个函数。</p><p>需要注意的是，队列里添加的对象一定要是 ctrl.Request 类型的，如果是其他类型，会直接被内部 controller 丢弃，具体的代码在 <code>controller-runtime/pkg/internal/controller/controller.go</code> 的 reconcileHandler 函数，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> reconcileHandler(ctx context.Context, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">//....</span><br><br><span class="hljs-comment">// Make sure that the object is a valid request.</span><br>  <span class="hljs-comment">// 在这里进行了判断，如果不是 Request 类型会直接丢弃</span><br>req, ok := obj.(reconcile.Request)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-comment">// As the item in the workqueue is actually invalid, we call</span><br><span class="hljs-comment">// Forget here else we&#x27;d go into a loop of attempting to</span><br><span class="hljs-comment">// process a work item that is invalid.</span><br>c.Queue.Forget(obj)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来编写调协相关的代码：</p><h2 id="ctrl-go"><a href="#ctrl-go" class="headerlink" title="ctrl.go"></a>ctrl.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><br>corev1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>ctrl <span class="hljs-string">&quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/event&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/handler&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/predicate&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Ctrl <span class="hljs-keyword">struct</span> &#123;<br>fw *FileWatch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Ctrl)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>klog.Info(<span class="hljs-string">&quot;new modify event, file path: &quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Ctrl)</span></span> SetupWithManager(mgr ctrl.Manager) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> ctrl.NewControllerManagedBy(mgr).<br><span class="hljs-comment">// controller-runtime 必须要指定一种监听的资源，否则无法启动，这里设置为 Pod</span><br>For(&amp;corev1.Pod&#123;&#125;).<br>Watches(c.fw, &amp;handler.EnqueueRequestForObject&#123;&#125;).<br>WithEventFilter(&amp;predicate.Funcs&#123;<br><span class="hljs-comment">// 在这里设置过滤事件，只监听指定 namespace 的 pod 的创建事件，</span><br><span class="hljs-comment">// 这里的 namespace 我随便设置了一个，进而可以达到忽略 Pod 事件的目的，</span><br>      <span class="hljs-comment">// 因为我们的主要目的是观察自定义 Source 的效果，所以尽量避免其他资源的干扰</span><br>CreateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(e event.CreateEvent)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> e.Object.GetNamespace() == <span class="hljs-string">&quot;UNKNOWN_NAMESPACE&quot;</span><br>&#125;,<br>&#125;).<br>Complete(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>Reconcile</code> 中，我们只会简单输出一条日志，表示发生了文件修改事件，在 <code>SetupWithManager</code> 中，我们指定了 <code>Watches</code> 的第一个参数为 fw，也就是我们自定义的 Source。</p><p>最后是主函数 main.go。</p><h2 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>ctrl <span class="hljs-string">&quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/client/config&quot;</span><br><span class="hljs-string">&quot;sigs.k8s.io/controller-runtime/pkg/manager&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filepath := os.Getenv(<span class="hljs-string">&quot;FILE_PATH&quot;</span>)<br><span class="hljs-keyword">if</span> filepath == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;file path can&#x27;t be nil&quot;</span>)<br>&#125;<br><br>cfg, err := config.GetConfig()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err, <span class="hljs-string">&quot;unable to get kubeconfig&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br>mgr, err := manager.New(cfg, manager.Options&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err, <span class="hljs-string">&quot;unable to set up manager&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">if</span> err := (&amp;Ctrl&#123;<br>fw: NewFileWatch(filepath),<br>&#125;).SetupWithManager(mgr); err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>klog.Info(<span class="hljs-string">&quot;starting manager&quot;</span>)<br><span class="hljs-keyword">if</span> err := mgr.Start(ctrl.SetupSignalHandler()); err != <span class="hljs-literal">nil</span> &#123;<br>klog.Error(err, <span class="hljs-string">&quot;problem running manager&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们启动整个程序，你需要通过环境变量 <code>FILE_PATH</code> 来指定你要监听的文件路径，比如像下面这样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">FILE_PATH=testdata/test.txt  go run .<br></code></pre></td></tr></table></figure><p>运行后，对你监听的文件进行修改，观察 terminal 的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">I0420 16:47:42.610297 3741467 main.go:35] starting manager<br>I0420 16:47:42.610718 3741467 source.go:74] fileWatch start...<br>I0420 16:48:00.611223 3741467 ctrl.go:19] new modify event, file path: /testdata/test.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>controller-runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s Storageclass</title>
    <link href="/2023/04/18/k8s-storageclass/"/>
    <url>/2023/04/18/k8s-storageclass/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建-NFS-StorageClass"><a href="#搭建-NFS-StorageClass" class="headerlink" title="搭建 NFS StorageClass"></a>搭建 NFS StorageClass</h1><h2 id="搭建-NFS-Server"><a href="#搭建-NFS-Server" class="headerlink" title="搭建 NFS Server"></a>搭建 NFS Server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 NFS 服务端</span><br>sudo apt-get install nfs-kernel-server  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 <span class="hljs-built_in">dir</span> 作为 NFS 共享目录</span><br>mkdir /share<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑配置</span><br>sudo vim /etc/exports<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在最后一行添加</span><br>/share *(rw,sync,no_root_squash,no_subtree_check)<br></code></pre></td></tr></table></figure><p>修改完成后，:wq 保存，然后执行 <code>exportfs -rav</code> 命令使配置生效，不然客户端挂载 NFS 会报错无权限。</p><p><code>/share *(rw,sync,no_root_squash,no_subtree_check)</code></p><p>其中 &#x2F;share 就是我们的 NFS 共享目录</p><p>*(rw,sync,no_root_squash,no_subtree_check) 是一条配置行，用于指定 NFS 共享目录的权限设置</p><p>具体解释如下：</p><ul><li><code>*</code>: 表示允许任何客户端访问该共享目录。也可以指定特定的 IP 地址、IP 地址范围或域名等来限制客户端的访问。</li><li><code>(rw)</code>: 表示共享目录以读写 (read-write) 模式共享，客户端可以对共享目录进行读取和写入操作。也可以使用 <code>(ro)</code> 表示只读 (read-only) 模式共享，客户端只能对共享目录进行读取操作。</li><li><code>(sync)</code>: 表示使用同步 (synchronous) 模式，NFS 服务器在客户端请求完成之前会等待写入操作同步到磁盘上。这样可以保证数据的一致性，但可能会影响性能。</li><li><code>(no_root_squash)</code>: 表示允许客户端使用 root 权限访问共享目录。默认情况下，NFS 服务器会将客户端使用 root 权限的请求映射为使用匿名用户 (nobody) 权限，这样可以提高安全性。使用 <code>(no_root_squash)</code> 参数可以禁用这种映射，允许客户端使用 root 权限访问共享目录。</li><li><code>(no_subtree_check)</code>: 表示禁用子树检查，这样可以加快目录共享的速度。子树检查是一种安全特性，用于检查共享目录的父目录和祖先目录的权限，但在某些情况下可能会影响性能。使用 <code>(no_subtree_check)</code> 参数可以禁用这种检查。</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先在共享目录 &#x2F;share 下创建一个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> 123 &gt; /share/123.txt</span><br></code></pre></td></tr></table></figure><p>在另一台主机上，挂载该共享目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo mount -t nfs 192.168.223.129:/share /mnt</span><br></code></pre></td></tr></table></figure><p>其中，192.168.223.129 是 NFS Server 的 IP，&#x2F;share 是该 server 的共享目录，&#x2F;mnt 是客户端要挂载到本机的目的目录。</p><blockquote><p>如果执行后报错</p><p>mount: &#x2F;mnt: bad option; for several filesystems (e.g. nfs, cifs) you might need a &#x2F;sbin&#x2F;mount.<type> helper program.</p><p>表示你没有安装 NFS 客户端，执行下面的命令进行安装 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install -y nfs-common<br></code></pre></td></tr></table></figure></blockquote><p>执行完成后如果没有任何错误信息则代表成功，查看当前主机的 &#x2F;mnt 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /mnt</span><br>123.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /mnt/123.txt</span><br>123<br></code></pre></td></tr></table></figure><p>发现之前在 NFS Server 的 &#x2F;share 里创建的文件，出现在了客户端主机的 &#x2F;mnt 目录下，代表 NFS Server 搭建成功。</p><h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span>        <span class="hljs-comment">#根据实际环境设定namespace,下面类同</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;persistentvolumes&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;persistentvolumeclaims&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;storage.k8s.io&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;storageclasses&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;events&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">run-nfs-client-provisioner</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>    <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;endpoints&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-comment"># replace with namespace where provisioner is deployed</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><h1 id="部署-provisioner-deployment"><a href="#部署-provisioner-deployment" class="headerlink" title="部署 provisioner-deployment"></a>部署 provisioner-deployment</h1><blockquote><p>⚠️  如果你的 k8s 版本和我一样是 v1.25.6，那么需要使用下面这个镜像：</p><p>gcr.io&#x2F;k8s-staging-sig-storage&#x2F;nfs-subdir-external-provisioner:v4.0.0</p><p>否则 pvc 无法 bound，报错 selfLink was empty, can’t make reference</p><p>下面这个镜像无法正常工作</p><p>quay.io&#x2F;external_storage&#x2F;nfs-client-provisioner:latest</p><p>此外还需要注意的是，你需要确保所有节点上都已经安装好了 NFS 客户端，因为 pod 可能被调度到任何一个 worker 节点。如果没有，你可以执行下面的命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install -y nfs-common<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nft-provisioner-deployment.yaml</span><br><span class="hljs-comment"># kubectl apply -f nft-provisioner-deployment.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">nfs-client-provisioner</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/k8s-staging-sig-storage/nfs-subdir-external-provisioner:v4.0.0</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/persistentvolumes</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PROVISIONER_NAME</span><br>              <span class="hljs-comment"># 自定义 provisioner 名称</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">nfs-provisioner</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_SERVER</span><br>              <span class="hljs-comment"># 替换为 nfs 服务器地址</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.223</span><span class="hljs-number">.129</span> <br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_PATH</span><br>              <span class="hljs-comment"># 替换为 NFS 共享文件路径</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">/share</span> <br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>          <span class="hljs-attr">nfs:</span><br>            <span class="hljs-comment"># 替换为 nfs 服务器地址</span><br>            <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.223</span><span class="hljs-number">.129</span><br>            <span class="hljs-comment"># 替换为 NFS 共享文件路径</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/share</span><br></code></pre></td></tr></table></figure><h3 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># nfs-storage.yaml</span><br><span class="hljs-comment"># kubectl apply -f nfs-storage.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-storage</span><br><span class="hljs-comment"># 使用上面的自定义 provisioner 名称</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">nfs-provisioner</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-comment"># archiveOnDelete 指定为 false 表示删除 PVC 后 PV 也会被删除。</span><br>  <span class="hljs-comment"># 如果想在 PVC 被删除后仍旧保留数据的，可指定为 true</span><br>  <span class="hljs-attr">archiveOnDelete:</span> <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>验证：</p><p>创建 pvc</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-claim</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># 与 nfs-StorageClass.yaml metadata.name 保持一致</span><br>    <span class="hljs-attr">volume.beta.kubernetes.io/storage-class:</span> <span class="hljs-string">&quot;nfs-storage&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Mi</span><br></code></pre></td></tr></table></figure><p>查看是否 Bound：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get pvc</span><br>NAME           STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>test-claim     Bound     pvc-969d9309-4510-46ac-90c1-8e9cc1d8f2ec   1Mi        RWX            nfs-storage    22m<br></code></pre></td></tr></table></figure><p>TODO 测试 pod 能否挂载上这个 pvc</p><h1 id="设置默认-StorageClass"><a href="#设置默认-StorageClass" class="headerlink" title="设置默认 StorageClass"></a>设置默认 StorageClass</h1><p>执行下面的命令将某个 sc 设置为默认：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch storageclass &lt;storageclass-name&gt; -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>比如现在有一个名为 nfs-storage 的 sc，要将其设置为默认 sc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get sc</span><br>NAME          PROVISIONER       RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE<br>nfs-storage   nfs-provisioner   Delete          Immediate           false                  41m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch storageclass nfs-storage -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span></span><br></code></pre></td></tr></table></figure><p>执行后，发现名字后面多了一个 (default)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k get sc</span><br>NAME                    PROVISIONER       RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE<br>nfs-storage (default)   nfs-provisioner   Delete          Immediate           false                  46m<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过 Kubespray 搭建 k8s 集群</title>
    <link href="/2023/04/16/Kubespray-install/"/>
    <url>/2023/04/16/Kubespray-install/</url>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️  安装前最好确保你的主机够干净，我的虚拟机就因为之前自行用二进制搭建过，导致使用 kubespray 安装出现各种奇奇怪怪的错误，最后删除重新创建了一台，一次就安装成功了</p></blockquote><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ssh 登录要用，不然报错 <span class="hljs-string">&quot;to use the &#x27;ssh&#x27; connection type with passwords or pkcs11_provider, you must install the sshpass program</span></span><br>apt install sshpass<br><br>pip install netaddr # 不确定这玩意的必要性，最好还是装了吧<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">不要手动安装下面这些东西，手动安装的 ansible 可能与 Kubespray 要求的版本不匹配</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">pip install --upgrade jinja2</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">apt install ansible</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">不要 clone 这个，可能有问题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">git clone https://github.com/kubernetes-incubator/kubespray.git</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">从 release 里下载</span></span><br>wget https://github.com/kubernetes-sigs/kubespray/archive/refs/tags/v2.21.0.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">解压上面下载下来的压缩包</span></span><br>tar -C . -xvf v2.21.0.tar.gz<br><br>cd kubespray-2.21.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">安装符合版本的依赖，这里会安装 ansible</span></span><br>pip install -U -r requirements.txt<br></code></pre></td></tr></table></figure><h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd kubespray-2.21.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制一份配置进行修改</span><br>cp -rfp inventory/sample inventory/k8s<br>vim inventory/k8s/inventory.ini<br></code></pre></td></tr></table></figure><p>配置如下，保证 IP 正确，其中 master 节点要指定 etcd_member_name，worker 节点该值置为空</p><p>同理，[kube_control_plane] 和 [etcd] 里写 master 节点，[kube_node] 里写 worker 节点</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># ## Configure &#x27;ip&#x27; variable to bind kubernetes services on a</span><br><span class="hljs-comment"># ## different ip than the default iface</span><br><span class="hljs-section">[all]</span><br>k8s-master <span class="hljs-attr">ansible_host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.128</span> ip=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.128</span> ansible_ssh_user=root ansible_ssh_pass=root etcd_member_name=k8s-master<br>k8s-worker1 <span class="hljs-attr">ansible_host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.129</span> ip=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.129</span> etcd_member_name=<span class="hljs-string">&quot;&quot;</span><br>k8s-worker2 <span class="hljs-attr">ansible_host</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.130</span> ip=<span class="hljs-number">192.168</span>.<span class="hljs-number">223.130</span> etcd_member_name=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment"># node1 ansible_host=95.54.0.12  # ip=10.3.0.1 etcd_member_name=etcd1</span><br><span class="hljs-comment"># node2 ansible_host=95.54.0.13  # ip=10.3.0.2 etcd_member_name=etcd2</span><br><span class="hljs-comment"># node3 ansible_host=95.54.0.14  # ip=10.3.0.3 etcd_member_name=etcd3</span><br><span class="hljs-comment"># node4 ansible_host=95.54.0.15  # ip=10.3.0.4 etcd_member_name=etcd4</span><br><span class="hljs-comment"># node5 ansible_host=95.54.0.16  # ip=10.3.0.5 etcd_member_name=etcd5</span><br><span class="hljs-comment"># node6 ansible_host=95.54.0.17  # ip=10.3.0.6 etcd_member_name=etcd6</span><br><br><span class="hljs-comment"># ## configure a bastion host if your nodes are not directly reachable</span><br><span class="hljs-comment"># [bastion]</span><br><span class="hljs-comment"># bastion ansible_host=x.x.x.x ansible_user=some_user</span><br><br><span class="hljs-section">[kube_control_plane]</span><br>k8s-master<br><span class="hljs-comment"># node1</span><br><span class="hljs-comment"># node2</span><br><span class="hljs-comment"># node3</span><br><br><span class="hljs-section">[etcd]</span><br>k8s-master<br><span class="hljs-comment"># node1</span><br><span class="hljs-comment"># node2</span><br><span class="hljs-comment"># node3</span><br><br><span class="hljs-section">[kube_node]</span><br>k8s-worker1<br>k8s-worker2<br><span class="hljs-comment"># node2</span><br><span class="hljs-comment"># node3</span><br><span class="hljs-comment"># node4</span><br><span class="hljs-comment"># node5</span><br><span class="hljs-comment"># node6</span><br><br><span class="hljs-section">[calico_rr]</span><br><br><span class="hljs-section">[k8s_cluster:children]</span><br>kube_control_plane<br>kube_node<br>calico_rr<br></code></pre></td></tr></table></figure><h1 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h1><p>执行下面的命令进行部署，中间可能需要等待 10 分钟左右。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible-playbook -i inventory/k8s/inventory.ini cluster.yml -b -vvv <br></code></pre></td></tr></table></figure><p>最终如果执行结果如下，即所有节点 failed&#x3D;0，代表安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">PLAY RECAP ****************************************************************************************************<br>k8s-master                 : ok=728  changed=141  unreachable=0    failed=0    skipped=1260 rescued=0    ignored=8<br>k8s-worker1                : ok=479  changed=28   unreachable=0    failed=0    skipped=776  rescued=0    ignored=1<br>k8s-worker2                : ok=479  changed=28   unreachable=0    failed=0    skipped=775  rescued=0    ignored=1<br>localhost                  : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0<br></code></pre></td></tr></table></figure><h1 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><del>报错 Ansible must be between 2.11.0 and 2.13.0 exclusive</del></p><p><del>执行 python3 -m pip install –upgrade –user ansible 后还是报错，发现是版本又太高了：</del></p><p><del>ansible –version</del><br><del>ansible [core 2.14.4]</del></p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>报错 the output has been hidden due to the fact that ‘no_log: true’ was specified for this result</p><p>vim inventory&#x2F;k8s&#x2F;group_vars&#x2F;all&#x2F;all.yml</p><p>修改下面这行为 true</p><p>unsafe_show_logs: true</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>报错：</p><p>The checksum for &#x2F;tmp&#x2F;releases&#x2F;calico-v3.25.1-kdd-crds&#x2F;v3.25.1.tar.gz did not match 361b0e0e6d64156f0e1b2fbfd18d13217d188eee614eec5de6b05ac0deaab372; it was 4d6b6653499f24f80a85a0a7dac28d9571cabfa25356b08f3b438fd97e322e2d.</p><p>尝试手动下载</p><p>cd &#x2F;tmp&#x2F;releases&#x2F;calico-v3.25.1-kdd-crds</p><p>wget <a href="https://github.com/projectcalico/calico/archive/v3.25.1.tar.gz">https://github.com/projectcalico/calico/archive/v3.25.1.tar.gz</a></p><p>不行，执行部署命令会清空该目录</p><p>解决：</p><p>不要 clone 下面这个 master 分支，可能有问题</p><p>git clone <a href="https://github.com/kubernetes-incubator/kubespray.git">https://github.com/kubernetes-incubator/kubespray.git</a></p><p>从 release 里下载</p><p>wget <a href="https://github.com/kubernetes-sigs/kubespray/archive/refs/tags/v2.21.0.tar.gz">https://github.com/kubernetes-sigs/kubespray/archive/refs/tags/v2.21.0.tar.gz</a></p><p>后安装就没有这个问题了</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>W0416 11:04:23.183824  468870 utils.go:69] The recommended value for &quot;clusterDNS&quot; in &quot;KubeletConfiguration&quot; is: [10.233.0.10]; the provided value is: [169.254.25.10]\nerror execution phase certs&#x2F;apiserver: couldn’t load CA certificate ca: couldn’t load ca certificate authority from &#x2F;etc&#x2F;kubernetes&#x2F;ssl\nTo see the stack trace of this error execute with –v&#x3D;5 or higher</p><p>不知道啥原因，可能是因为之前机器装过二进制 k8s 导致一些莫名其妙的冲突</p><h1 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h1><p>安装完只有 master 节点安装好了 kubectl，worker 节点都没有安装，这个正常吗？</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装机记录</title>
    <link href="/2023/04/14/zhuangji-jilu/"/>
    <url>/2023/04/14/zhuangji-jilu/</url>
    
    <content type="html"><![CDATA[<p>最近组了台台式，用来当做迷你服务器使用，因为是自己第一次独立装机，所以特此记录一下期间的心路历程。</p><h1 id="坑爹-1：CPU"><a href="#坑爹-1：CPU" class="headerlink" title="坑爹 1：CPU"></a>坑爹 1：CPU</h1><p>坑爹指数：⭐️</p><p>老实说这玩意安装还是非常简单的，主要是包装和说明书上各种警告，还有网上各种压弯针脚的帖子，搞得人心惶惶的，其实感觉问题不大，按照说明书的步骤来，稍微小心一点，很容易就安装好了。</p><h1 id="坑爹-2：-主板"><a href="#坑爹-2：-主板" class="headerlink" title="坑爹 2： 主板"></a>坑爹 2： 主板</h1><p>坑爹指数：⭐️⭐️⭐️⭐️</p><p>主板本身的安装没什么难的，对准螺丝柱，拧上螺丝就 OK 了，蛋疼的是这玩意不能太早安装，作为初次装机的练习生，在这点上就踩了大坑了，前前后后装了拆拆了装了好几次，印象如下：</p><p>第一次：主板电源插线，发现需要用点力才能插进去，但是因为已经固定在螺丝柱上了，而有一部分线又需要插在主板角落，害怕把持不住把主板搞弯了，保险起见只能把主板拆掉再插线</p><p>第二次：安装散热，发现散热底座螺丝柱需要从主板背面安装，没办法又得拆下主板</p><p>第三次：安装机箱挡板，这玩意要安装在机箱内部，然后再用力往外压才能完成安装，我一开始还以为是从外到内安装。。。没办法只能拆掉主板</p><p>第四次：安装网卡 wifi-go 盒子，同样也是要从主板背面安装螺丝，没办法又得拆下主板</p><h1 id="坑爹-3：主板跳线"><a href="#坑爹-3：主板跳线" class="headerlink" title="坑爹 3：主板跳线"></a>坑爹 3：主板跳线</h1><p>坑爹指数：⭐️⭐️</p><p>这个乍一看挺复杂的，其实对着网上的视频教学，还是不难的，不过话虽这么说，但我还是没有一次成功，装好后电源键没反应，当时吓了我一跳，还以为硬件有问题，还好把跳线全部拔掉再照着视频插了一遍后成功解决了，总的来说还是不难的</p><h1 id="坑爹-4：主板电源线"><a href="#坑爹-4：主板电源线" class="headerlink" title="坑爹 4：主板电源线"></a>坑爹 4：主板电源线</h1><p>坑爹指数：⭐️⭐️⭐️⭐️⭐️</p><p>插这破玩意的时候直接让我破防，主要是太紧了，看视频要全部插到底才算 OK，否则有烧主板的风险，但是想插到底真的是费劲的一批，而且用太大劲又怕把针脚给搞弯，搞的是用劲不是，不用劲也不是，最后磨了半天最后才完全插进去，属实是恶心</p><h1 id="坑爹-5：网卡"><a href="#坑爹-5：网卡" class="headerlink" title="坑爹 5：网卡"></a>坑爹 5：网卡</h1><p>坑爹指数：⭐️⭐️⭐️⭐️⭐️</p><p>千算万算没想到，这个 jb 玩意是我安装过程中最恶心的一个部位，首先是那两根破线，就是连接天线和网卡的那根线，连接纽扣处太小了，难装的一批，后来看视频里的是斜着装的，然后调整了半天角度才扣上去，装好后又发现一个问题：我不知道如何将天线固定在机箱，虽然包装里给了两个带洞的铁片，好像是什么挡板，但是我不知道装在机箱的哪里，网上找到的视频也都是 wifi-go 盒子安装的，折腾了半天也没头绪，浪费了好多时间，最后没办法只能再买一个 wifi-go 盒子了，不过我发现单网卡不插天线，其实也是可以使用的，网速也有个 4 5M 每秒。</p><h1 id="坑爹-6：机箱挡板"><a href="#坑爹-6：机箱挡板" class="headerlink" title="坑爹 6：机箱挡板"></a>坑爹 6：机箱挡板</h1><p>坑爹指数：⭐️</p><p>这玩意其实没啥坑爹的，就是按压的时候要用点力，听见咔嚓的声音就可以了</p><h1 id="傻瓜级：内存，固态，电源"><a href="#傻瓜级：内存，固态，电源" class="headerlink" title="傻瓜级：内存，固态，电源"></a>傻瓜级：内存，固态，电源</h1><p>这三玩意基本都是简单无脑，也无需担心不小心装坏了什么的，像内存和电源都有防呆缺口，然后插进去就 OK 了，电源也是直接对准机箱屁股拧上螺丝就好了，主要是电源接线麻烦一些，电源本身安装非常简单</p>]]></content>
    
    
    
    <tags>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s 二进制安装</title>
    <link href="/2023/04/13/k8s-binray-install/"/>
    <url>/2023/04/13/k8s-binray-install/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>主机系统为 win11，通过 vmware 创建了 3 台虚拟机，详情如下：</p><table><thead><tr><th>hostname</th><th>os</th><th>ip</th><th>cpu</th><th>mem</th><th>disk</th></tr></thead><tbody><tr><td>k8s-master</td><td>Ubuntu 22.04.2 LTS</td><td>192.168.223.128</td><td>4c</td><td>8g</td><td>50g</td></tr><tr><td>k8s-worker1</td><td>Ubuntu 22.04.2 LTS</td><td>192.168.223.129</td><td>4c</td><td>8g</td><td>50g</td></tr><tr><td>k8s-worker2</td><td>Ubuntu 22.04.2 LTS</td><td>192.168.223.130</td><td>4c</td><td>8g</td><td>50g</td></tr></tbody></table><h1 id="基础环境准备"><a href="#基础环境准备" class="headerlink" title="基础环境准备"></a>基础环境准备</h1><h2 id="配置-hosts"><a href="#配置-hosts" class="headerlink" title="配置 hosts"></a>配置 hosts</h2><p>在 3 台主机的 &#x2F;etc&#x2F;hosts 文件中加入以下内容：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.223.128</span> k8s-master<br><span class="hljs-number">192.168.223.129</span> k8s-worker1<br><span class="hljs-number">192.168.223.130</span> k8s-worker2<br></code></pre></td></tr></table></figure><h2 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h2><p>首先在每台机器上执行下面的命令来生成 ssh 秘钥，直接回车到底：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure><p>继续执行 <code>ssh-copy-id -i .ssh/id_rsa.pub &lt;hostname&gt;</code> 命令，其中 hostname 填写 <strong>另外两台主机的主机名</strong>，这里以 <code>k8s-worker1</code> 为例。 按照提示输入 yes，最后输入目标主机的密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-copy-id -i .ssh/id_rsa.pub k8s-worker1</span><br></code></pre></td></tr></table></figure><p>输入密码后，如果提示下面内容，说明配置免密成功，执行 <code>ssh &#39;k8s-worker1&#39;</code>，发现无需输入密码即可直接 ssh 到目标主机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Number of key(s) added: 1<br><br>Now try logging into the machine, with:   &quot;ssh &#x27;k8s-worker1&#x27;&quot;<br>and check to make sure that only the key(s) you wanted were added.<br></code></pre></td></tr></table></figure><p>按照上面的流程对每台主机执行相同操作，完成 3 台主机相互之间的免密登录，这里不再赘述。</p><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p>在每台主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">disable</span> --now ufw</span><br></code></pre></td></tr></table></figure><p>查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ufw status</span><br>Status: inactive<br></code></pre></td></tr></table></figure><h2 id="关闭交换分区"><a href="#关闭交换分区" class="headerlink" title="关闭交换分区"></a>关闭交换分区</h2><p>执行下面的命令关闭 swap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab<br>swapoff -a &amp;&amp; sysctl -w vm.swappiness=0<br></code></pre></td></tr></table></figure><p>查看效果，Swap 这栏的 total 为 0，表示关闭成功。上面的命令会永久禁用 Swap，即使重启后也会生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">free -h</span><br>               total        used        free      shared  buff/cache   available<br>Mem:           7.7Gi       415Mi       6.5Gi       1.0Mi       851Mi       7.1Gi<br>Swap:             0B          0B          0B<br></code></pre></td></tr></table></figure><blockquote><p>🤔️ 为什么安装 k8s 要需要关闭 Swap？</p><p>在安装 Kubernetes 集群时，需要关闭 swap。原因是 Kubernetes 通过 cgroup 来对容器进行资源限制，而 cgroup 只能控制实际内存，无法控制 swap，因此开启 swap 后可能会导致资源不受限制，进而导致容器运行不稳定或者宕机。因此关闭 swap 可以提高 Kubernetes 集群的稳定性和安全性。</p></blockquote><h2 id="设置时间同步"><a href="#设置时间同步" class="headerlink" title="设置时间同步"></a>设置时间同步</h2><p>在所有主机上执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开终端输入以下命令安装ntpdate工具。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt install ntpdate</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再输入命令设置系统时间与网络时间同步。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ntpdate cn.pool.ntp.org</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后输入命令将时间更新到硬件上即可。</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hwclock --systohc</span><br></code></pre></td></tr></table></figure><blockquote><p>🤔️ 安装 k8s 为什么需要设置时间同步？</p><p>在 Kubernetes 集群中，各个节点之间需要进行协调和通信，如果各个节点的时间不同步，将会导致一些问题，例如：</p><ol><li>证书问题：Kubernetes 使用 TLS 证书进行节点间的认证和通信，如果各个节点的时间不同步，可能导致证书过期或者无法验证等问题。</li><li>日志问题：各个节点的日志需要进行时间戳的记录，如果各个节点的时间不同步，可能导致日志顺序错乱或者无法定位问题。</li></ol><p>因此，在安装 Kubernetes 时需要设置时间同步，保证各个节点之间的时间是一致的，从而避免出现以上问题。</p></blockquote><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a><del>安装 Docker</del></h2><p><del>因为我在安装 Ubuntu 时勾选了 Docker，所以系统已经默认安装好了 Docker。</del></p><h2 id="所有节点安装-Containerd"><a href="#所有节点安装-Containerd" class="headerlink" title="所有节点安装 Containerd"></a>所有节点安装 Containerd</h2><p>在所有节点执行，master 节点和 worker 节点都需要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 cni 插件所需目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /etc/cni/net.d /opt/cni/bin</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压 cni 二进制包</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar xf cni-plugins-linux-amd64-v1.1.1.tgz -C /opt/cni/bin/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://github.com/containerd/containerd/releases/download/v1.6.4/cri-containerd-cni-1.6.4-linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -C / -xzf cri-containerd-cni-1.6.4-linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建服务启动文件</span><br>cat &gt; /etc/systemd/system/containerd.service &lt;&lt;EOF<br>[Unit]<br>Description=containerd container runtime<br>Documentation=https://containerd.io<br>After=network.target local-fs.target<br>[Service]<br>ExecStartPre=-/sbin/modprobe overlay<br>ExecStart=/usr/local/bin/containerd<br>Type=notify<br>Delegate=yes<br>KillMode=process<br>Restart=always<br>RestartSec=5<br>LimitNPROC=infinity<br>LimitCORE=infinity<br>LimitNOFILE=infinity<br>TasksMax=infinity<br>OOMScoreAdjust=-999<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p>配置 Containerd 所需的模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf<br>overlay<br>br_netfilter<br>EOF<br></code></pre></td></tr></table></figure><p>加载模块，设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart systemd-modules-load.service</span><br></code></pre></td></tr></table></figure><p>配置Containerd所需的内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf<br>net.bridge.bridge-nf-call-iptables  = 1<br>net.ipv4.ip_forward                 = 1<br>net.bridge.bridge-nf-call-ip6tables = 1<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载内核</span> <br>sysctl --system<br></code></pre></td></tr></table></figure><p>创建 Containerd 的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置文件</span><br>mkdir -p /etc/containerd<br>containerd config default | tee /etc/containerd/config.toml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改 Containerd 的配置文件</span><br>sed -i &quot;s#SystemdCgroup\ \=\ false#SystemdCgroup\ \=\ true#g&quot; /etc/containerd/config.toml<br><br>cat /etc/containerd/config.toml | grep SystemdCgroup<br><br>sed -i &quot;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/abcdocker#g&quot; /etc/containerd/config.toml<br><br>cat /etc/containerd/config.toml | grep sandbox_image<br></code></pre></td></tr></table></figure><p>手动删除 <code>/etc/containerd/config.toml</code> 中的 <code>systemd_cgroup = false</code> 这一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><p>设置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable --now containerd<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ctr version</span><br>Client:<br>  Version:  v1.6.4<br>  Revision: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16<br>  Go version: go1.17.9<br>Server:<br>  Version:  v1.6.4<br>  Revision: 212e8b6fa2f44b9c21b2798135fc6fb7c53efc16<br>  UUID: f3171aee-67b0-4e01-871b-2e93674af2ad<br></code></pre></td></tr></table></figure><h1 id="k8s-环境部署"><a href="#k8s-环境部署" class="headerlink" title="k8s 环境部署"></a>k8s 环境部署</h1><h2 id="下载相关二进制文件"><a href="#下载相关二进制文件" class="headerlink" title="下载相关二进制文件"></a>下载相关二进制文件</h2><p>在 master 节点执行下面的命令，下载 k8s 相关的可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://dl.k8s.io/v1.24.3/kubernetes-server-linux-amd64.tar.gz</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget https://github.com/etcd-io/etcd/releases/download/v3.5.4/etcd-v3.5.4-linux-amd64.tar.gz</span><br></code></pre></td></tr></table></figure><p>解压获得可执行文件，将解压到 <code>/usr/local/bin</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf kubernetes-server-linux-amd64.tar.gz  --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kube&#123;<span class="hljs-built_in">let</span>,ctl,-apiserver,-controller-manager,-scheduler,-proxy&#125;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">tar -xf etcd-v3.5.4-linux-amd64.tar.gz --strip-components=1 -C /usr/local/bin etcd-v3.5.4-linux-amd64/etcd&#123;,ctl&#125;</span><br></code></pre></td></tr></table></figure><p>检查<code>/usr/local/bin</code>下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /usr/local/bin/</span><br>cfssl      etcd     kube-apiserver           kubectl  kube-proxy<br>cfssljson  etcdctl  kube-controller-manager  kubelet  kube-scheduler<br></code></pre></td></tr></table></figure><p>验证二进制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubelet --version</span><br>Kubernetes v1.24.3<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl version</span><br>etcdctl version: 3.5.4<br>API version: 3.5<br></code></pre></td></tr></table></figure><p>将刚刚解压的二进制文件拷贝到其它节点上（另外两个节点都是计算节点，所以其实不用拷贝 etcd 相关的可执行文件，但是 kubectl 什么的还是需要的，所以影响不大）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in k8s-worker1 k8s-worker2;do   <br>scp /usr/local/bin/kube* root@$i:/usr/local/bin/    <br>scp /usr/local/bin/&#123;etcd,etcdctl&#125;   root@$i:/usr/local/bin/<br>done<br></code></pre></td></tr></table></figure><h2 id="准备一个目录用来存放证书配置文件"><a href="#准备一个目录用来存放证书配置文件" class="headerlink" title="准备一个目录用来存放证书配置文件"></a>准备一个目录用来存放证书配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> pki</span><br></code></pre></td></tr></table></figure><h2 id="下载配置-cfssl-证书"><a href="#下载配置-cfssl-证书" class="headerlink" title="下载配置 cfssl 证书"></a>下载配置 cfssl 证书</h2><blockquote><p>⚠️ 只需在控制节点 k8s-master 上执行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget <span class="hljs-string">&quot;https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssl_1.6.1_linux_amd64&quot;</span> -O /usr/local/bin/cfssl</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget <span class="hljs-string">&quot;https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssljson_1.6.1_linux_amd64&quot;</span> -O /usr/local/bin/cfssljson</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x /usr/local/bin/cfssl /usr/local/bin/cfssljson</span><br></code></pre></td></tr></table></figure><h2 id="创建证书配置文件"><a href="#创建证书配置文件" class="headerlink" title="创建证书配置文件"></a>创建证书配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> pki</span><br></code></pre></td></tr></table></figure><p>下面这段 shell 是用来创建一个 admin 用户的证书签发请求文件 <code>admin-csr.json</code>，其中包含了以下信息：</p><ul><li><code>CN</code>：Common Name，即证书的名称，这里是 <code>admin</code>。</li><li><code>key</code>：用于指定生成密钥的算法及长度，这里是 <code>rsa</code> 算法，长度是 <code>2048</code> 位。</li><li><code>names</code>：用于指定证书中的主题（Subject）信息，包括国家（C）、省（ST）、城市（L）、组织（O）和组织单位（OU），这里主要指定了组织为 <code>system:masters</code>，也就是 Kubernetes 的管理员。</li></ul><p>该证书用于验证用户 <code>admin</code> 对 Kubernetes API Server 的访问权限，由 Kubernetes 的证书管理工具 <code>cfssl</code> 根据此文件生成证书。</p><p>（以上内容来自 ChatGPT。。。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; admin-csr.json &lt;&lt; <span class="hljs-string">EOF</span></span> <br>&#123;<br>  &quot;CN&quot;: &quot;admin&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:masters&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>下面这段 shell 是定义 CA 的配置文件，主要包含两个部分，”signing” 和 “profiles”。</p><p>其中，”signing” 部分定义了默认的证书过期时间，这里设置为 876000 小时，也就是 100 年。这个时间可以根据实际情况进行调整。</p><p>“profiles” 部分定义了不同 profile 的配置信息。这里只定义了一个叫做 “kubernetes” 的 profile，该 profile 的用途包括 “signing”、”key encipherment”、”server auth” 和 “client auth”，也就是该 profile 适用于用于签发和验证服务器和客户端证书，同时也能用于加密传输数据。该 profile 的证书过期时间也设置为 876000 小时，与默认的证书过期时间相同。</p><blockquote><p>CA，即证书授权中心（Certificate Authority），是指负责签发、管理和吊销数字证书的可信机构。在网络通信中，数字证书起到验证通信双方身份的作用，CA 则是负责颁发数字证书，以及验证证书的真实性和有效性。</p><p>CA 通常由政府、军队、金融机构等具有一定信誉和安全保障能力的机构所担任，以确保数字证书的安全性和可靠性。通过使用CA，数字证书的颁发和验证得以形成一个闭环，使得网络通信过程更加安全和可靠。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; ca-config.json &lt;&lt; <span class="hljs-string">EOF</span></span> <br>&#123;<br>  &quot;signing&quot;: &#123;<br>    &quot;default&quot;: &#123;<br>      &quot;expiry&quot;: &quot;876000h&quot;<br>    &#125;,<br>    &quot;profiles&quot;: &#123;<br>      &quot;kubernetes&quot;: &#123;<br>        &quot;usages&quot;: [<br>            &quot;signing&quot;,<br>            &quot;key encipherment&quot;,<br>            &quot;server auth&quot;,<br>            &quot;client auth&quot;<br>        ],<br>        &quot;expiry&quot;: &quot;876000h&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>下面这段 shell 是用于创建 etcd CA 证书签名请求文件的 JSON 配置文件。其中，”CN” 是证书的通用名称，”key” 定义了加密算法和密钥长度，”names” 列出了证书的主题，”ca” 定义了证书颁发机构的过期时间。该文件会被用于生成 etcd CA 证书，用于签发和管理 etcd 集群中的其他证书，保证集群通信的安全性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &gt; etcd-ca-csr.json  &lt;&lt; <span class="hljs-string">EOF</span></span> <br>&#123;<br>  &quot;CN&quot;: &quot;etcd&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;etcd&quot;,<br>      &quot;OU&quot;: &quot;Etcd Security&quot;<br>    &#125;<br>  ],<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><h3 id="这部分直接看这里"><a href="#这部分直接看这里" class="headerlink" title="这部分直接看这里"></a>这部分直接看这里</h3><blockquote><p>发现这部分 shell 有点多，懒得一个一个问 ChatGPT 什么意思了，暂时也不关注这些证书相关的东西了。。。</p></blockquote><p>直接将下面这些命令复制到 terminal 回车即可，会一并创建这些文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; admin-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;admin&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:masters&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; ca-config.json &lt;&lt; EOF <br>&#123;<br>  &quot;signing&quot;: &#123;<br>    &quot;default&quot;: &#123;<br>      &quot;expiry&quot;: &quot;876000h&quot;<br>    &#125;,<br>    &quot;profiles&quot;: &#123;<br>      &quot;kubernetes&quot;: &#123;<br>        &quot;usages&quot;: [<br>            &quot;signing&quot;,<br>            &quot;key encipherment&quot;,<br>            &quot;server auth&quot;,<br>            &quot;client auth&quot;<br>        ],<br>        &quot;expiry&quot;: &quot;876000h&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; etcd-ca-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;etcd&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;etcd&quot;,<br>      &quot;OU&quot;: &quot;Etcd Security&quot;<br>    &#125;<br>  ],<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; front-proxy-ca-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;kubernetes&quot;,<br>  &quot;key&quot;: &#123;<br>     &quot;algo&quot;: &quot;rsa&quot;,<br>     &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; kubelet-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:node:\$NODE&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:nodes&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; manager-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:kube-controller-manager&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:kube-controller-manager&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; apiserver-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;kube-apiserver&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;Kubernetes&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; ca-csr.json   &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;kubernetes&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;Kubernetes&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ],<br>  &quot;ca&quot;: &#123;<br>    &quot;expiry&quot;: &quot;876000h&quot;<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; etcd-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;etcd&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;etcd&quot;,<br>      &quot;OU&quot;: &quot;Etcd Security&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; front-proxy-client-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;front-proxy-client&quot;,<br>  &quot;key&quot;: &#123;<br>     &quot;algo&quot;: &quot;rsa&quot;,<br>     &quot;size&quot;: 2048<br>  &#125;<br>&#125;<br>EOF<br>cat &gt; kube-proxy-csr.json  &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:kube-proxy&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:kube-proxy&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br>cat &gt; scheduler-csr.json &lt;&lt; EOF <br>&#123;<br>  &quot;CN&quot;: &quot;system:kube-scheduler&quot;,<br>  &quot;key&quot;: &#123;<br>    &quot;algo&quot;: &quot;rsa&quot;,<br>    &quot;size&quot;: 2048<br>  &#125;,<br>  &quot;names&quot;: [<br>    &#123;<br>      &quot;C&quot;: &quot;CN&quot;,<br>      &quot;ST&quot;: &quot;Beijing&quot;,<br>      &quot;L&quot;: &quot;Beijing&quot;,<br>      &quot;O&quot;: &quot;system:kube-scheduler&quot;,<br>      &quot;OU&quot;: &quot;Kubernetes-manual&quot;<br>    &#125;<br>  ]<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><p>继续复制执行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br>mkdir bootstrap<br>cd bootstrap<br>cat &gt; bootstrap.secret.yaml &lt;&lt; EOF <br>apiVersion: v1<br>kind: Secret<br>metadata:<br>  name: bootstrap-token-c8ad9c<br>  namespace: kube-system<br>type: bootstrap.kubernetes.io/token<br>stringData:<br>  description: &quot;The default bootstrap token generated by &#x27;kubelet &#x27;.&quot;<br>  token-id: c8ad9c<br>  token-secret: 2e4d610cf3e7426e<br>  usage-bootstrap-authentication: &quot;true&quot;<br>  usage-bootstrap-signing: &quot;true&quot;<br>  auth-extra-groups:  system:bootstrappers:default-node-token,system:bootstrappers:worker,system:bootstrappers:ingress<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: kubelet-bootstrap<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:node-bootstrapper<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group<br>  name: system:bootstrappers:default-node-token<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: node-autoapprove-bootstrap<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:certificates.k8s.io:certificatesigningrequests:nodeclient<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group<br>  name: system:bootstrappers:default-node-token<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: node-autoapprove-certificate-rotation<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclient<br>subjects:<br>- apiGroup: rbac.authorization.k8s.io<br>  kind: Group<br>  name: system:nodes<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  annotations:<br>    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;<br>  labels:<br>    kubernetes.io/bootstrapping: rbac-defaults<br>  name: system:kube-apiserver-to-kubelet<br>rules:<br>  - apiGroups:<br>      - &quot;&quot;<br>    resources:<br>      - nodes/proxy<br>      - nodes/stats<br>      - nodes/log<br>      - nodes/spec<br>      - nodes/metrics<br>    verbs:<br>      - &quot;*&quot;<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRoleBinding<br>metadata:<br>  name: system:kube-apiserver<br>  namespace: &quot;&quot;<br>roleRef:<br>  apiGroup: rbac.authorization.k8s.io<br>  kind: ClusterRole<br>  name: system:kube-apiserver-to-kubelet<br>subjects:<br>  - apiGroup: rbac.authorization.k8s.io<br>    kind: User<br>    name: kube-apiserver<br>EOF<br></code></pre></td></tr></table></figure><p>这些 Kubernetes 配置包含以下内容：</p><ol><li><code>bootstrap-token-c8ad9c</code>: 用于启动 Kubernetes 集群的默认引导令牌及其相关权限信息，包括描述信息、令牌 ID、令牌密钥以及用于启动认证和签名等权限的标志。</li><li><code>kubelet-bootstrap</code> ClusterRoleBinding：将 <code>system:node-bootstrapper</code> ClusterRole 分配给 <code>system:bootstrappers:default-node-token</code> 组，以便允许节点使用引导令牌进行身份验证和授权。</li><li><code>node-autoapprove-bootstrap</code> ClusterRoleBinding：自动批准使用引导令牌发出的节点客户端证书签名请求。</li><li><code>node-autoapprove-certificate-rotation</code> ClusterRoleBinding：自动批准用于自签名节点证书轮换的签名请求。</li><li><code>system:kube-apiserver-to-kubelet</code> ClusterRole：定义了一个角色，该角色允许 kube-apiserver 访问 kubelet API，以便可以从 kube-apiserver 发送请求到节点的 kubelet API，以获取节点信息和执行操作。</li><li><code>system:kube-apiserver</code> ClusterRoleBinding：将 <code>system:kube-apiserver-to-kubelet</code> ClusterRole 分配给 kube-apiserver 用户，以便在整个 Kubernetes 集群范围内允许 kube-apiserver 访问 kubelet API。</li></ol><h2 id="ETCD-证书"><a href="#ETCD-证书" class="headerlink" title="ETCD 证书"></a>ETCD 证书</h2><blockquote><p>本节操作只需要 master 节点执行即可。</p></blockquote><h3 id="创建证书文件"><a href="#创建证书文件" class="headerlink" title="创建证书文件"></a>创建证书文件</h3><p>创建用于存放证书的文件夹</p><p>PS：因为我只有一个控制面节点 k8s-master，而 etcd 只需要部署在控制面即可，所以不需要在其他节点执行同样的操作，直接在本节点创建</p><p><del>for i in k8s-master k8s-worker1 k8s-worker2;do</del><br>   <del>ssh root@$i mkdir &#x2F;etc&#x2F;etcd&#x2F;ssl -p</del><br>   <del>echo $i create done</del><br><del>done</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/etcd/ssl -p<br></code></pre></td></tr></table></figure><h3 id="生成-etcd-证书和-etcd-证书的-key"><a href="#生成-etcd-证书和-etcd-证书的-key" class="headerlink" title="生成 etcd 证书和 etcd 证书的 key"></a>生成 etcd 证书和 etcd 证书的 key</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> pki</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert -initca etcd-ca-csr.json | cfssljson -bare /etc/etcd/ssl/etcd-ca</span><br></code></pre></td></tr></table></figure><p>注意 <code>-hostname</code> 这里的参数，改成你对应 master 节点的 hostname 和 IP，别直接 cv 过来就执行，如果你不小心执行错了（和我一样没注意，直接 cv 过来就执行，导致后续 etcd 不认这个节点），直接修改下面的 shell 后再重新执行一遍即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert \</span><br><span class="language-bash">   -ca=/etc/etcd/ssl/etcd-ca.pem \</span><br><span class="language-bash">   -ca-key=/etc/etcd/ssl/etcd-ca-key.pem \</span><br><span class="language-bash">   -config=ca-config.json \</span><br><span class="language-bash">   -hostname=k8s-master,192.168.223.128 \</span><br><span class="language-bash">   -profile=kubernetes \</span><br><span class="language-bash">   etcd-csr.json | cfssljson -bare /etc/etcd/ssl/etcd</span><br></code></pre></td></tr></table></figure><p>执行完成后，将会在 <code>/etc/etcd/ssl</code> 目录下生成这些证书文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/etcd/ssl</span><br>etcd-ca.csr  etcd-ca-key.pem  etcd-ca.pem  etcd.csr  etcd-key.pem  etcd.pem<br></code></pre></td></tr></table></figure><h3 id="将证书复制到其他节点"><a href="#将证书复制到其他节点" class="headerlink" title="将证书复制到其他节点"></a>将证书复制到其他节点</h3><p>我的单节点控制面用不上了</p><p><del>for i in k8s-worker1 k8s-worker2;do</del><br>    <del>ssh $i “mkdir -p &#x2F;etc&#x2F;etcd&#x2F;ssl”</del><br>    <del>scp &#x2F;etc&#x2F;etcd&#x2F;ssl&#x2F;* $i:&#x2F;etc&#x2F;etcd&#x2F;ssl&#x2F;</del><br><del>done</del></p><h2 id="k8s-集群证书"><a href="#k8s-集群证书" class="headerlink" title="k8s 集群证书"></a>k8s 集群证书</h2><blockquote><p>本节操作只需要 master 节点执行即可。</p></blockquote><h3 id="创建所有证书的存放目录"><a href="#创建所有证书的存放目录" class="headerlink" title="创建所有证书的存放目录"></a>创建所有证书的存放目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /etc/kubernetes/pki</span><br></code></pre></td></tr></table></figure><h3 id="生成一个根证书"><a href="#生成一个根证书" class="headerlink" title="生成一个根证书"></a>生成一个根证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert -initca ca-csr.json | cfssljson -bare /etc/kubernetes/pki/ca</span><br></code></pre></td></tr></table></figure><h3 id="创建-API-Server-凭证与私钥"><a href="#创建-API-Server-凭证与私钥" class="headerlink" title="创建 API Server 凭证与私钥"></a>创建 API Server 凭证与私钥</h3><p>10.96.0.1 是 service 网段的第一个地址，hostname 中指定了生成的证书的 Subject Alternative Names (SANs)，即证书允许被使用的主机名或 IP 地址，这里我填写了 3 台虚拟机的 hostname 和 IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert   \</span><br><span class="language-bash">-ca=/etc/kubernetes/pki/ca.pem   \</span><br><span class="language-bash">-ca-key=/etc/kubernetes/pki/ca-key.pem   \</span><br><span class="language-bash">-config=ca-config.json   \</span><br><span class="language-bash">-hostname=10.96.0.1,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.default.svc.cluster.local,k8s-master,k8s-worker1,k8s-worker2,192.168.223.128,192.168.223.129,192.168.223.130   \</span><br><span class="language-bash">-profile=kubernetes   apiserver-csr.json | cfssljson -bare /etc/kubernetes/pki/apiserver</span><br></code></pre></td></tr></table></figure><h3 id="生成-apiserver"><a href="#生成-apiserver" class="headerlink" title="生成 apiserver"></a>生成 apiserver</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert   -initca front-proxy-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-ca</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert  \</span><br><span class="language-bash">-ca=/etc/kubernetes/pki/front-proxy-ca.pem   \</span><br><span class="language-bash">-ca-key=/etc/kubernetes/pki/front-proxy-ca-key.pem   \</span><br><span class="language-bash">-config=ca-config.json   \</span><br><span class="language-bash">-profile=kubernetes   front-proxy-client-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-client</span><br></code></pre></td></tr></table></figure><h3 id="生成-controller-manage-证书"><a href="#生成-controller-manage-证书" class="headerlink" title="生成 controller-manage 证书"></a>生成 controller-manage 证书</h3><p>注意替换下面命令中的 –server，IP 填写 api-server 的 IP，在我这里是 master 节点的 IP，端口填写 api-server 的 port，这个值在 api server 配置中的 –secure-port&#x3D;6443 指定</p><blockquote><p>疑问：</p><p>我这里只有一个 master 节点，所以 api-server 的 IP 就是该 master 节点的 IP，那如果部署方式是多个 master 节点，此时 api-server 的 IP 又该如何填写呢？</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cfssl gencert \</span><br><span class="language-bash">   -ca=/etc/kubernetes/pki/ca.pem \</span><br><span class="language-bash">   -ca-key=/etc/kubernetes/pki/ca-key.pem \</span><br><span class="language-bash">   -config=ca-config.json \</span><br><span class="language-bash">   -profile=kubernetes \</span><br><span class="language-bash">   manager-csr.json | cfssljson -bare /etc/kubernetes/pki/controller-manager</span><br>   <br>   <br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置一个集群项</span><br>kubectl config set-cluster kubernetes \<br>     --certificate-authority=/etc/kubernetes/pki/ca.pem \<br>     --embed-certs=true \<br>     --server=https://192.168.223.128:6443 \<br>     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置一个环境项，一个上下文</span><br>kubectl config set-context system:kube-controller-manager@kubernetes \<br>    --cluster=kubernetes \<br>    --user=system:kube-controller-manager \<br>    --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置一个用户项</span><br>kubectl config set-credentials system:kube-controller-manager \<br>     --client-certificate=/etc/kubernetes/pki/controller-manager.pem \<br>     --client-key=/etc/kubernetes/pki/controller-manager-key.pem \<br>     --embed-certs=true \<br>     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置默认环境</span><br>kubectl config use-context system:kube-controller-manager@kubernetes \<br>     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig<br>cfssl gencert \<br>   -ca=/etc/kubernetes/pki/ca.pem \<br>   -ca-key=/etc/kubernetes/pki/ca-key.pem \<br>   -config=ca-config.json \<br>   -profile=kubernetes \<br>   scheduler-csr.json | cfssljson -bare /etc/kubernetes/pki/scheduler<br>kubectl config set-cluster kubernetes \<br>     --certificate-authority=/etc/kubernetes/pki/ca.pem \<br>     --embed-certs=true \<br>     --server=https://192.168.223.128:6443 \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>kubectl config set-credentials system:kube-scheduler \<br>     --client-certificate=/etc/kubernetes/pki/scheduler.pem \<br>     --client-key=/etc/kubernetes/pki/scheduler-key.pem \<br>     --embed-certs=true \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>kubectl config set-context system:kube-scheduler@kubernetes \<br>     --cluster=kubernetes \<br>     --user=system:kube-scheduler \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>kubectl config use-context system:kube-scheduler@kubernetes \<br>     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>cfssl gencert \<br>   -ca=/etc/kubernetes/pki/ca.pem \<br>   -ca-key=/etc/kubernetes/pki/ca-key.pem \<br>   -config=ca-config.json \<br>   -profile=kubernetes \<br>   admin-csr.json | cfssljson -bare /etc/kubernetes/pki/admin<br>kubectl config set-cluster kubernetes     \<br>  --certificate-authority=/etc/kubernetes/pki/ca.pem     \<br>  --embed-certs=true     \<br>  --server=https://192.168.223.128:6443     \<br>  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br>kubectl config set-credentials kubernetes-admin  \<br>  --client-certificate=/etc/kubernetes/pki/admin.pem     \<br>  --client-key=/etc/kubernetes/pki/admin-key.pem     \<br>  --embed-certs=true     \<br>  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br>kubectl config set-context kubernetes-admin@kubernetes    \<br>  --cluster=kubernetes     \<br>  --user=kubernetes-admin     \<br>  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br>kubectl config use-context kubernetes-admin@kubernetes  --kubeconfig=/etc/kubernetes/admin.kubeconfig<br></code></pre></td></tr></table></figure><h3 id="生成-kube-proxy-证书"><a href="#生成-kube-proxy-证书" class="headerlink" title="生成 kube-proxy 证书"></a>生成 kube-proxy 证书</h3><p>注意替换下面命令中的 –server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">cfssl gencert \<br>   -ca=/etc/kubernetes/pki/ca.pem \<br>   -ca-key=/etc/kubernetes/pki/ca-key.pem \<br>   -config=ca-config.json \<br>   -profile=kubernetes \<br>   kube-proxy-csr.json | cfssljson -bare /etc/kubernetes/pki/kube-proxy<br>kubectl config set-cluster kubernetes     \<br>  --certificate-authority=/etc/kubernetes/pki/ca.pem     \<br>  --embed-certs=true     \<br>  --server=https://192.168.223.128:6443     \<br>  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br>kubectl config set-credentials kube-proxy  \<br>  --client-certificate=/etc/kubernetes/pki/kube-proxy.pem     \<br>  --client-key=/etc/kubernetes/pki/kube-proxy-key.pem     \<br>  --embed-certs=true     \<br>  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br>kubectl config set-context kube-proxy@kubernetes    \<br>  --cluster=kubernetes     \<br>  --user=kube-proxy     \<br>  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br>kubectl config use-context kube-proxy@kubernetes  --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig<br></code></pre></td></tr></table></figure><h3 id="创建-ServiceAccount-Key"><a href="#创建-ServiceAccount-Key" class="headerlink" title="创建 ServiceAccount Key"></a>创建 ServiceAccount Key</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl genrsa -out /etc/kubernetes/pki/sa.key 2048</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">openssl rsa -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/sa.key -pubout -out /etc/kubernetes/pki/sa.pub</span><br></code></pre></td></tr></table></figure><p>其他节点创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in k8s-worker1 k8s-worker2;do    <br>ssh $i &quot;mkdir  /etc/kubernetes/pki/ -p&quot;    <br>scp -r /etc/kubernetes/pki $i:/etc/kubernetes/<br>done<br></code></pre></td></tr></table></figure><h3 id="查看各个节点的证书"><a href="#查看各个节点的证书" class="headerlink" title="查看各个节点的证书"></a>查看各个节点的证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/kubernetes/pki/</span><br>admin.csr          ca.csr                      front-proxy-ca.csr          kube-proxy.csr      scheduler-key.pem<br>admin-key.pem      ca-key.pem                  front-proxy-ca-key.pem      kube-proxy-key.pem  scheduler.pem<br>admin.pem          ca.pem                      front-proxy-ca.pem          kube-proxy.pem<br>apiserver.csr      controller-manager.csr      front-proxy-client.csr      sa.key<br>apiserver-key.pem  controller-manager-key.pem  front-proxy-client-key.pem  sa.pub<br>apiserver.pem      controller-manager.pem      front-proxy-client.pem      scheduler.csr<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一共 26 个就对了</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /etc/kubernetes/pki/ |<span class="hljs-built_in">wc</span> -l</span><br>26<br></code></pre></td></tr></table></figure><h2 id="配置-ETCD"><a href="#配置-ETCD" class="headerlink" title="配置 ETCD"></a>配置 ETCD</h2><h3 id="master-节点"><a href="#master-节点" class="headerlink" title="master 节点"></a>master 节点</h3><p>在 master 节点执行下面的 shell，注意将配置里的 IP 改为 master 节点的 IP，hostname 也要修改成对应的，initial-cluster 修改成对应的几个节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可</span><br>cat &gt; /etc/etcd/etcd.config.yml &lt;&lt; EOF <br>name: &#x27;k8s-master&#x27;<br>data-dir: /var/lib/etcd<br>wal-dir: /var/lib/etcd/wal<br>snapshot-count: 5000<br>heartbeat-interval: 100<br>election-timeout: 1000<br>quota-backend-bytes: 0<br>listen-peer-urls: &#x27;https://192.168.223.128:2380&#x27;<br>listen-client-urls: &#x27;https://192.168.223.128:2379,http://127.0.0.1:2379&#x27;<br>max-snapshots: 3<br>max-wals: 5<br>cors:<br>initial-advertise-peer-urls: &#x27;https://192.168.223.128:2380&#x27;<br>advertise-client-urls: &#x27;https://192.168.223.128:2379&#x27;<br>discovery:<br>discovery-fallback: &#x27;proxy&#x27;<br>discovery-proxy:<br>discovery-srv:<br>initial-cluster: &#x27;k8s-master=https://192.168.223.128:2380&#x27;<br>initial-cluster-token: &#x27;etcd-k8s-cluster&#x27;<br>initial-cluster-state: &#x27;new&#x27;<br>strict-reconfig-check: false<br>enable-v2: true<br>enable-pprof: true<br>proxy: &#x27;off&#x27;<br>proxy-failure-wait: 5000<br>proxy-refresh-interval: 30000<br>proxy-dial-timeout: 1000<br>proxy-write-timeout: 5000<br>proxy-read-timeout: 0<br>client-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>peer-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  peer-client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>debug: false<br>log-package-levels:<br>log-outputs: [default]<br>force-new-cluster: false<br>EOF<br></code></pre></td></tr></table></figure><h3 id="k8s-worker1-节点"><a href="#k8s-worker1-节点" class="headerlink" title="k8s-worker1 节点"></a><del>k8s-worker1 节点</del></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可</span><br>cat &gt; /etc/etcd/etcd.config.yml &lt;&lt; EOF <br>name: &#x27;k8s-worker1&#x27;<br>data-dir: /var/lib/etcd<br>wal-dir: /var/lib/etcd/wal<br>snapshot-count: 5000<br>heartbeat-interval: 100<br>election-timeout: 1000<br>quota-backend-bytes: 0<br>listen-peer-urls: &#x27;https://192.168.223.129:2380&#x27;<br>listen-client-urls: &#x27;https://192.168.223.129:2379,http://127.0.0.1:2379&#x27;<br>max-snapshots: 3<br>max-wals: 5<br>cors:<br>initial-advertise-peer-urls: &#x27;https://192.168.223.129:2380&#x27;<br>advertise-client-urls: &#x27;https://192.168.223.129:2379&#x27;<br>discovery:<br>discovery-fallback: &#x27;proxy&#x27;<br>discovery-proxy:<br>discovery-srv:<br>initial-cluster: &#x27;k8s-master=https://192.168.223.128:2380,k8s-worker1=https://192.168.223.129:2380,k8s-worker2=https://192.168.223.130:2380&#x27;<br>initial-cluster-token: &#x27;etcd-k8s-cluster&#x27;<br>initial-cluster-state: &#x27;new&#x27;<br>strict-reconfig-check: false<br>enable-v2: true<br>enable-pprof: true<br>proxy: &#x27;off&#x27;<br>proxy-failure-wait: 5000<br>proxy-refresh-interval: 30000<br>proxy-dial-timeout: 1000<br>proxy-write-timeout: 5000<br>proxy-read-timeout: 0<br>client-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>peer-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  peer-client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>debug: false<br>log-package-levels:<br>log-outputs: [default]<br>force-new-cluster: false<br>EOF<br></code></pre></td></tr></table></figure><h3 id="k8s-worker2-节点"><a href="#k8s-worker2-节点" class="headerlink" title="k8s-worker2 节点"></a><del>k8s-worker2 节点</del></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可</span><br>cat &gt; /etc/etcd/etcd.config.yml &lt;&lt; EOF <br>name: &#x27;k8s-worker2&#x27;<br>data-dir: /var/lib/etcd<br>wal-dir: /var/lib/etcd/wal<br>snapshot-count: 5000<br>heartbeat-interval: 100<br>election-timeout: 1000<br>quota-backend-bytes: 0<br>listen-peer-urls: &#x27;https://192.168.223.130:2380&#x27;<br>listen-client-urls: &#x27;https://192.168.223.130:2379,http://127.0.0.1:2379&#x27;<br>max-snapshots: 3<br>max-wals: 5<br>cors:<br>initial-advertise-peer-urls: &#x27;https://192.168.223.130:2380&#x27;<br>advertise-client-urls: &#x27;https://192.168.223.130:2379&#x27;<br>discovery:<br>discovery-fallback: &#x27;proxy&#x27;<br>discovery-proxy:<br>discovery-srv:<br>initial-cluster: &#x27;k8s-master=https://192.168.223.128:2380,k8s-worker1=https://192.168.223.129:2380,k8s-worker2=https://192.168.223.130:2380&#x27;<br>initial-cluster-token: &#x27;etcd-k8s-cluster&#x27;<br>initial-cluster-state: &#x27;new&#x27;<br>strict-reconfig-check: false<br>enable-v2: true<br>enable-pprof: true<br>proxy: &#x27;off&#x27;<br>proxy-failure-wait: 5000<br>proxy-refresh-interval: 30000<br>proxy-dial-timeout: 1000<br>proxy-write-timeout: 5000<br>proxy-read-timeout: 0<br>client-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>peer-transport-security:<br>  cert-file: &#x27;/etc/kubernetes/pki/etcd/etcd.pem&#x27;<br>  key-file: &#x27;/etc/kubernetes/pki/etcd/etcd-key.pem&#x27;<br>  peer-client-cert-auth: true<br>  trusted-ca-file: &#x27;/etc/kubernetes/pki/etcd/etcd-ca.pem&#x27;<br>  auto-tls: true<br>debug: false<br>log-package-levels:<br>log-outputs: [default]<br>force-new-cluster: false<br>EOF<br></code></pre></td></tr></table></figure><p>创建 etcd 启动服务（需要在所有 master 节点操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF<br>[Unit]<br>Description=Etcd Service<br>Documentation=https://coreos.com/etcd/docs/latest/<br>After=network.target<br>[Service]<br>Type=notify<br>ExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/etcd.config.yml<br>Restart=on-failure<br>RestartSec=10<br>LimitNOFILE=65536<br>[Install]<br>WantedBy=multi-user.target<br>Alias=etcd3.service<br>EOF<br></code></pre></td></tr></table></figure><p>拷贝 ETCD 证书</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /etc/kubernetes/pki/etcd<br>ln -s /etc/etcd/ssl/* /etc/kubernetes/pki/etcd/<br>systemctl daemon-reload<br>systemctl enable --now etcd<br></code></pre></td></tr></table></figure><p>查看 etcd 状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">etcdctl --endpoints=<span class="hljs-string">&quot;k8s-master:2379&quot;</span> --cacert=/etc/kubernetes/pki/etcd/etcd-ca.pem --cert=/etc/kubernetes/pki/etcd/etcd.pem --key=/etc/kubernetes/pki/etcd/etcd-key.pem  endpoint status --write-out=table</span><br></code></pre></td></tr></table></figure><blockquote><p>之前的配置文件写错了，应该只有 master 节点需要运行 etcd，所以配置文件中的 initial-cluster 需要改为 k8s-master&#x3D;<a href="https://192.168.223.128:2380'，也就是只添加">https://192.168.223.128:2380&#39;，也就是只添加</a> master 本身即可，删掉之前加入的两个 worker 节点，修改为：</p><p><code>initial-cluster: &#39;k8s-master=https://192.168.223.128:2380&#39;</code></p><p>然后执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo systemctl restart etcd</span><br></code></pre></td></tr></table></figure><p>重新运行 etcd，但是发现无法运行，手动执行 etcd –config-file&#x3D;&#x2F;etc&#x2F;etcd&#x2F;etcd.config.yml（也可以使用 <code>sudo journalctl -u etcd</code>），发现日志里输出 “error”:”dial tcp 192.168.223.129:2380: connect: connection refused”，这表示 etcd 依旧在尝试连接 worker1 的 etcd，明明改了 initial-cluster，为什么没有生效呢？</p><p>我重新排查日志，发现有这么一行有点可疑：</p><p>{“level”:”info”,”ts”:”2023-04-15T16:58:41.252Z”,”caller”:”etcdmain&#x2F;etcd.go:116”,”msg”:”server has been already initialized”,”data-dir”:”&#x2F;var&#x2F;lib&#x2F;etcd”,”dir-type”:”member”}</p><p>尝试删掉 &#x2F;var&#x2F;lib&#x2F;etcd&#x2F;member，再次执行 sudo systemctl restart etcd，发现命令不会阻塞了，etcd 成功运行。（此时我只想夸自己一句牛逼 plus）</p></blockquote><p>如果输出下面这些内容，说明你搞对了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">+-----------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+<br>|    ENDPOINT     |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |<br>+-----------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+<br>| k8s-master:2379 | 2918d818e481030f |   3.5.4 |   20 kB |      true |      false |         5 |         10 |                 10 |        |<br>+-----------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+<br></code></pre></td></tr></table></figure><h2 id="ApiServer-配置"><a href="#ApiServer-配置" class="headerlink" title="ApiServer 配置"></a>ApiServer 配置</h2><p>创建 apiserver 服务启动文件</p><p>需要在每台节点自行修改对应的信息</p><ul><li>–advertise-address 当前节点 IP</li><li>–etcd-servers ETCD 节点信息</li><li>–secure-port apiserver 端口号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes API Server<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=network.target<br>[Service]<br>ExecStart=/usr/local/bin/kube-apiserver \<br>      --v=2  \<br>      --logtostderr=true  \<br>      --allow-privileged=true  \<br>      --bind-address=0.0.0.0  \<br>      --secure-port=6443  \<br>      --advertise-address=192.168.223.128 \<br>      --service-cluster-ip-range=10.96.0.0/12,fd00::/108  \<br>      --feature-gates=IPv6DualStack=true  \<br>      --service-node-port-range=30000-32767  \<br>      --etcd-servers=https://k8s-master:2379 \<br>      --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem  \<br>      --etcd-certfile=/etc/etcd/ssl/etcd.pem  \<br>      --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem  \<br>      --client-ca-file=/etc/kubernetes/pki/ca.pem  \<br>      --tls-cert-file=/etc/kubernetes/pki/apiserver.pem  \<br>      --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem  \<br>      --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem  \<br>      --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem  \<br>      --service-account-key-file=/etc/kubernetes/pki/sa.pub  \<br>      --service-account-signing-key-file=/etc/kubernetes/pki/sa.key  \<br>      --service-account-issuer=https://kubernetes.default.svc.cluster.local \<br>      --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \<br>      --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \<br>      --authorization-mode=Node,RBAC  \<br>      --enable-bootstrap-token-auth=true  \<br>      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \<br>      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \<br>      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \<br>      --requestheader-allowed-names=aggregator  \<br>      --requestheader-group-headers=X-Remote-Group  \<br>      --requestheader-extra-headers-prefix=X-Remote-Extra-  \<br>      --requestheader-username-headers=X-Remote-User \<br>      --enable-aggregator-routing=true<br>      # --token-auth-file=/etc/kubernetes/token.csv<br>Restart=on-failure<br>RestartSec=10s<br>LimitNOFILE=65535<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p>启动 apiserver（所有 master 节点）</p><p><del>for i in k8s-01 k8s-02 k8s-03;do</del><br>    <del>ssh $i “systemctl daemon-reload &amp;&amp; systemctl enable –now kube-apiserver”</del><br>    <del>echo “$i”</del><br>    <del>sleep 5</del><br>    <del>ssh $i “systemctl status kube-apiserver”</del><br><del>done</del></p><p>单 master 节点只需要执行下面的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload &amp;&amp; systemctl <span class="hljs-built_in">enable</span> --now kube-apiserver</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sleep</span> 5</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl status kube-apiserver</span><br></code></pre></td></tr></table></figure><p>如果输出类似这样，即 Active: active (running)，则代表成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">● kube-apiserver.service - Kubernetes API Server<br>     Loaded: loaded (/lib/systemd/system/kube-apiserver.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Sat 2023-04-15 18:01:27 UTC; 6s ago<br>       Docs: https://github.com/kubernetes/kubernetes<br>   Main PID: 54969 (kube-apiserver)<br>      Tasks: 15 (limit: 9362)<br>     Memory: 290.8M<br>        CPU: 3.201s<br></code></pre></td></tr></table></figure><h2 id="Controller-Manage-配置"><a href="#Controller-Manage-配置" class="headerlink" title="Controller-Manage 配置"></a>Controller-Manage 配置</h2><p>172.16.0.0&#x2F;12 为 pod 网段，按需求设置你自己的网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes Controller Manager<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=network.target<br>[Service]<br>ExecStart=/usr/local/bin/kube-controller-manager \<br>      --v=2 \<br>      --logtostderr=true \<br>      --bind-address=127.0.0.1 \<br>      --root-ca-file=/etc/kubernetes/pki/ca.pem \<br>      --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \<br>      --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \<br>      --service-account-private-key-file=/etc/kubernetes/pki/sa.key \<br>      --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig \<br>      --leader-elect=true \<br>      --use-service-account-credentials=true \<br>      --node-monitor-grace-period=40s \<br>      --node-monitor-period=5s \<br>      --pod-eviction-timeout=2m0s \<br>      --controllers=*,bootstrapsigner,tokencleaner \<br>      --allocate-node-cidrs=true \<br>      --feature-gates=IPv6DualStack=true \<br>      --service-cluster-ip-range=10.96.0.0/12,fd00::/108 \<br>      --cluster-cidr=172.16.0.0/12,fc00::/48 \<br>      --node-cidr-mask-size-ipv4=24 \<br>      --node-cidr-mask-size-ipv6=64 \<br>      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem <br>Restart=always<br>RestartSec=10s<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p><strong>配置文件拷贝到其它节点</strong></p><p><del>for i in k8s-02 k8s-03;do<br>    scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kube-controller-manager.service  $i:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;    scp &#x2F;etc&#x2F;kubernetes&#x2F;controller-manager.kubeconfig  $i:&#x2F;etc&#x2F;kubernetes&#x2F;</del><br><del>done</del></p><p>我这边就用不着了</p><p><strong>启动所有节点服务</strong></p><p><del>for i in k8s-01 k8s-02 k8s-03;do</del><br>      <del>ssh $i “systemctl daemon-reload &amp;&amp; systemctl enable –now kube-controller-manager &amp;&amp; systemctl  status kube-controller-manager”</del><br><del>done</del></p><p>我这里也用不着了，只需要执行下面这段即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload &amp;&amp; systemctl <span class="hljs-built_in">enable</span> --now kube-controller-manager &amp;&amp; systemctl  status kube-controller-manager</span><br></code></pre></td></tr></table></figure><p>输出类似下面这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">Created symlink /etc/systemd/system/multi-user.target.wants/kube-controller-manager.service → /lib/systemd/system/kube-controller-manager.service.<br>● kube-controller-manager.service - Kubernetes Controller Manager<br>     Loaded: loaded (/lib/systemd/system/kube-controller-manager.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Sat 2023-04-15 18:14:05 UTC; 5ms ago<br>       Docs: https://github.com/kubernetes/kubernetes<br>   Main PID: 55081 (kube-controller)<br>      Tasks: 6 (limit: 9362)<br>     Memory: 1.6M<br>        CPU: 3ms<br></code></pre></td></tr></table></figure><h2 id="Scheduler-配置"><a href="#Scheduler-配置" class="headerlink" title="Scheduler 配置"></a>Scheduler 配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes Scheduler<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=network.target<br>[Service]<br>ExecStart=/usr/local/bin/kube-scheduler \<br>      --v=2 \<br>      --logtostderr=true \<br>      --bind-address=127.0.0.1 \<br>      --leader-elect=true \<br>      --kubeconfig=/etc/kubernetes/scheduler.kubeconfig<br>Restart=always<br>RestartSec=10s<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><p><del>配置文件拷贝到其它节点</del></p><p><del>for i in k8s-02 k8s-03;do<br>    scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kube-scheduler.service  $i:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<br>    scp &#x2F;etc&#x2F;kubernetes&#x2F;scheduler.kubeconfig $i:&#x2F;etc&#x2F;kubernetes&#x2F;</del><br><del>done</del></p><p>启动所有节点服务</p><p><del>for i in k8s-01 k8s-02 k8s-03;do<br>    ssh $i “systemctl daemon-reload &amp;&amp; systemctl enable –now kube-scheduler &amp;&amp; systemctl  status kube-scheduler”</del><br><del>done</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload &amp;&amp; systemctl <span class="hljs-built_in">enable</span> --now kube-scheduler &amp;&amp; systemctl  status kube-scheduler</span><br></code></pre></td></tr></table></figure><h2 id="上下文配置"><a href="#上下文配置" class="headerlink" title="上下文配置"></a>上下文配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /root/bootstrap<br>kubectl config set-cluster kubernetes     \<br>--certificate-authority=/etc/kubernetes/pki/ca.pem     \<br>--embed-certs=true     <br>--server=https://192.168.223.128:6443     \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br>kubectl config set-credentials tls-bootstrap-token-user     \<br>--token=c8ad9c.2e4d610cf3e7426e \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br>kubectl config set-context tls-bootstrap-token-user@kubernetes     \<br>--cluster=kubernetes     \<br>--user=tls-bootstrap-token-user     \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br>kubectl config use-context tls-bootstrap-token-user@kubernetes     \<br>--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">token的位置在bootstrap.secret.yaml，如果修改的话到这个文件修改</span><br>mkdir -p /root/.kube ; cp /etc/kubernetes/admin.kubeconfig /root/.kube/config<br></code></pre></td></tr></table></figure><p>查看集群状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cs</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这样就对了</span><br>Warning: v1 ComponentStatus is deprecated in v1.19+<br>NAME                 STATUS    MESSAGE                         ERROR<br>scheduler            Healthy   ok<br>controller-manager   Healthy   ok<br>etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;,&quot;reason&quot;:&quot;&quot;&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f bootstrap.secret.yaml</span><br></code></pre></td></tr></table></figure><h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><h3 id="创建-kubelet-启动文件"><a href="#创建-kubelet-启动文件" class="headerlink" title="创建 kubelet 启动文件"></a>创建 kubelet 启动文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF<br>[Unit]<br>Description=Kubernetes Kubelet<br>Documentation=https://github.com/kubernetes/kubernetes<br>After=containerd.service<br>Requires=containerd.service<br>[Service]<br>ExecStart=/usr/local/bin/kubelet \<br>    --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig  \<br>    --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \<br>    --config=/etc/kubernetes/kubelet-conf.yml \<br>    --container-runtime=remote  \<br>    --runtime-request-timeout=15m  \<br>    --container-runtime-endpoint=unix:///run/containerd/containerd.sock  \<br>    --cgroup-driver=systemd \<br>    --node-labels=node.kubernetes.io/node=&#x27;&#x27; \<br>    --feature-gates=IPv6DualStack=true<br>[Install]<br>WantedBy=multi-user.target<br>EOF<br></code></pre></td></tr></table></figure><h3 id="创建-kubelet-配置文件"><a href="#创建-kubelet-配置文件" class="headerlink" title="创建 kubelet 配置文件"></a>创建 kubelet 配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; /etc/kubernetes/kubelet-conf.yml &lt;&lt;EOF<br>apiVersion: kubelet.config.k8s.io/v1beta1<br>kind: KubeletConfiguration<br>address: 0.0.0.0<br>port: 10250<br>readOnlyPort: 10255<br>authentication:<br>  anonymous:<br>    enabled: false<br>  webhook:<br>    cacheTTL: 2m0s<br>    enabled: true<br>  x509:<br>    clientCAFile: /etc/kubernetes/pki/ca.pem<br>authorization:<br>  mode: Webhook<br>  webhook:<br>    cacheAuthorizedTTL: 5m0s<br>    cacheUnauthorizedTTL: 30s<br>cgroupDriver: systemd<br>cgroupsPerQOS: true<br>clusterDNS:<br>- 10.96.0.10<br>clusterDomain: cluster.local<br>containerLogMaxFiles: 5<br>containerLogMaxSize: 10Mi<br>contentType: application/vnd.kubernetes.protobuf<br>cpuCFSQuota: true<br>cpuManagerPolicy: none<br>cpuManagerReconcilePeriod: 10s<br>enableControllerAttachDetach: true<br>enableDebuggingHandlers: true<br>enforceNodeAllocatable:<br>- pods<br>eventBurst: 10<br>eventRecordQPS: 5<br>evictionHard:<br>  imagefs.available: 15%<br>  memory.available: 100Mi<br>  nodefs.available: 10%<br>  nodefs.inodesFree: 5%<br>evictionPressureTransitionPeriod: 5m0s<br>failSwapOn: true<br>fileCheckFrequency: 20s<br>hairpinMode: promiscuous-bridge<br>healthzBindAddress: 127.0.0.1<br>healthzPort: 10248<br>httpCheckFrequency: 20s<br>imageGCHighThresholdPercent: 85<br>imageGCLowThresholdPercent: 80<br>imageMinimumGCAge: 2m0s<br>iptablesDropBit: 15<br>iptablesMasqueradeBit: 14<br>kubeAPIBurst: 10<br>kubeAPIQPS: 5<br>makeIPTablesUtilChains: true<br>maxOpenFiles: 1000000<br>maxPods: 110<br>nodeStatusUpdateFrequency: 10s<br>oomScoreAdj: -999<br>podPidsLimit: -1<br>registryBurst: 10<br>registryPullQPS: 5<br>resolvConf: /etc/resolv.conf<br>rotateCertificates: true<br>runtimeRequestTimeout: 2m0s<br>serializeImagePulls: true<br>staticPodPath: /etc/kubernetes/manifests<br>streamingConnectionIdleTimeout: 4h0m0s<br>syncFrequency: 1m0s<br>volumeStatsAggPeriod: 1m0s<br>EOF<br></code></pre></td></tr></table></figure><h3 id="拷贝证书到其它节点"><a href="#拷贝证书到其它节点" class="headerlink" title="拷贝证书到其它节点"></a><del>拷贝证书到其它节点</del></h3><p><del>for i in k8s-01 k8s-02 k8s-03;do<br>    ssh $i “mkdir -p &#x2F;var&#x2F;lib&#x2F;kubelet &#x2F;var&#x2F;log&#x2F;kubernetes  &#x2F;etc&#x2F;kubernetes&#x2F;manifests&#x2F;“   scp &#x2F;etc&#x2F;kubernetes&#x2F;kubelet-conf.yml $i:&#x2F;etc&#x2F;kubernetes&#x2F;<br>    scp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;kubelet.service  $i:&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;<br>    scp &#x2F;etc&#x2F;kubernetes&#x2F;bootstrap-kubelet.kubeconfig $i:&#x2F;etc&#x2F;kubernetes&#x2F;</del><br><del>done</del></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p /var/lib/kubelet /var/log/kubernetes  /etc/kubernetes/manifests/</span><br></code></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl daemon-reload<br>systemctl enable --now kubelet<br>systemctl status kubelet<br></code></pre></td></tr></table></figure><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get node</span><br><br>No resources found<br></code></pre></td></tr></table></figure><p>失败了。。。没有任何节点</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://i4t.com/5636.html">https://i4t.com/5636.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过实践学习 Nginx</title>
    <link href="/2023/04/06/nginx-practice/"/>
    <url>/2023/04/06/nginx-practice/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx-反代"><a href="#Nginx-反代" class="headerlink" title="Nginx 反代"></a>Nginx 反代</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;flag&quot;</span><br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>        mark <span class="hljs-type">string</span><br>        ip   <span class="hljs-type">string</span><br>        port <span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        flag.StringVar(&amp;mark, <span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-string">&quot;001&quot;</span>, <span class="hljs-string">&quot;mark&quot;</span>)<br>        flag.StringVar(&amp;ip, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;ip&quot;</span>)<br>        flag.StringVar(&amp;port, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br>        flag.Parse()<br><br>        fmt.Printf(<span class="hljs-string">&quot;listen in %v:%v, mark: %v\n&quot;</span>, ip, port, mark)<br><br>        http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>                w.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;You visited %s&quot;</span>, mark)))<br>        &#125;)<br><br>        <span class="hljs-keyword">if</span> err := http.ListenAndServe(fmt.Sprintf(<span class="hljs-string">&quot;%s:%s&quot;</span>, ip, port), <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run http_server.go -m 001 -p 8081 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run http_server.go -m 002 -p 8082 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run http_server.go -m 003 -p 8083 &amp;</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">upstream</span> myapp &#123;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8081</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8082</span>;<br>        <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8083</span>;<br>    &#125;<br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8000</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br>        <br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://myapp;<br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问 localhost:8000，会随机显示 You visited 001, You visited 002, You visited 003</p><p>TODO：观察 8080 的响应头</p><h1 id="修改响应体"><a href="#修改响应体" class="headerlink" title="修改响应体"></a>修改响应体</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;encoding/json&quot;</span><br>        <span class="hljs-string">&quot;flag&quot;</span><br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>        ip   <span class="hljs-type">string</span><br>        port <span class="hljs-type">string</span><br>)<br><br><span class="hljs-keyword">type</span> Resp <span class="hljs-keyword">struct</span> &#123;<br>        HTTPCode <span class="hljs-type">string</span><br>        Code     <span class="hljs-type">string</span><br>        Msg      <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        flag.StringVar(&amp;ip, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;ip&quot;</span>)<br>        flag.StringVar(&amp;port, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br>        flag.Parse()<br><br>        fmt.Printf(<span class="hljs-string">&quot;listen in %v:%v\n&quot;</span>, ip, port)<br><br>        http.HandleFunc(<span class="hljs-string">&quot;/suc&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>                b, err := json.Marshal(&amp;Resp&#123;HTTPCode: <span class="hljs-string">&quot;200&quot;</span>, Code: <span class="hljs-string">&quot;10000&quot;</span>, Msg: <span class="hljs-string">&quot;success.&quot;</span>&#125;)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                        w.WriteHeader(http.StatusInternalServerError)<br>                        w.Write([]<span class="hljs-type">byte</span>(err.Error()))<br>                        <span class="hljs-keyword">return</span><br>                &#125;<br>                w.WriteHeader(http.StatusOK)<br>                w.Write(b)<br>        &#125;)<br><br>        http.HandleFunc(<span class="hljs-string">&quot;/err&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>                b, err := json.Marshal(&amp;Resp&#123;HTTPCode: <span class="hljs-string">&quot;500&quot;</span>, Code: <span class="hljs-string">&quot;20000&quot;</span>, Msg: <span class="hljs-string">&quot;error.&quot;</span>&#125;)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                        w.WriteHeader(http.StatusInternalServerError)<br>                        w.Write([]<span class="hljs-type">byte</span>(err.Error()))<br>                        <span class="hljs-keyword">return</span><br>                &#125;<br>                w.WriteHeader(http.StatusInternalServerError)<br>                w.Write(b)<br>        &#125;)<br><br>        <span class="hljs-keyword">if</span> err := http.ListenAndServe(fmt.Sprintf(<span class="hljs-string">&quot;%s:%s&quot;</span>, ip, port), <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br>http &#123;<br>    gzip              on;<br>    gzip_types        text/plain text/css application/json application/javascript;<br>    gzip_min_length   <span class="hljs-number">1000</span>;<br>    gzip_proxied      any;<br><br>    server &#123;<br>        listen <span class="hljs-number">80</span>;<br>        server_name example.com;<br><br>        location /api &#123;<br>            proxy_pass http:<span class="hljs-comment">//backend;</span><br>            sub_filter_types application/json;<br>            sub_filter <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>;<br>            sub_filter_last_modified on;<br>            sub_filter_once off;<br>            proxy_set_header Accept-Encoding <span class="hljs-string">&quot;&quot;</span>;<br>            proxy_set_header Connection <span class="hljs-string">&quot;&quot;</span>;<br>            proxy_http_version <span class="hljs-number">1.1</span>;<br>            proxy_set_header Host $host;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s Secret</title>
    <link href="/2022/10/10/k8s-secret/"/>
    <url>/2022/10/10/k8s-secret/</url>
    
    <content type="html"><![CDATA[<h2 id="Opaque-Secret"><a href="#Opaque-Secret" class="headerlink" title="Opaque Secret"></a>Opaque Secret</h2><p>要求 value 必须是 base64 编码的</p><h3 id="测试：如果-value-不是-base64-呢？"><a href="#测试：如果-value-不是-base64-呢？" class="headerlink" title="测试：如果 value 不是 base64 呢？"></a>测试：如果 value 不是 base64 呢？</h3><p>准备如下 yaml 用来创建 secret，其中 value 不是 base64 格式的：</p><p><strong>secret_not_base64.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">pass:</span> <span class="hljs-string">123r</span> <br></code></pre></td></tr></table></figure><p>运行并查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret_not_base64.yaml</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secret</span>                           <br>NAME                  TYPE                                  DATA   AGE<br>mysecret-not-base64   Opaque                                2      42m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get secret mysecret-not-base64 -oyaml</span><br>apiVersion: v1<br>data:<br>  pass: 123r<br>  user: root<br>kind: Secret<br>metadata:<br>  annotations:<br>    kubectl.kubernetes.io/last-applied-configuration: |<br>      &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:&#123;&quot;pass&quot;:&quot;123r&quot;,&quot;user&quot;:&quot;root&quot;&#125;,&quot;kind&quot;:&quot;Secret&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;mysecret-not-base64&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;type&quot;:&quot;Opaque&quot;&#125;<br>  creationTimestamp: &quot;2022-10-10T14:25:30Z&quot;<br>  name: mysecret-not-base64<br>  namespace: default<br>  resourceVersion: &quot;158457&quot;<br>  uid: 44ae7fda-3f7f-4da3-95b1-c3068727d765<br>type: Opaque<br></code></pre></td></tr></table></figure><p>貌似没什么影响啊？可以正常创建，也可以查看其中的值，继续测试看看</p><p>该 yaml 从名为 mysecret-not-base64 的 secret 中引用值，并将其设置为环境变量，然后会执行 env 命令查看当前系统里的所有环境变量（busybox 是一个集成了一些 linux 同样命令的镜像）</p><p><strong>secret_not_base64_pod.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-not-base64-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret1</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [ <span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;env&quot;</span> ]<br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">USERNAME</span> <span class="hljs-comment"># 设置名为 USERNAME 的环境变量，其值引用 mysecret-not-base64 中的 user 字段</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">user</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PASSWORD</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>运行并查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret_not_base64_pod.yaml</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs  secret-not-base64-pod</span>        <br>KUBERNETES_SERVICE_PORT=443<br>KUBERNETES_PORT=tcp://10.96.0.1:443<br>HOSTNAME=secret-not-base64-pod<br>SHLVL=1<br>HOME=/root<br>USERNAME=��-<br>KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>KUBERNETES_PORT_443_TCP_PORT=443<br>KUBERNETES_PORT_443_TCP_PROTO=tcp<br>KUBERNETES_SERVICE_PORT_HTTPS=443<br>KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443<br>KUBERNETES_SERVICE_HOST=10.96.0.1<br>PWD=/<br>PASSWORD=�m�<br></code></pre></td></tr></table></figure><p>发现我们设置的两个环境变量 USERNAME 和 PASSWORD 的值都显示为乱码，莫非如果引用了Opaque 类型的 secret 中的字段，会执行解码操作，将解码出来的值作为 value 进行设置吗？</p><p>为了搞清楚这个问题，我们可以再尝试做一个 value 是 base64 编码过的 secret：</p><p><strong>secret.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">YWRtaW4=</span><br>  <span class="hljs-attr">pass:</span> <span class="hljs-string">MWYyZDFlMmU2N2Rm</span><br></code></pre></td></tr></table></figure><p>tips：linux&#x2F;mac 自带了 base64 命令，可以方便的获取值的 base64:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;admin&quot;</span> | <span class="hljs-built_in">base64</span></span><br>YWRtaW4=<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;admin321&quot;</span> | <span class="hljs-built_in">base64</span></span><br>YWRtaW4zMjE=<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;YWRtaW4=&quot;</span> | <span class="hljs-built_in">base64</span> -d</span>    <br>admin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解密</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;MWYyZDFlMmU2N2Rm&quot;</span> | <span class="hljs-built_in">base64</span> -d</span><br>1f2d1e2e67df<br></code></pre></td></tr></table></figure><p><strong>secret_base64_pod.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">secret-base64-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">secret1</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [ <span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;env&quot;</span> ]<br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">USERNAME</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">user</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PASSWORD</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">secretKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span> <br>          <span class="hljs-attr">key:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret_base64_pod.yaml</span>  <br>pod/secret-base64-pod created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs secret-base64-pod</span><br>KUBERNETES_SERVICE_PORT=443<br>KUBERNETES_PORT=tcp://10.96.0.1:443<br>HOSTNAME=secret-base64-pod<br>SHLVL=1<br>HOME=/root<br>USERNAME=admin<br>KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>KUBERNETES_PORT_443_TCP_PORT=443<br>KUBERNETES_PORT_443_TCP_PROTO=tcp<br>KUBERNETES_SERVICE_PORT_HTTPS=443<br>KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443<br>KUBERNETES_SERVICE_HOST=10.96.0.1<br>PWD=/<br>PASSWORD=1f2d1e2e67df<br></code></pre></td></tr></table></figure><p>发现环境变量 USERNAME 和 PASSWORD 的值都正常显示了，看来确实是这样，当引用Opaque 类型的 secret 中的值时，会自动做 base64 解码操作</p><p>再试试用挂载的方式：</p><p>这里将 mysecret 这个 secret 下的所有条目挂载到了容器内的 &#x2F;projected-volume 目录下，mysecret 就是上面定义的 secret.yaml：</p><p><strong>secret-test-pod.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-projected-volume</span> <br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-secret-volume</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;86400&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/projected-volume&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>    <span class="hljs-attr">projected:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret</span><br></code></pre></td></tr></table></figure><p>运行并查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f secret-test-pod.yaml</span>  <br>pod/test-projected-volume created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span>                         <br>NAME                                READY   STATUS    RESTARTS   AGE<br>test-projected-volume               1/1     Running   0          7s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume -- <span class="hljs-built_in">cat</span> /projected-volume/pass</span>                              <br><span class="hljs-meta prompt_">1f2d1e2e67df% </span><span class="language-bash">                                                                                                                                                            $ kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume -- <span class="hljs-built_in">cat</span> /projected-volume/user</span><br><span class="hljs-meta prompt_">admin% </span><br></code></pre></td></tr></table></figure><p>发现这里将 secret 中的每个条目都单独做成了一个文件，并且文件内容都是已经解码过的值</p><p>再试试挂载引用之前那个 value 不是 base64 的 secret：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-projected-volume-not-base64</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test-secret-volume</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;86400&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/projected-volume&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-cred</span><br>    <span class="hljs-attr">projected:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">mysecret-not-base64</span> <span class="hljs-comment"># 修改这里</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it test-projected-volume-not-base64 -- <span class="hljs-built_in">cat</span> /projected-volume/user</span><br>??-%                                                                                                                                                                      $ kubectl exec -it test-projected-volume-not-base64 -- cat /projected-volume/pass<br>?m?% <br></code></pre></td></tr></table></figure><p>发现乱码了</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s client-go 源码阅读</title>
    <link href="/2022/10/07/client-go-yuan-ma/"/>
    <url>/2022/10/07/client-go-yuan-ma/</url>
    
    <content type="html"><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/ebb2c434fe2fdcb013512d0e6f62e9d8722bc2e3/img/K8s-informer.png"></p><p>Informers 由几个核心的组件构成：</p><ul><li>Reflector：负责从 api-server list（全量拉取数据） and watch（监听数据变更）</li><li>DeltaFIFO：一个存储事件的队列，里面记录了事件的类型</li><li>Indexer：存储数据，数据来源是从 DeltaFIFO 中 pop 出来的，然后会根据事件类型进行对应的操作</li><li>sharedProcessor：用于运行用户设置的事件回调函数，里面用 map 存储了所有的 listener，每次调用 AddEventHandler 都会创建一个 listener，同时这个函数可以调用多次，也就是创建多个 listener，当发送事件时，会调用所有的 listener 的对应回调函数</li><li>controller：上面提到的 Reflector、DeltaFIFO、Indexer 各自有各自的作用，但是它们彼此之间还没有关联起来，而 controller 就是负责这件事的，它是这 3 个组件的 master，让它们可以协同运作，大致流程是：当 Reflector watch 到事件时会将其保存到 DeltaFIFO 中，controller 这边会持续从 DeltaFIFO 中 pop 元素，然后根据事件类型对 indexer 进行相应操作（add、update、delete），使得 indexer 中的数据和 api-server 中的一致，同时还会调用 sharedProcessor 的对应回调，来完成用户设置的对应事件操作。</li></ul><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h2><p>Reflector struct 有非常多的字段，这里对其进行了截取，只保留了部分与本文相关的关键字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reflector <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// The destination to sync up with the watch source</span><br>store Store<br><span class="hljs-comment">// listerWatcher is used to perform lists and watches.</span><br>listerWatcher ListerWatcher<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="informers-x2F-factory-go"><a href="#informers-x2F-factory-go" class="headerlink" title="informers&#x2F;factory.go"></a>informers&#x2F;factory.go</h1><h2 id="types"><a href="#types" class="headerlink" title="types"></a>types</h2><h3 id="sharedInformerFactory"><a href="#sharedInformerFactory" class="headerlink" title="sharedInformerFactory"></a>sharedInformerFactory</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sharedInformerFactory <span class="hljs-keyword">struct</span> &#123;<br>   client           kubernetes.Interface<br>   namespace        <span class="hljs-type">string</span><br>   tweakListOptions internalinterfaces.TweakListOptionsFunc<br>   lock             sync.Mutex<br>   defaultResync    time.Duration<br>   customResync     <span class="hljs-keyword">map</span>[reflect.Type]time.Duration<br><br>   informers <span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer<br>   <span class="hljs-comment">// startedInformers is used for tracking which informers have been started.</span><br>   <span class="hljs-comment">// This allows Start() to be called multiple times safely.</span><br>   startedInformers <span class="hljs-keyword">map</span>[reflect.Type]<span class="hljs-type">bool</span><br>   <span class="hljs-comment">// wg tracks how many goroutines were started.</span><br>   wg sync.WaitGroup<br>   <span class="hljs-comment">// shuttingDown is true when Shutdown has been called. It may still be running</span><br>   <span class="hljs-comment">// because it needs to wait for goroutines.</span><br>   shuttingDown <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-comment">// Start initializes all requested informers.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> Start(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>  <span class="hljs-comment">// 遍历 factory 中已注册的 informer，如果该 informer 还未运行过，则运行它</span><br><span class="hljs-keyword">for</span> informerType, informer := <span class="hljs-keyword">range</span> f.informers &#123;<br><span class="hljs-keyword">if</span> !f.startedInformers[informerType] &#123;<span class="hljs-comment">// 还未运行过</span><br><span class="hljs-keyword">go</span> informer.Run(stopCh)<span class="hljs-comment">// 运行该 informer</span><br>f.startedInformers[informerType] = <span class="hljs-literal">true</span><span class="hljs-comment">// 标记为已运行</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="InformerFor"><a href="#InformerFor" class="headerlink" title="InformerFor()"></a>InformerFor()</h4><p>InformerFor 填充 sharedInformerFactory 的 informers 字段</p><p>会检查该 type 是否已经注册，如果没注册则会调用传递进来的 newFunc 回调函数进行创建，并注册到 informers 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InternalInformerFor returns the SharedIndexInformer for obj using an internal</span><br><span class="hljs-comment">// client.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer &#123;<br>   f.lock.Lock()<br>   <span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>   <span class="hljs-comment">// 使用反射获取 obj 的类型</span><br>   informerType := reflect.TypeOf(obj)<br>   <span class="hljs-comment">// 查看是否已注册过该 informerType，如果注册过则直接返回，符合了 shared 的定义 </span><br>   informer, exists := f.informers[informerType]<br>   <span class="hljs-keyword">if</span> exists &#123;<br>      <span class="hljs-keyword">return</span> informer<br>   &#125;<br><br>   resyncPeriod, exists := f.customResync[informerType]<br>   <span class="hljs-keyword">if</span> !exists &#123;<br>      resyncPeriod = f.defaultResync<br>   &#125;<br><br>  <span class="hljs-comment">// 走到这里说明 informerType 还未注册过，那么就创建一个 informer 并注册</span><br>   informer = newFunc(f.client, resyncPeriod)<br>   f.informers[informerType] = informer<br><br>   <span class="hljs-keyword">return</span> informer<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>比如有一个 podInformer，它有一个 Informer 方法，该方法会调用 InformerFor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *podInformer)</span></span> Informer() cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> f.factory.InformerFor(&amp;corev1.Pod&#123;&#125;, f.defaultInformer)<br>&#125;<br></code></pre></td></tr></table></figure><p>它传递的回调函数是 f.defaultInformer，该函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *podInformer)</span></span> defaultInformer(client kubernetes.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> NewFilteredPodInformer(client, f.namespace, resyncPeriod, cache.Indexers&#123;cache.NamespaceIndex: cache.MetaNamespaceIndexFunc&#125;, f.tweakListOptions)<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数又调用了 NewFilteredPodInformer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewFilteredPodInformer constructs a new informer for Pod type.</span><br><span class="hljs-comment">// Always prefer using an informer factory to get a shared informer instead of getting an independent</span><br><span class="hljs-comment">// one. This reduces memory footprint and number of connections to the server.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFilteredPodInformer</span><span class="hljs-params">(client kubernetes.Interface, namespace <span class="hljs-type">string</span>, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc)</span></span> cache.SharedIndexInformer &#123;<br><span class="hljs-keyword">return</span> cache.NewSharedIndexInformer(<br>&amp;cache.ListWatch&#123;<br>ListFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> tweakListOptions != <span class="hljs-literal">nil</span> &#123;<br>tweakListOptions(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> client.CoreV1().Pods(namespace).List(context.TODO(), options)<br>&#125;,<br>WatchFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options metav1.ListOptions)</span></span> (watch.Interface, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> tweakListOptions != <span class="hljs-literal">nil</span> &#123;<br>tweakListOptions(&amp;options)<br>&#125;<br><span class="hljs-keyword">return</span> client.CoreV1().Pods(namespace).Watch(context.TODO(), options)<br>&#125;,<br>&#125;,<br>&amp;corev1.Pod&#123;&#125;,<br>resyncPeriod,<br>indexers,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数又调用了 NewSharedIndexInformer ，最终会创建出一个 SharedIndexInformer，该函数定义在 tools&#x2F;cache&#x2F;shared_informer.go</p><h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><h3 id="NewSharedInformerFactory"><a href="#NewSharedInformerFactory" class="headerlink" title="NewSharedInformerFactory"></a>NewSharedInformerFactory</h3><p>实际调用的是 NewSharedInformerFactoryWithOptions</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSharedInformerFactory</span><span class="hljs-params">(client kubernetes.Interface, defaultResync time.Duration)</span></span> SharedInformerFactory &#123;<br>   <span class="hljs-keyword">return</span> NewSharedInformerFactoryWithOptions(client, defaultResync)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NewSharedInformerFactoryWithOptions"><a href="#NewSharedInformerFactoryWithOptions" class="headerlink" title="NewSharedInformerFactoryWithOptions"></a>NewSharedInformerFactoryWithOptions</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSharedInformerFactoryWithOptions</span><span class="hljs-params">(client kubernetes.Interface, defaultResync time.Duration, options ...SharedInformerOption)</span></span> SharedInformerFactory &#123;<br>   factory := &amp;sharedInformerFactory&#123;<br>      client:           client,<br>      namespace:        v1.NamespaceAll,<br>      defaultResync:    defaultResync,<br>      informers:        <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer),<br>      startedInformers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]<span class="hljs-type">bool</span>),<br>      customResync:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[reflect.Type]time.Duration),<br>   &#125;<br><br>   <span class="hljs-comment">// Apply all options</span><br>   <span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> options &#123;<br>      factory = opt(factory)<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> factory<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tools-x2F-cache-x2F-shared-informer-go"><a href="#tools-x2F-cache-x2F-shared-informer-go" class="headerlink" title="tools&#x2F;cache&#x2F;shared_informer.go"></a>tools&#x2F;cache&#x2F;shared_informer.go</h1><h2 id="types-1"><a href="#types-1" class="headerlink" title="types"></a>types</h2><h3 id="sharedIndexInformer"><a href="#sharedIndexInformer" class="headerlink" title="sharedIndexInformer"></a>sharedIndexInformer</h3><p>sharedIndexInformer 结构体，里面的几个核心属性是用来 list-watch 的 <code>listerWatcher</code>，负责存储的 <code>indexer</code>，负责执行整套流程的的 controller（从 reflector 中 list-watch，从 DefltaFIFO 中 pop 并更新 indexer），负责执行用户设置的 eventHandle 的 processor</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// `*sharedIndexInformer` implements SharedIndexInformer and has three</span><br><span class="hljs-comment">// main components.  One is an indexed local cache, `indexer Indexer`.</span><br><span class="hljs-comment">// The second main component is a Controller that pulls</span><br><span class="hljs-comment">// objects/notifications using the ListerWatcher and pushes them into</span><br><span class="hljs-comment">// a DeltaFIFO --- whose knownObjects is the informer&#x27;s local cache</span><br><span class="hljs-comment">// --- while concurrently Popping Deltas values from that fifo and</span><br><span class="hljs-comment">// processing them with `sharedIndexInformer::HandleDeltas`.  Each</span><br><span class="hljs-comment">// invocation of HandleDeltas, which is done with the fifo&#x27;s lock</span><br><span class="hljs-comment">// held, processes each Delta in turn.  For each Delta this both</span><br><span class="hljs-comment">// updates the local cache and stuffs the relevant notification into</span><br><span class="hljs-comment">// the sharedProcessor.  The third main component is that</span><br><span class="hljs-comment">// sharedProcessor, which is responsible for relaying those</span><br><span class="hljs-comment">// notifications to each of the informer&#x27;s clients.</span><br><span class="hljs-keyword">type</span> sharedIndexInformer <span class="hljs-keyword">struct</span> &#123;<br>   indexer    Indexer<br>   controller Controller<br><br>   processor             *sharedProcessor<br>   cacheMutationDetector MutationDetector<br><br>   listerWatcher ListerWatcher<br><br>   <span class="hljs-comment">// objectType is an example object of the type this informer is</span><br>   <span class="hljs-comment">// expected to handle.  Only the type needs to be right, except</span><br>   <span class="hljs-comment">// that when that is `unstructured.Unstructured` the object&#x27;s</span><br>   <span class="hljs-comment">// `&quot;apiVersion&quot;` and `&quot;kind&quot;` must also be right.</span><br>   objectType runtime.Object<br><br>   <span class="hljs-comment">// resyncCheckPeriod is how often we want the reflector&#x27;s resync timer to fire so it can call</span><br>   <span class="hljs-comment">// shouldResync to check if any of our listeners need a resync.</span><br>   resyncCheckPeriod time.Duration<br>   <span class="hljs-comment">// defaultEventHandlerResyncPeriod is the default resync period for any handlers added via</span><br>   <span class="hljs-comment">// AddEventHandler (i.e. they don&#x27;t specify one and just want to use the shared informer&#x27;s default</span><br>   <span class="hljs-comment">// value).</span><br>   defaultEventHandlerResyncPeriod time.Duration<br>   <span class="hljs-comment">// clock allows for testability</span><br>   clock clock.Clock<br><br>   started, stopped <span class="hljs-type">bool</span><br>   startedLock      sync.Mutex<br><br>   <span class="hljs-comment">// blockDeltas gives a way to stop all event distribution so that a late event handler</span><br>   <span class="hljs-comment">// can safely join the shared informer.</span><br>   blockDeltas sync.Mutex<br><br>   <span class="hljs-comment">// Called whenever the ListAndWatch drops the connection with an error.</span><br>   watchErrorHandler WatchErrorHandler<br><br>   transform TransformFunc<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Run"><a href="#Run" class="headerlink" title="Run()"></a>Run()</h4><p>Run 会调用 s.controller.Run</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>   <span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><br>   <span class="hljs-keyword">if</span> s.HasStarted() &#123;<br>      klog.Warningf(<span class="hljs-string">&quot;The sharedIndexInformer has started, run more than once is not allowed&quot;</span>)<br>      <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">// 创建一个 DeltaFIFO</span><br>   fifo := NewDeltaFIFOWithOptions(DeltaFIFOOptions&#123;<br>      KnownObjects:          s.indexer,<br>      EmitDeltaTypeReplaced: <span class="hljs-literal">true</span>,<br>   &#125;)<br><br>  <span class="hljs-comment">// 配置用来创建 controller 的 Config</span><br>   cfg := &amp;Config&#123;<br>      Queue:            fifo, <span class="hljs-comment">// 设置为 DeltaFIFO</span><br>      ListerWatcher:    s.listerWatcher,<br>      ObjectType:       s.objectType,<br>      FullResyncPeriod: s.resyncCheckPeriod,<br>      RetryOnError:     <span class="hljs-literal">false</span>,<br>      ShouldResync:     s.processor.shouldResync,<br><br>      Process:           s.HandleDeltas,<br>      WatchErrorHandler: s.watchErrorHandler,<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      s.startedLock.Lock()<br>      <span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br><br>     <span class="hljs-comment">// 创建 controller</span><br>      s.controller = New(cfg)<br>      s.controller.(*controller).clock = s.clock<br>      s.started = <span class="hljs-literal">true</span><br>   &#125;()<br><br>   <span class="hljs-comment">// Separate stop channel because Processor should be stopped strictly after controller</span><br>   processorStopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>   <span class="hljs-keyword">var</span> wg wait.Group<br>   <span class="hljs-keyword">defer</span> wg.Wait()              <span class="hljs-comment">// Wait for Processor to stop</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(processorStopCh) <span class="hljs-comment">// Tell Processor to stop</span><br>   wg.StartWithChannel(processorStopCh, s.cacheMutationDetector.Run)<br>   wg.StartWithChannel(processorStopCh, s.processor.run)<br><br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      s.startedLock.Lock()<br>      <span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br>      s.stopped = <span class="hljs-literal">true</span> <span class="hljs-comment">// Don&#x27;t want any new listeners</span><br>   &#125;()<br>   <span class="hljs-comment">// 运行 controller</span><br>   s.controller.Run(stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HandleDeltas"><a href="#HandleDeltas" class="headerlink" title="HandleDeltas()"></a>HandleDeltas()</h4><p>对 DeltaFIFO 中 pop 出的元素进行处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> HandleDeltas(obj <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>s.blockDeltas.Lock()<br><span class="hljs-keyword">defer</span> s.blockDeltas.Unlock()<br><br><span class="hljs-keyword">if</span> deltas, ok := obj.(Deltas); ok &#123;<br>    <span class="hljs-comment">// 又调用了 processDeltas，其中第二个参数传递的是 indexer</span><br><span class="hljs-keyword">return</span> processDeltas(s, s.indexer, s.transform, deltas)<br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;object given as Process argument is not Deltas&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AddEventHandler"><a href="#AddEventHandler" class="headerlink" title="AddEventHandler()"></a>AddEventHandler()</h4><p>添加事件处理函数，但发生事件时（add，update，delete）会调用对应的回调函数，实际调用的是AddEventHandlerWithResyncPeriod，该函数可以调用多次（也就是 add 多个 EventHandler），每次都会创建一个 listener，当发生事件时，会一并通知所有的 listener</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> AddEventHandler(handler ResourceEventHandler) (ResourceEventHandlerRegistration, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> s.AddEventHandlerWithResyncPeriod(handler, s.defaultEventHandlerResyncPeriod)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AddEventHandlerWithResyncPeriod"><a href="#AddEventHandlerWithResyncPeriod" class="headerlink" title="AddEventHandlerWithResyncPeriod()"></a>AddEventHandlerWithResyncPeriod()</h4><p>该函数会创建一个 listener</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) (ResourceEventHandlerRegistration, <span class="hljs-type">error</span>) &#123;<br>s.startedLock.Lock()<br><span class="hljs-keyword">defer</span> s.startedLock.Unlock()<br><br><span class="hljs-keyword">if</span> s.stopped &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;handler %v was not added to shared informer because it has stopped already&quot;</span>, handler)<br>&#125;<br><br><span class="hljs-keyword">if</span> resyncPeriod &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> resyncPeriod &lt; minimumResyncPeriod &#123;<br>klog.Warningf(<span class="hljs-string">&quot;resyncPeriod %v is too small. Changing it to the minimum allowed value of %v&quot;</span>, resyncPeriod, minimumResyncPeriod)<br>resyncPeriod = minimumResyncPeriod<br>&#125;<br><br><span class="hljs-keyword">if</span> resyncPeriod &lt; s.resyncCheckPeriod &#123;<br><span class="hljs-keyword">if</span> s.started &#123;<br>klog.Warningf(<span class="hljs-string">&quot;resyncPeriod %v is smaller than resyncCheckPeriod %v and the informer has already started. Changing it to %v&quot;</span>, resyncPeriod, s.resyncCheckPeriod, s.resyncCheckPeriod)<br>resyncPeriod = s.resyncCheckPeriod<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// if the event handler&#x27;s resyncPeriod is smaller than the current resyncCheckPeriod, update</span><br><span class="hljs-comment">// resyncCheckPeriod to match resyncPeriod and adjust the resync periods of all the listeners</span><br><span class="hljs-comment">// accordingly</span><br>s.resyncCheckPeriod = resyncPeriod<br>s.processor.resyncCheckPeriodChanged(resyncPeriod)<br>&#125;<br>&#125;<br>&#125;<br><br>  <span class="hljs-comment">// 创建一个 listener</span><br>listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now(), initialBufferSize)<br><br><span class="hljs-keyword">if</span> !s.started &#123;<br><span class="hljs-keyword">return</span> s.processor.addListener(listener), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// in order to safely join, we have to</span><br><span class="hljs-comment">// 1. stop sending add/update/delete notifications</span><br><span class="hljs-comment">// 2. do a list against the store</span><br><span class="hljs-comment">// 3. send synthetic &quot;Add&quot; events to the new handler</span><br><span class="hljs-comment">// 4. unblock</span><br>s.blockDeltas.Lock()<br><span class="hljs-keyword">defer</span> s.blockDeltas.Unlock()<br><br>  <span class="hljs-comment">// 将 listener 添加到 s.processor</span><br>handle := s.processor.addListener(listener)<br>  <span class="hljs-comment">// 遍历当前 indexer 里的所有数据，对所有的 listener 进行通知</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> s.indexer.List() &#123;<br>listener.add(addNotification&#123;newObj: item&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> handle, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OnAdd"><a href="#OnAdd" class="headerlink" title="OnAdd()"></a>OnAdd()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Conforms to ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> OnAdd(obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// Invocation of this function is locked under s.blockDeltas, so it is</span><br><span class="hljs-comment">// save to distribute the notification</span><br>s.cacheMutationDetector.AddObject(obj)<br>s.processor.distribute(addNotification&#123;newObj: obj&#125;, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OnUpdate"><a href="#OnUpdate" class="headerlink" title="OnUpdate()"></a>OnUpdate()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Conforms to ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> OnUpdate(old, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>isSync := <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// If is a Sync event, isSync should be true</span><br><span class="hljs-comment">// If is a Replaced event, isSync is true if resource version is unchanged.</span><br><span class="hljs-comment">// If RV is unchanged: this is a Sync/Replaced event, so isSync is true</span><br><br><span class="hljs-keyword">if</span> accessor, err := meta.Accessor(<span class="hljs-built_in">new</span>); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> oldAccessor, err := meta.Accessor(old); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Events that didn&#x27;t change resourceVersion are treated as resync events</span><br><span class="hljs-comment">// and only propagated to listeners that requested resync</span><br>isSync = accessor.GetResourceVersion() == oldAccessor.GetResourceVersion()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Invocation of this function is locked under s.blockDeltas, so it is</span><br><span class="hljs-comment">// save to distribute the notification</span><br>s.cacheMutationDetector.AddObject(<span class="hljs-built_in">new</span>)<br>s.processor.distribute(updateNotification&#123;oldObj: old, newObj: <span class="hljs-built_in">new</span>&#125;, isSync)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="OnDelete"><a href="#OnDelete" class="headerlink" title="OnDelete()"></a>OnDelete()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Conforms to ResourceEventHandler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *sharedIndexInformer)</span></span> OnDelete(old <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-comment">// Invocation of this function is locked under s.blockDeltas, so it is</span><br><span class="hljs-comment">// save to distribute the notification</span><br>s.processor.distribute(deleteNotification&#123;oldObj: old&#125;, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sharedProcessor"><a href="#sharedProcessor" class="headerlink" title="sharedProcessor"></a>sharedProcessor</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// sharedProcessor has a collection of processorListener and can</span><br><span class="hljs-comment">// distribute a notification object to its listeners.  There are two</span><br><span class="hljs-comment">// kinds of distribute operations.  The sync distributions go to a</span><br><span class="hljs-comment">// subset of the listeners that (a) is recomputed in the occasional</span><br><span class="hljs-comment">// calls to shouldResync and (b) every listener is initially put in.</span><br><span class="hljs-comment">// The non-sync distributions go to every listener.</span><br><span class="hljs-keyword">type</span> sharedProcessor <span class="hljs-keyword">struct</span> &#123;<br>listenersStarted <span class="hljs-type">bool</span><br>listenersLock    sync.RWMutex<br><span class="hljs-comment">// Map from listeners to whether or not they are currently syncing</span><br>listeners <span class="hljs-keyword">map</span>[*processorListener]<span class="hljs-type">bool</span><br>clock     clock.Clock<br>wg        wait.Group<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="addListener"><a href="#addListener" class="headerlink" title="addListener()"></a>addListener()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sharedProcessor)</span></span> addListener(listener *processorListener) &#123;<br>p.listenersLock.Lock()<br><span class="hljs-keyword">defer</span> p.listenersLock.Unlock()<br><br>p.addListenerLocked(listener)<br><span class="hljs-keyword">if</span> p.listenersStarted &#123;<br>p.wg.Start(listener.run)<br>p.wg.Start(listener.pop)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="distribute"><a href="#distribute" class="headerlink" title="distribute()"></a>distribute()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sharedProcessor)</span></span> distribute(obj <span class="hljs-keyword">interface</span>&#123;&#125;, sync <span class="hljs-type">bool</span>) &#123;<br>p.listenersLock.RLock()<br><span class="hljs-keyword">defer</span> p.listenersLock.RUnlock()<br><br><span class="hljs-keyword">for</span> listener, isSyncing := <span class="hljs-keyword">range</span> p.listeners &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> !sync:<br><span class="hljs-comment">// non-sync messages are delivered to every listener</span><br>listener.add(obj)<br><span class="hljs-keyword">case</span> isSyncing:<br><span class="hljs-comment">// sync messages are delivered to every syncing listener</span><br>listener.add(obj)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// skipping a sync obj for a non-syncing listener</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="processorListener"><a href="#processorListener" class="headerlink" title="processorListener"></a>processorListener</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processorListener relays notifications from a sharedProcessor to</span><br><span class="hljs-comment">// one ResourceEventHandler --- using two goroutines, two unbuffered</span><br><span class="hljs-comment">// channels, and an unbounded ring buffer.  The `add(notification)`</span><br><span class="hljs-comment">// function sends the given notification to `addCh`.  One goroutine</span><br><span class="hljs-comment">// runs `pop()`, which pumps notifications from `addCh` to `nextCh`</span><br><span class="hljs-comment">// using storage in the ring buffer while `nextCh` is not keeping up.</span><br><span class="hljs-comment">// Another goroutine runs `run()`, which receives notifications from</span><br><span class="hljs-comment">// `nextCh` and synchronously invokes the appropriate handler method.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// processorListener also keeps track of the adjusted requested resync</span><br><span class="hljs-comment">// period of the listener.</span><br><span class="hljs-keyword">type</span> processorListener <span class="hljs-keyword">struct</span> &#123;<br>nextCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br>addCh  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>handler ResourceEventHandler<br><br><span class="hljs-comment">// pendingNotifications is an unbounded ring buffer that holds all notifications not yet distributed.</span><br><span class="hljs-comment">// There is one per listener, but a failing/stalled listener will have infinite pendingNotifications</span><br><span class="hljs-comment">// added until we OOM.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is no worse than before, since reflectors were backed by unbounded DeltaFIFOs, but</span><br><span class="hljs-comment">// we should try to do something better.</span><br>pendingNotifications buffer.RingGrowing<br><br><span class="hljs-comment">// requestedResyncPeriod is how frequently the listener wants a</span><br><span class="hljs-comment">// full resync from the shared informer, but modified by two</span><br><span class="hljs-comment">// adjustments.  One is imposing a lower bound,</span><br><span class="hljs-comment">// `minimumResyncPeriod`.  The other is another lower bound, the</span><br><span class="hljs-comment">// sharedIndexInformer&#x27;s `resyncCheckPeriod`, that is imposed (a) only</span><br><span class="hljs-comment">// in AddEventHandlerWithResyncPeriod invocations made after the</span><br><span class="hljs-comment">// sharedIndexInformer starts and (b) only if the informer does</span><br><span class="hljs-comment">// resyncs at all.</span><br>requestedResyncPeriod time.Duration<br><span class="hljs-comment">// resyncPeriod is the threshold that will be used in the logic</span><br><span class="hljs-comment">// for this listener.  This value differs from</span><br><span class="hljs-comment">// requestedResyncPeriod only when the sharedIndexInformer does</span><br><span class="hljs-comment">// not do resyncs, in which case the value here is zero.  The</span><br><span class="hljs-comment">// actual time between resyncs depends on when the</span><br><span class="hljs-comment">// sharedProcessor&#x27;s `shouldResync` function is invoked and when</span><br><span class="hljs-comment">// the sharedIndexInformer processes `Sync` type Delta objects.</span><br>resyncPeriod time.Duration<br><span class="hljs-comment">// nextResync is the earliest time the listener should get a full resync</span><br>nextResync time.Time<br><span class="hljs-comment">// resyncLock guards access to resyncPeriod and nextResync</span><br>resyncLock sync.Mutex<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="newProcessListener"><a href="#newProcessListener" class="headerlink" title="newProcessListener()"></a>newProcessListener()</h4><p>该函数在 sharedIndexInformer.AddEventHandlerWithResyncPeriod 中调用，创建一个新的 listener</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newProcessListener</span><span class="hljs-params">(handler ResourceEventHandler, requestedResyncPeriod, resyncPeriod time.Duration, now time.Time, bufferSize <span class="hljs-type">int</span>)</span></span> *processorListener &#123;<br>ret := &amp;processorListener&#123;<br>nextCh:                <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;),<br>addCh:                 <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;),<br>handler:               handler,<br>pendingNotifications:  *buffer.NewRingGrowing(bufferSize),<br>requestedResyncPeriod: requestedResyncPeriod,<br>resyncPeriod:          resyncPeriod,<br>&#125;<br><br>ret.determineNextResync(now)<br><br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="functions-1"><a href="#functions-1" class="headerlink" title="functions"></a>functions</h2><h3 id="NewSharedIndexInformer"><a href="#NewSharedIndexInformer" class="headerlink" title="NewSharedIndexInformer"></a>NewSharedIndexInformer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewSharedIndexInformer creates a new instance for the listwatcher.</span><br><span class="hljs-comment">// The created informer will not do resyncs if the given</span><br><span class="hljs-comment">// defaultEventHandlerResyncPeriod is zero.  Otherwise: for each</span><br><span class="hljs-comment">// handler that with a non-zero requested resync period, whether added</span><br><span class="hljs-comment">// before or after the informer starts, the nominal resync period is</span><br><span class="hljs-comment">// the requested resync period rounded up to a multiple of the</span><br><span class="hljs-comment">// informer&#x27;s resync checking period.  Such an informer&#x27;s resync</span><br><span class="hljs-comment">// checking period is established when the informer starts running,</span><br><span class="hljs-comment">// and is the maximum of (a) the minimum of the resync periods</span><br><span class="hljs-comment">// requested before the informer starts and the</span><br><span class="hljs-comment">// defaultEventHandlerResyncPeriod given here and (b) the constant</span><br><span class="hljs-comment">// `minimumResyncPeriod` defined in this file.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSharedIndexInformer</span><span class="hljs-params">(lw ListerWatcher, exampleObject runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers)</span></span> SharedIndexInformer &#123;<br>realClock := &amp;clock.RealClock&#123;&#125;<br>sharedIndexInformer := &amp;sharedIndexInformer&#123;<br>processor:                       &amp;sharedProcessor&#123;clock: realClock&#125;,<br>indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),<br>listerWatcher:                   lw,<br>objectType:                      exampleObject,<br>resyncCheckPeriod:               defaultEventHandlerResyncPeriod,<br>defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,<br>cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf(<span class="hljs-string">&quot;%T&quot;</span>, exampleObject)),<br>clock:                           realClock,<br>&#125;<br><span class="hljs-keyword">return</span> sharedIndexInformer<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tools-x2F-cache-x2F-controller-go"><a href="#tools-x2F-cache-x2F-controller-go" class="headerlink" title="tools&#x2F;cache&#x2F;controller.go"></a>tools&#x2F;cache&#x2F;controller.go</h1><h2 id="types-2"><a href="#types-2" class="headerlink" title="types"></a>types</h2><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// `*controller` implements Controller</span><br><span class="hljs-keyword">type</span> controller <span class="hljs-keyword">struct</span> &#123;<br>config         Config<br>reflector      *Reflector<br>reflectorMutex sync.RWMutex<br>clock          clock.Clock<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="processLoop"><a href="#processLoop" class="headerlink" title="processLoop()"></a>processLoop()</h4><p>processLoop 会不断从 DeltaFIFO 中 pop 出元素，并调用 c.config.Process 对 pop 出的元素进行处理，这个 Process 实际是 HandleDeltas</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processLoop drains the work queue.</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider doing the processing in parallel. This will require a little thought</span><br><span class="hljs-comment">// to make sure that we don&#x27;t end up processing the same object multiple times</span><br><span class="hljs-comment">// concurrently.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Plumb through the stopCh here (and down to the queue) so that this can</span><br><span class="hljs-comment">// actually exit when the controller is stopped. Or just give up on this stuff</span><br><span class="hljs-comment">// ever being stoppable. Converting this whole package to use Context would</span><br><span class="hljs-comment">// also be helpful.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> processLoop() &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>      obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         <span class="hljs-keyword">if</span> err == ErrFIFOClosed &#123;<br>            <span class="hljs-keyword">return</span><br>         &#125;<br>         <span class="hljs-keyword">if</span> c.config.RetryOnError &#123;<br>            <span class="hljs-comment">// This is the safe way to re-enqueue.</span><br>            c.config.Queue.AddIfNotPresent(obj)<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Run-1"><a href="#Run-1" class="headerlink" title="Run()"></a>Run()</h4><p>sharedIndexInformer.Run 里会创建一个 DeltaFIFO，并将 config.Queue 设置为这个 DeltaFIFO</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Run begins processing items, and will continue until a value is sent down stopCh or it is closed.</span><br><span class="hljs-comment">// It&#x27;s an error to call Run more than once.</span><br><span class="hljs-comment">// Run blocks; call via go.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">defer</span> utilruntime.HandleCrash()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-stopCh<br>c.config.Queue.Close()<br>&#125;()<br>  <br><span class="hljs-comment">// 创建一个 reflector 用来 list-watch</span><br>  <span class="hljs-comment">// 这里的 c.config.Queue 实际是一个 DeltaFIFO</span><br>r := NewReflector(<br>c.config.ListerWatcher,<br>c.config.ObjectType,<br>c.config.Queue,<br>c.config.FullResyncPeriod,<br>)<br>r.ShouldResync = c.config.ShouldResync<br>r.WatchListPageSize = c.config.WatchListPageSize<br>r.clock = c.clock<br><span class="hljs-keyword">if</span> c.config.WatchErrorHandler != <span class="hljs-literal">nil</span> &#123;<br>r.watchErrorHandler = c.config.WatchErrorHandler<br>&#125;<br><br>c.reflectorMutex.Lock()<br>c.reflector = r<br>c.reflectorMutex.Unlock()<br><br><span class="hljs-keyword">var</span> wg wait.Group<br><br>wg.StartWithChannel(stopCh, r.Run)<br><br>wait.Until(c.processLoop, time.Second, stopCh)<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>   <span class="hljs-comment">// The queue for your objects - has to be a DeltaFIFO due to</span><br>   <span class="hljs-comment">// assumptions in the implementation. Your Process() function</span><br>   <span class="hljs-comment">// should accept the output of this Queue&#x27;s Pop() method.</span><br>   <span class="hljs-comment">// 应该传递一个 DeltaFIFO 类型的 queue，Process() 中会从该 queue</span><br>   <span class="hljs-comment">// 中 pop 元素进行处理</span><br>   Queue<br><br>   <span class="hljs-comment">// Something that can list and watch your objects.</span><br>   ListerWatcher<br><br>   <span class="hljs-comment">// Something that can process a popped Deltas.</span><br>   <span class="hljs-comment">// Pop 出来的 obj 处理函数</span><br>   Process ProcessFunc<br><br>   <span class="hljs-comment">// ObjectType is an example object of the type this controller is</span><br>   <span class="hljs-comment">// expected to handle.  Only the type needs to be right, except</span><br>   <span class="hljs-comment">// that when that is `unstructured.Unstructured` the object&#x27;s</span><br>   <span class="hljs-comment">// `&quot;apiVersion&quot;` and `&quot;kind&quot;` must also be right.</span><br>   ObjectType runtime.Object<br><br>   <span class="hljs-comment">// FullResyncPeriod is the period at which ShouldResync is considered.</span><br>   FullResyncPeriod time.Duration<br><br>   <span class="hljs-comment">// ShouldResync is periodically used by the reflector to determine</span><br>   <span class="hljs-comment">// whether to Resync the Queue. If ShouldResync is `nil` or</span><br>   <span class="hljs-comment">// returns true, it means the reflector should proceed with the</span><br>   <span class="hljs-comment">// resync.</span><br>   ShouldResync ShouldResyncFunc<br><br>   <span class="hljs-comment">// If true, when Process() returns an error, re-enqueue the object.</span><br>   <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add interface to let you inject a delay/backoff or drop</span><br>   <span class="hljs-comment">//       the object completely if desired. Pass the object in</span><br>   <span class="hljs-comment">//       question to this interface as a parameter.  This is probably moot</span><br>   <span class="hljs-comment">//       now that this functionality appears at a higher level.</span><br>   RetryOnError <span class="hljs-type">bool</span><br><br>   <span class="hljs-comment">// Called whenever the ListAndWatch drops the connection with an error.</span><br>   WatchErrorHandler WatchErrorHandler<br><br>   <span class="hljs-comment">// WatchListPageSize is the requested chunk size of initial and relist watch lists.</span><br>   WatchListPageSize <span class="hljs-type">int64</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ProcessFunc"><a href="#ProcessFunc" class="headerlink" title="ProcessFunc"></a>ProcessFunc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ProcessFunc processes a single object.</span><br><span class="hljs-keyword">type</span> ProcessFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><h2 id="functions-2"><a href="#functions-2" class="headerlink" title="functions"></a>functions</h2><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New makes a new Controller from the given Config.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(c *Config)</span></span> Controller &#123;<br>   ctlr := &amp;controller&#123;<br>      config: *c,<br>      clock:  &amp;clock.RealClock&#123;&#125;,<br>   &#125;<br>   <span class="hljs-keyword">return</span> ctlr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="processDeltas"><a href="#processDeltas" class="headerlink" title="processDeltas"></a>processDeltas</h3><p>如果是 HandleDeltas 调用该函数，那么第二个参数传递的是 indexer，那么这里就会根据 pop 的事件类型对 indexer 进行相应操作，同时还传递了一个 handler 参数，这是一个接口类型，需要实现 OnAdd、OnUpdate、OnDelete 三个方法，sharedIndexInformer 实现了这个接口，实际会调用 sharedProcessor 的 OnAdd 等方法，这些方法是用户自己设置的回调函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Multiplexes updates in the form of a list of Deltas into a Store, and informs</span><br><span class="hljs-comment">// a given handler of events OnUpdate, OnAdd, OnDelete</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processDeltas</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">// Object which receives event notifications from the given deltas</span></span><br><span class="hljs-params"><span class="hljs-function">handler ResourceEventHandler,</span></span><br><span class="hljs-params"><span class="hljs-function">clientState Store,</span></span><br><span class="hljs-params"><span class="hljs-function">transformer TransformFunc,</span></span><br><span class="hljs-params"><span class="hljs-function">deltas Deltas,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// from oldest to newest</span><br><span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> deltas &#123;<br>obj := d.Object<br><span class="hljs-keyword">if</span> transformer != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>obj, err = transformer(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">switch</span> d.Type &#123;<br><span class="hljs-keyword">case</span> Sync, Replaced, Added, Updated:<br><span class="hljs-keyword">if</span> old, exists, err := clientState.Get(obj); err == <span class="hljs-literal">nil</span> &amp;&amp; exists &#123;<br>        <span class="hljs-comment">// 更新 indexer 里的数据</span><br><span class="hljs-keyword">if</span> err := clientState.Update(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>        <span class="hljs-comment">// 同时执行用户设置的回调函数</span><br>handler.OnUpdate(old, obj)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> err := clientState.Add(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>handler.OnAdd(obj)<br>&#125;<br><span class="hljs-keyword">case</span> Deleted:<br><span class="hljs-keyword">if</span> err := clientState.Delete(obj); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>handler.OnDelete(obj)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="tools-x2F-cache-x2F-reflector-go"><a href="#tools-x2F-cache-x2F-reflector-go" class="headerlink" title="tools&#x2F;cache&#x2F;reflector.go"></a>tools&#x2F;cache&#x2F;reflector.go</h1><h2 id="types-3"><a href="#types-3" class="headerlink" title="types"></a>types</h2><h2 id="functions-3"><a href="#functions-3" class="headerlink" title="functions"></a>functions</h2><h3 id="watchHandler"><a href="#watchHandler" class="headerlink" title="watchHandler"></a>watchHandler</h3><p>当 watch 到有事件产生时，会执行该函数对事件进行相应的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// watchHandler watches w and sets setLastSyncResourceVersion</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">watchHandler</span><span class="hljs-params">(start time.Time,</span></span><br><span class="hljs-params"><span class="hljs-function">   w watch.Interface,</span></span><br><span class="hljs-params"><span class="hljs-function">   store Store,</span></span><br><span class="hljs-params"><span class="hljs-function"> // 省略其他参数...</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> <span class="hljs-type">error</span> &#123;<br>  eventCount := <span class="hljs-number">0</span><br><br><span class="hljs-comment">// Stopping the watcher should be idempotent and if we return from this function there&#x27;s no way</span><br><span class="hljs-comment">// we&#x27;re coming back in with the same watch interface.</span><br><span class="hljs-keyword">defer</span> w.Stop()<br><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// 省略...</span><br>    <span class="hljs-comment">// 有事件产生了  </span><br><span class="hljs-keyword">case</span> event, ok := &lt;-w.ResultChan():<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br><span class="hljs-keyword">if</span> event.Type == watch.Error &#123;<br><span class="hljs-keyword">return</span> apierrors.FromObject(event.Object)<br>&#125;<br><span class="hljs-comment">// 省略...</span><br>      <span class="hljs-comment">// 判断事件类型，进行相应的处理</span><br><span class="hljs-keyword">switch</span> event.Type &#123;<br><span class="hljs-keyword">case</span> watch.Added:<br>        <span class="hljs-comment">// 这里的 store 实际是 DeltaFIFO，调用的是 DeltaFIFO.Add()</span><br>err := store.Add(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to add watch event object (%#v) to store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Modified:<br>err := store.Update(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to update watch event object (%#v) to store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Deleted:<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Will any consumers need access to the &quot;last known</span><br><span class="hljs-comment">// state&quot;, which is passed in event.Object? If so, may need</span><br><span class="hljs-comment">// to change this.</span><br>err := store.Delete(event.Object)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to delete watch event object (%#v) from store: %v&quot;</span>, name, event.Object, err))<br>&#125;<br><span class="hljs-keyword">case</span> watch.Bookmark:<br><span class="hljs-comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span><br><span class="hljs-keyword">default</span>:<br>utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, name, event))<br>&#125;<br>setLastSyncResourceVersion(resourceVersion)<br><span class="hljs-keyword">if</span> rvu, ok := store.(ResourceVersionUpdater); ok &#123;<br>rvu.UpdateResourceVersion(resourceVersion)<br>&#125;<br>eventCount++<br>&#125;<br>&#125;<br>  <span class="hljs-comment">// 省略...</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="tools-x2F-cache-x2F-delta-fifo-go"><a href="#tools-x2F-cache-x2F-delta-fifo-go" class="headerlink" title="tools&#x2F;cache&#x2F;delta_fifo.go"></a>tools&#x2F;cache&#x2F;delta_fifo.go</h1><h2 id="types-4"><a href="#types-4" class="headerlink" title="types"></a>types</h2><h3 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// DeltaFIFO is like FIFO, but differs in two ways.  One is that the</span><br><span class="hljs-comment">// accumulator associated with a given object&#x27;s key is not that object</span><br><span class="hljs-comment">// but rather a Deltas, which is a slice of Delta values for that</span><br><span class="hljs-comment">// object.  Applying an object to a Deltas means to append a Delta</span><br><span class="hljs-comment">// except when the potentially appended Delta is a Deleted and the</span><br><span class="hljs-comment">// Deltas already ends with a Deleted.  In that case the Deltas does</span><br><span class="hljs-comment">// not grow, although the terminal Deleted will be replaced by the new</span><br><span class="hljs-comment">// Deleted if the older Deleted&#x27;s object is a</span><br><span class="hljs-comment">// DeletedFinalStateUnknown.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The other difference is that DeltaFIFO has two additional ways that</span><br><span class="hljs-comment">// an object can be applied to an accumulator: Replaced and Sync.</span><br><span class="hljs-comment">// If EmitDeltaTypeReplaced is not set to true, Sync will be used in</span><br><span class="hljs-comment">// replace events for backwards compatibility.  Sync is used for periodic</span><br><span class="hljs-comment">// resync events.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// DeltaFIFO is a producer-consumer queue, where a Reflector is</span><br><span class="hljs-comment">// intended to be the producer, and the consumer is whatever calls</span><br><span class="hljs-comment">// the Pop() method.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// DeltaFIFO solves this use case:</span><br><span class="hljs-comment">//   - You want to process every object change (delta) at most once.</span><br><span class="hljs-comment">//   - When you process an object, you want to see everything</span><br><span class="hljs-comment">//     that&#x27;s happened to it since you last processed it.</span><br><span class="hljs-comment">//   - You want to process the deletion of some of the objects.</span><br><span class="hljs-comment">//   - You might want to periodically reprocess objects.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// DeltaFIFO&#x27;s Pop(), Get(), and GetByKey() methods return</span><br><span class="hljs-comment">// interface&#123;&#125; to satisfy the Store/Queue interfaces, but they</span><br><span class="hljs-comment">// will always return an object of type Deltas. List() returns</span><br><span class="hljs-comment">// the newest object from each accumulator in the FIFO.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A DeltaFIFO&#x27;s knownObjects KeyListerGetter provides the abilities</span><br><span class="hljs-comment">// to list Store keys and to get objects by Store key.  The objects in</span><br><span class="hljs-comment">// question are called &quot;known objects&quot; and this set of objects</span><br><span class="hljs-comment">// modifies the behavior of the Delete, Replace, and Resync methods</span><br><span class="hljs-comment">// (each in a different way).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A note on threading: If you call Pop() in parallel from multiple</span><br><span class="hljs-comment">// threads, you could end up with multiple threads processing slightly</span><br><span class="hljs-comment">// different versions of the same object.</span><br><span class="hljs-keyword">type</span> DeltaFIFO <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// lock/cond protects access to &#x27;items&#x27; and &#x27;queue&#x27;.</span><br>lock sync.RWMutex<br>cond sync.Cond<br><br><span class="hljs-comment">// `items` maps a key to a Deltas.</span><br><span class="hljs-comment">// Each such Deltas has at least one Delta.</span><br>items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Deltas<br><br><span class="hljs-comment">// `queue` maintains FIFO order of keys for consumption in Pop().</span><br><span class="hljs-comment">// There are no duplicates in `queue`.</span><br><span class="hljs-comment">// A key is in `queue` if and only if it is in `items`.</span><br>queue []<span class="hljs-type">string</span><br><br><span class="hljs-comment">// populated is true if the first batch of items inserted by Replace() has been populated</span><br><span class="hljs-comment">// or Delete/Add/Update/AddIfNotPresent was called first.</span><br>populated <span class="hljs-type">bool</span><br><span class="hljs-comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span><br>initialPopulationCount <span class="hljs-type">int</span><br><br><span class="hljs-comment">// keyFunc is used to make the key used for queued item</span><br><span class="hljs-comment">// insertion and retrieval, and should be deterministic.</span><br>keyFunc KeyFunc<br><br><span class="hljs-comment">// knownObjects list keys that are &quot;known&quot; --- affecting Delete(),</span><br><span class="hljs-comment">// Replace(), and Resync()</span><br>knownObjects KeyListerGetter<br><br><span class="hljs-comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span><br><span class="hljs-comment">// Currently, not used to gate any of CRUD operations.</span><br>closed <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// emitDeltaTypeReplaced is whether to emit the Replaced or Sync</span><br><span class="hljs-comment">// DeltaType when Replace() is called (to preserve backwards compat).</span><br>emitDeltaTypeReplaced <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Add"><a href="#Add" class="headerlink" title="Add()"></a>Add()</h4><p>实际调用的是 queueActionLocked 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Add inserts an item, and puts it in the queue. The item is only enqueued</span><br><span class="hljs-comment">// if it doesn&#x27;t already exist in the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Add(obj <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>   f.lock.Lock()<br>   <span class="hljs-keyword">defer</span> f.lock.Unlock()<br>   f.populated = <span class="hljs-literal">true</span><br>   <span class="hljs-keyword">return</span> f.queueActionLocked(Added, obj)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="queueActionLocked"><a href="#queueActionLocked" class="headerlink" title="queueActionLocked()"></a>queueActionLocked()</h4><p>queueActionLocked 会将 actionType 和 obj 封装为一个 Delta 对象，并 push 到 DeltaFIFO</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// queueActionLocked appends to the delta list for the object.</span><br><span class="hljs-comment">// Caller must lock first.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> queueActionLocked(actionType DeltaType, obj <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>id, err := f.KeyOf(obj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> KeyError&#123;obj, err&#125;<br>&#125;<br>oldDeltas := f.items[id]<br>newDeltas := <span class="hljs-built_in">append</span>(oldDeltas, Delta&#123;actionType, obj&#125;)<br>newDeltas = dedupDeltas(newDeltas)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(newDeltas) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> _, exists := f.items[id]; !exists &#123;<br>f.queue = <span class="hljs-built_in">append</span>(f.queue, id)<br>&#125;<br>f.items[id] = newDeltas<br>f.cond.Broadcast()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// This never happens, because dedupDeltas never returns an empty list</span><br><span class="hljs-comment">// when given a non-empty list (as it is here).</span><br><span class="hljs-comment">// If somehow it happens anyway, deal with it but complain.</span><br><span class="hljs-keyword">if</span> oldDeltas == <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; ignoring&quot;</span>, id, oldDeltas, obj)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>klog.Errorf(<span class="hljs-string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; breaking invariant by storing empty Deltas&quot;</span>, id, oldDeltas, obj)<br>f.items[id] = newDeltas<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; broke DeltaFIFO invariant by storing empty Deltas&quot;</span>, id, oldDeltas, obj)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="functions-4"><a href="#functions-4" class="headerlink" title="functions"></a>functions</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/k8s-club/k8s-club/blob/main/articles/K8s%20%E7%B3%BB%E5%88%97(%E5%9B%9B)%20-%20%E6%B5%85%E8%B0%88%20Informer.md">K8s 系列(四) - 浅谈 Informer.md</a></p><p><a href="https://cloudnative.to/blog/client-go-informer-source-code/#indexer">深入了解 Kubernetes Informer</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubebuilder 实践</title>
    <link href="/2022/10/03/kubebuilder/"/>
    <url>/2022/10/03/kubebuilder/</url>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="下载-kubebuiler"><a href="#下载-kubebuiler" class="headerlink" title="下载 kubebuiler"></a>下载 kubebuiler</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">os=$(go <span class="hljs-built_in">env</span> GOOS)</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">arch</span>=$(go <span class="hljs-built_in">env</span> GOARCH)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/<span class="hljs-variable">$&#123;os&#125;</span>/<span class="hljs-variable">$&#123;arch&#125;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x kubebuilder</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">mv</span> ./kubebuilder /usr/local/bin</span><br></code></pre></td></tr></table></figure><h2 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> operator</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> operator</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go mod init operator.example.com</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们将使用 my.domain 域，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以所有的 API 组将是&lt;group&gt;.my.domain.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubebuilder init --domain my.domain</span><br></code></pre></td></tr></table></figure><h2 id="创建一个-API"><a href="#创建一个-API" class="headerlink" title="创建一个 API"></a>创建一个 API</h2><p>运行下面的命令，创建一个新的 API（组&#x2F;版本）为 “webapp&#x2F;v1”，并在上面创建新的 Kind(CRD) “Guestbook”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubebuilder create api --group webapp --version v1 --kind Guestbook</span><br></code></pre></td></tr></table></figure><h2 id="安装-kustomize"><a href="#安装-kustomize" class="headerlink" title="安装 kustomize"></a>安装 kustomize</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> 到当前项目目录的 bin 目录下</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> bin</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">go version≥go1.17</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">GOBIN=$(<span class="hljs-built_in">pwd</span>)/ GO111MODULE=on go install sigs.k8s.io/kustomize/kustomize/v4@latest</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前目录下是否下载好 kustomize</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>controller-gen kustomize<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>将 CRD 安装到集群中</p><p>这步操作需要你已经安装好 kustomize</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make install<br></code></pre></td></tr></table></figure><p>运行控制器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make run</span><br>go fmt ./...<br>go vet ./...<br>go run ./main.go<br>1.664805588618038e+09   INFO    controller-runtime.metrics      Metrics server is starting to listen    &#123;&quot;addr&quot;: &quot;:8080&quot;&#125;<br>1.664805588619189e+09   INFO    setup   starting manager<br>1.664805588620343e+09   INFO    Starting server &#123;&quot;path&quot;: &quot;/metrics&quot;, &quot;kind&quot;: &quot;metrics&quot;, &quot;addr&quot;: &quot;[::]:8080&quot;&#125;<br>1.664805588620474e+09   INFO    Starting server &#123;&quot;kind&quot;: &quot;health probe&quot;, &quot;addr&quot;: &quot;[::]:8081&quot;&#125;<br>1.664805588620887e+09   INFO    controller.guestbook    Starting EventSource    &#123;&quot;reconciler group&quot;: &quot;webapp.my.domain&quot;, &quot;reconciler kind&quot;: &quot;Guestbook&quot;, &quot;source&quot;: &quot;kind source: *v1.Guestbook&quot;&#125;<br>1.664805588620948e+09   INFO    controller.guestbook    Starting Controller     &#123;&quot;reconciler group&quot;: &quot;webapp.my.domain&quot;, &quot;reconciler kind&quot;: &quot;Guestbook&quot;&#125;<br>1.6648055887228339e+09  INFO    controller.guestbook    Starting workers        &#123;&quot;reconciler group&quot;: &quot;webapp.my.domain&quot;, &quot;reconciler kind&quot;: &quot;Guestbook&quot;, &quot;worker count&quot;: 1&#125;<br><br></code></pre></td></tr></table></figure><p>运行这个 CRD：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f config/samples/</span><br>guestbook.webapp.my.domain/guestbook-sample created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get Guestbook</span><br>NAME               AGE<br>guestbook-sample   33s<br></code></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>继续沿用 <strong>快速入门</strong> 里已经创建好的项目</p><p>注意这里的 group 必须要指定为和 <strong>快速入门</strong> 中相同的 webapp，如果指定为别的，会报错：<code>Error: failed to create API: unable to inject the resource to &quot;base.go.kubebuilder.io/v3&quot;: multiple groups are not allowed by default, to enable multi-group visit https://kubebuilder.io/migration/multi-group.html</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubebuilder create api --group webapp --version v1 --kind CronJob</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker tag 的用处</title>
    <link href="/2022/09/29/docker-tag/"/>
    <url>/2022/09/29/docker-tag/</url>
    
    <content type="html"><![CDATA[<p>docker tag 相当于对镜像做一次备份，将当前的镜像（比如 tag:latest）备份出去一份（比如 tag: v1），然后如果开发了新的镜像，可以直接覆盖掉当前的（tag:latest），然后再给 latest 打个标签：tag:v2，相当于又备份了一份，现在就有了 v1，v2，latest 三个镜像，使用 tag 不仅可以备份镜像，还可以对镜像做标注区分。</p><p>详细可以看下面的例子： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> hello-world-go</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim Dockerfile</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入以下内容</span><br>FROM golang:alpine AS builder<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为我们的镜像设置必要的环境变量</span><br>ENV GO111MODULE=on \<br>    CGO_ENABLED=0 \<br>    GOOS=linux \<br>    GOARCH=arm64<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移动到工作目录：/build</span><br>WORKDIR /build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将代码复制到容器中</span><br>COPY . .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将我们的代码编译成二进制可执行文件 app</span><br>RUN go build -o app .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">接下来创建一个小镜像</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################</span></span><br>FROM scratch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从builder镜像中把/dist/app 拷贝到当前目录</span><br>COPY --from=builder /build/app /<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">需要运行的命令</span><br>ENTRYPOINT [&quot;/app&quot;]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim hello.go</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入以下内容</span><br>package main<br><br>import (<br>        &quot;fmt&quot;<br>)<br><br>func main() &#123;<br>        fmt.Println(&quot;[v1] hello, world!&quot;)<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 go.mod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go mod init helloworld</span><br>go: creating new go.mod: module helloworld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t hello-world .</span><br>Sending build context to Docker daemon  4.608kB<br>Step 1/8 : FROM golang:alpine AS builder<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">97a79d0cc013</span><br>Step 2/8 : ENV GO111MODULE=on     CGO_ENABLED=0     GOOS=linux     GOARCH=arm64<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">accc05f16e78</span><br>Step 3/8 : WORKDIR /build<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">3cbd504d7581</span><br>Step 4/8 : COPY . .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">2bb03068056c</span><br>Step 5/8 : RUN go build -o app .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 6077f4d304a4</span><br>Removing intermediate container 6077f4d304a4<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">c9509017f175</span><br>Step 6/8 : FROM scratch<br><span class="hljs-meta prompt_"> ---&gt;</span><span class="language-bash"></span><br><span class="language-bash">Step 7/8 : COPY --from=builder /build/app /</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">d97340567693</span><br>Step 8/8 : ENTRYPOINT [&quot;/app&quot;]<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 7f5508753fa9</span><br>Removing intermediate container 7f5508753fa9<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">1b57ca8ce7d2</span><br>Successfully built 1b57ca8ce7d2<br>Successfully tagged hello-world:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED              SIZE<br>hello-world               latest    1b57ca8ce7d2   4 seconds ago        1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给镜像打个 tag</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag 1b57 hello-world:v1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看镜像，发现已经有了一个新的 tag 为 v1 的镜像，并且 ID 和 latest 相同，相当于有了一份备份</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE<br>hello-world               latest    1b57ca8ce7d2   2 minutes ago    1.82MB<br>hello-world               v1        1b57ca8ce7d2   2 minutes ago    1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行镜像查看效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world:v1</span><br>hello, world!<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">现在可以再次开发镜像了，修改 hello.go，将输出内容修改为 [v2]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim hello.go</span><br>package main<br><br>import (<br>        &quot;fmt&quot;<br>)<br><br>func main() &#123;<br>        fmt.Println(&quot;[v2] hello, world!&quot;)<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次构建新版本的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t hello-world .</span><br>Sending build context to Docker daemon  4.608kB<br>Step 1/8 : FROM golang:alpine AS builder<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">97a79d0cc013</span><br>Step 2/8 : ENV GO111MODULE=on     CGO_ENABLED=0     GOOS=linux     GOARCH=arm64<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">accc05f16e78</span><br>Step 3/8 : WORKDIR /build<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">3cbd504d7581</span><br>Step 4/8 : COPY . .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Using cache</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">6ee29a59885a</span><br>Step 5/8 : RUN go build -o app .<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 9e6388ccd40c</span><br>Removing intermediate container 9e6388ccd40c<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">78cb76e165de</span><br>Step 6/8 : FROM scratch<br><span class="hljs-meta prompt_"> ---&gt;</span><span class="language-bash"></span><br><span class="language-bash">Step 7/8 : COPY --from=builder /build/app /</span><br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">9fbd2d306353</span><br>Step 8/8 : ENTRYPOINT [&quot;/app&quot;]<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="hljs-keyword">in</span> 49e410971798</span><br>Removing intermediate container 49e410971798<br><span class="hljs-meta prompt_"> ---&gt; </span><span class="language-bash">245cbeaf290f</span><br>Successfully built 245cbeaf290f<br>Successfully tagged hello-world:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看镜像，新的镜像覆盖掉了之前的 hello-world:latest</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE<br>hello-world               latest    245cbeaf290f   11 seconds ago   1.82MB<br>hello-world               v1        1b57ca8ce7d2   37 minutes ago   1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看新镜像的运行效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world</span><br>[v2] hello, world!<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次给新镜像打 tag，相当于做一次备份</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker tag 245cbeaf290f hello-world:v2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看现在的 iamge</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker images</span><br>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE<br>hello-world               latest    245cbeaf290f   49 seconds ago   1.82MB<br>hello-world               v2        245cbeaf290f   49 seconds ago   1.82MB<br>hello-world               v1        1b57ca8ce7d2   38 minutes ago   1.82MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看新镜像的运行效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world:v2</span><br>[v2] hello, world!<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run hello-world:v1</span><br>[v1] hello, world!<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">现在就已经有了两个版本的镜像了</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s StatefulSet</title>
    <link href="/2022/09/11/k8s-statefulset/"/>
    <url>/2022/09/11/k8s-statefulset/</url>
    
    <content type="html"><![CDATA[<h1 id="有状态与无状态"><a href="#有状态与无状态" class="headerlink" title="有状态与无状态"></a>有状态与无状态</h1><p><strong>无状态应用</strong>，指的是在运行时不需要维护或跟踪任何特定状态的应用程序。例如，Web 服务器或 API 服务器通常可以处理来自客户端的请求，而无需了解以前的请求或客户端状态。这些应用程序可以很容易地水平扩展，因为它们不需要共享状态，所以可以在任何节点上运行。像 Deployment 也是一个典型的“无状态应用”，它会按照事先声明的模板创建出 pod，这表示每个 pod 的定义将会是一模一样的，此外，这些 pod 之间没有之间没有顺序相关性（什么事有顺序相关性？比如一些集群应用包含主节点和从节点，而主节点必须先于从节点启动，这便是顺序相关性），也无所谓在哪台宿主机上运行，任何一个 pod 都可以提供完全相同的功能，不需要时，也可以结束任意一个 pod。</p><p>相比之下，有状态，指的是那些在运行时需要维护和跟踪特定状态的应用程序，例如数据库或缓存。这些应用程序需要将数据持久化到存储中，并且需要一个唯一的标识符来标识它们的状态。这意味着当应用程序重新启动或迁移到其他节点时，必须能够重新获取其以前的状态。</p><h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><h2 id="yaml-模板"><a href="#yaml-模板" class="headerlink" title="yaml 模板"></a>yaml 模板</h2><p>下面就是一个 StatefulSet 的 yaml 模板，这个 StatefulSet 中定义了一个包含 3 个副本的 Nginx Pod，每个 Pod 都有一个 PVC 挂载到 &#x2F;data 目录，用于存储应用程序数据。它还定义了一个 Headless Service，名为 example，用于为 Pod 提供唯一的稳定 DNS 名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><p>乍一看和 deployment 的模板非常类似，只是多了 <code>serviceName</code> 和 <code>volumeClaimTemplates</code> 这两个字段，这两个字段的作用如下：</p><ul><li><code>serviceName</code> 指定了与 StatefulSet 相关联的 <strong>Headless Service</strong> 的名称，用于 DNS 解析。</li><li><code>volumeClaimTemplates</code> 指定了 StatefulSet 中每个 Pod 对应的 PersistentVolumeClaim 模板，用于为每个 Pod 创建对应的 PVC。这些 PVC 可以用于存储 StatefulSet 中的数据，从而实现 StatefulSet 的持久化存储。</li></ul><p>所以要想创建 StatefulSet，还需要先创建一个 headless service，用如下的 yaml 来创建一个 headless service：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口，不指定 targetPort，则默认与 port 相同</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <br></code></pre></td></tr></table></figure><p>创建完成后，预期结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get sts</span><br>NAME    READY   AGE<br>nginx   3/3     18m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME      READY   STATUS    RESTARTS   AGE<br>nginx-0   1/1     Running   0          18m<br>nginx-1   1/1     Running   0          17m<br>nginx-2   1/1     Running   0          16m<br></code></pre></td></tr></table></figure><p>现在我们要重点观察的是 <code>volumeClaimTemplates</code> 这个字段的作用，它会 <strong>为每个由 StatefulSet 创建的来的 pod 创建一个 pvc，并进行绑定</strong>：</p><p>查看所有的 pvc，发现现在已经有 3 个 pvc 了，并且它们的命名格式都是 &lt;volumeClaimTemplates.metadata.name&gt;-&lt;statefulSet.name&gt;-&lt;连续的序号&gt;。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME           STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>data-nginx-0   Bound    pvc-03e2e475-c81b-47c6-932f-40a758640628   1Gi        RWO            local-path     21m<br>data-nginx-1   Bound    pvc-71776884-824a-4773-8a4d-a626b0381329   1Gi        RWO            local-path     20m<br>data-nginx-2   Bound    pvc-bf9d7f67-f59a-42e9-a1c1-03c29887dbbf   1Gi        RWO            local-path     20m<br></code></pre></td></tr></table></figure><p>我们再查看一下每个 pod 绑定的 pvc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods -l app=nginx -o=jsonpath=<span class="hljs-string">&#x27;&#123;range .items[*]&#125;&#123;&quot;Pod Name: &quot;&#125;&#123;.metadata.name&#125; &#123;&quot;\t&quot;&#125; &#123;&quot;PVC Name: &quot;&#125;&#123;.spec.volumes[*].persistentVolumeClaim.claimName&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span></span><br><br>Pod Name: nginx-0  PVC Name: data-nginx-0<br>Pod Name: nginx-1  PVC Name: data-nginx-1<br>Pod Name: nginx-2  PVC Name: data-nginx-2<br></code></pre></td></tr></table></figure><p>发现了吗，每个 pod 绑定的 pvc 的名字都是有规可循的，</p><blockquote><p>突发奇想：如果删除某个 pvc 会发生什么？</p><p>实践了一下，发现执行了 <code>kubectl delete pvc data-nginx-0</code> 后，会输出 <code>persistentvolumeclaim &quot;data-nginx-0&quot; deleted</code>，然后整个终端就阻塞了，按 <code>Ctrl+c</code> 强制退出后，这个 pvc 的 Status 变为 Terminating，但是对应的 pod 仍然为 Running 状态</p></blockquote><p>然后我们再尝试向 pod 挂载的目录里创建一个文件，并像文件内写入一条数据，然后删除这个 pod，看看会发生什么。</p><p>首先先创建文件并写入数据，我们这里写入的对象 pod 是 nginx-0：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-0 -- /bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cd</span> 到挂载目录</span><br>root@nginx-0:/# cd /data<br>root@nginx-0:/data# ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在该目录下创建文件并写入内容</span><br>root@nginx-0:/data# echo &quot;test&quot; &gt; test.txt<br>root@nginx-0:/data# ls<br>test.txt<br>root@nginx-0:/data# cat test.txt<br>test<br></code></pre></td></tr></table></figure><p>然后删除这个 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除前先看一下当前所有的 pod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME      READY   STATUS    RESTARTS   AGE<br>nginx-0   1/1     Running   0          4d22h<br>nginx-1   1/1     Running   0          4d22h<br>nginx-2   1/1     Running   0          4d22h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删掉 nginx-0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po nginx-0</span><br>pod &quot;nginx-0&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看删除后效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME      READY   STATUS    RESTARTS   AGE<br>nginx-1   1/1     Running   0          4d22h<br>nginx-2   1/1     Running   0          4d22h<br>nginx-0   0/1     Pending   0          3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等待一会，nginx-0 会重新建出来</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -w</span><br>NAME      READY   STATUS              RESTARTS   AGE<br>nginx-1   1/1     Running             0          4d22h<br>nginx-2   1/1     Running             0          4d22h<br>nginx-0   0/1     ContainerCreating   0          5s<br>nginx-0   1/1     Running             0          5s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">再次查看 pod 的挂载目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-0 -- <span class="hljs-built_in">ls</span> /data</span><br>test.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-0 -- <span class="hljs-built_in">cat</span> /data/test.txt</span><br>test<br></code></pre></td></tr></table></figure><p>通过上面的实践，我们发现删除 pod 后，StatefulSet 会自动重建 pod，并且重要的是，<strong>重建的 pod 名字和先前的会保持一致</strong>，我们删掉了 nginx-0 ，然后重建出来的 pod 也叫 nginx-0，又因为名字和先前的一致，按照 pvc 的绑定规则，它依然会绑定到 data-nginx-0 这个 pvc，进而挂载到和这个 pvc 绑定的 pv。这也表明，删除 pod 并不会删除其对应的 pvc 和 pv，所以 pod 对应的数据才会安全的保存。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>创建一个 handless service：</p><p><strong>kubia-service-headless.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-service-headless.yaml</span><br>service/kubia created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   32h<br>kubia                    ClusterIP   None           &lt;none&gt;        80/TCP    9s<br></code></pre></td></tr></table></figure><p>准备一个程序用来测试，这是一个 HTTP 程序，如果发送 POST 请求，那么会在指定目录下创建&#x2F;打开一个文件，并将请求体内容写入该文件；如果发送 GET 请求，会在指定目录下读取文件内容，并作为 response 返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">const</span> dataFile = <span class="hljs-string">&quot;/var/data/kubia.txt&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fileExists</span>(<span class="hljs-params">file</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    fs.<span class="hljs-title function_">statSync</span>(file);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>) &#123;<br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">method</span> == <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>    <span class="hljs-keyword">var</span> file = fs.<span class="hljs-title function_">createWriteStream</span>(dataFile);<br>    file.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">fd</span>) &#123;<br>      request.<span class="hljs-title function_">pipe</span>(file);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;New data has been received and stored.&quot;</span>);<br>      response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>      response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Data stored on pod &quot;</span> + os.<span class="hljs-title function_">hostname</span>() + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-title function_">fileExists</span>(dataFile) ? fs.<span class="hljs-title function_">readFileSync</span>(dataFile, <span class="hljs-string">&#x27;utf8&#x27;</span>) : <span class="hljs-string">&quot;No data posted yet&quot;</span>;<br>    response.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>);<br>    response.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;You&#x27;ve hit &quot;</span> + os.<span class="hljs-title function_">hostname</span>() + <span class="hljs-string">&quot;\n&quot;</span>);<br>    response.<span class="hljs-title function_">end</span>(<span class="hljs-string">&quot;Data stored on this pod: &quot;</span> + data + <span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> www = http.<span class="hljs-title function_">createServer</span>(handler);<br>www.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><p>对应的 Dockerfile，注意这里使用的是 arm64 类型的镜像：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> arm64v8/node:<span class="hljs-number">7</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> app.js /app.js</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>kubia-statefulset.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span> <span class="hljs-comment"># has to match .spec.template.metadata.labels</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/kubia-pet-arm64</span> <span class="hljs-comment"># 注意这里更换成了 arm64 架构的</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/data</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Mi</span><br>      <span class="hljs-attr">accessModes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-statefulset.yaml</span><br>statefulset.apps/kubia created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS       AGE<br>kubia-0          1/1     Running   0              61s<br>kubia-1          1/1     Running   0              26s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>local-path-pvc   Bound    pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4   50Mi       RWO            local-path     21h<br>data-kubia-0     Bound    pvc-b2742307-c5d5-4402-a9a6-54730d60c4a3   1Mi        RWO            local-path     62m<br>data-kubia-1     Bound    pvc-28570e23-c08a-4610-8b6e-cc35434ded21   1Mi        RWO            local-path     61m<br></code></pre></td></tr></table></figure><p>使用 API server 访问 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy</span><br>Starting to serve on 127.0.0.1:8001<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>You&#x27;ve hit kubia-0<br>Data stored on this pod: No data posted yet<br></code></pre></td></tr></table></figure><p>本次发送的是 GET 请求，因为还没有发送过 POST 请求，所以文件还不存在，所以返回 No data posted yet</p><p>发送一个 POST 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -X POST -d <span class="hljs-string">&quot;Hey there! This greeting was submitted to kubia-0.&quot;</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>Data stored on pod kubia-0<br></code></pre></td></tr></table></figure><p>此时已经将请求体里的内容保存在了容器内</p><p>再次发送 GET 请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>You&#x27;ve hit kubia-0<br>Data stored on this pod: Hey there! This greeting was submitted to kubia-0.<br></code></pre></td></tr></table></figure><p>再次发送请求，发现可以输出文件内容了</p><p>现在删除一个 statefulset，看看其保存的数据会不会丢失：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po kubia-0</span><br>pod &quot;kubia-0&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                                  READY   STATUS    RESTARTS   AGE<br>kubia-1                               1/1     Running   0          12h<br>kubia-0                               1/1     Running   0          27s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br>You&#x27;ve hit kubia-0<br>Data stored on this pod: Hey there! This greeting was submitted to kubia-0.<br></code></pre></td></tr></table></figure><p>发现该 po 被删除后立马就重新创建出了一个新的，并且名字与与之前被删除的 pod 完全相同，并且其存储的数据也没有丢失</p><h1 id="在-statefulset-中发现伙伴节点"><a href="#在-statefulset-中发现伙伴节点" class="headerlink" title="在 statefulset 中发现伙伴节点"></a>在 statefulset 中发现伙伴节点</h1><p>之前以已经创建了一个 handless service，通过解析（lookup）这个 service 的 dns 便可获取其管辖的所有 pod 的 ip，那么 pod 就可以通过这种方式来获取同属于一个 service 下的其他 pod 的地址，进而完成通信。下面就来实践一下：</p><p>首先来尝试一下获取 handless service 下所有 pod 的 SRV 记录：</p><blockquote><p><strong>什么是 SRV 记录？</strong></p></blockquote><p>查看 handless service 的 SRV 记录：</p><blockquote><p>PS: 书里写的是 –image&#x3D;tutum&#x2F;dnstuils，但是这个镜像是 amd64 的，所以我重新做了一个镜像：stdoutt&#x2F;dnstuils-arm64</p><p>附：该镜像的 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:trusty<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -yq dnsutils &amp;&amp; apt-get clean &amp;&amp; <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists</span><br></code></pre></td></tr></table></figure></blockquote><p>具体操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先看一下 handless service 的 name</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1    &lt;none&gt;        443/TCP   2d3h<br>kubia        ClusterIP   None         &lt;none&gt;        80/TCP    12s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 kubia 这个 service 的 SRV 记录（该 service 的完整域名是 kubia.default.svc.cluster.local ），这个 pod 在</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行完毕后会立马删除，这里使用的是 stdoutt/dnsutils-arm64 这个适用于 arm64 的镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run -it srvlookup --image=stdoutt/dnsutils-arm64 --<span class="hljs-built_in">rm</span> --restart=Never -- dig SRV kubia.default.svc.cluster.local</span><br><br>; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.19-Ubuntu &lt;&lt;&gt;&gt; SRV kubia.default.svc.cluster.local<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 24375<br>;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 3<br>;; WARNING: recursion requested but not available<br><br>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 4096<br>;; QUESTION SECTION:<br>;kubia.default.svc.cluster.local. INSRV<br><br>;; ANSWER SECTION:<br>kubia.default.svc.cluster.local. 5 INSRV0 50 80 kubia-0.kubia.default.svc.cluster.local.<br>kubia.default.svc.cluster.local. 5 INSRV0 50 80 kubia-1.kubia.default.svc.cluster.local.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里便获取到了该 service 下的所有 pod 的 ip 地址</span><br>;; ADDITIONAL SECTION:<br>kubia-1.kubia.default.svc.cluster.local. 5 IN A10.42.0.22<br>kubia-0.kubia.default.svc.cluster.local. 5 IN A10.42.0.23<br><br>;; Query time: 12 msec<br>;; SERVER: 10.43.0.10#53(10.43.0.10)<br>;; WHEN: Mon Sep 26 16:37:29 UTC 2022<br>;; MSG SIZE  rcvd: 350<br><br>pod &quot;srvlookup&quot; deleted<br></code></pre></td></tr></table></figure><h1 id="使用-StatefulSet-搭建一个-MySQL-集群"><a href="#使用-StatefulSet-搭建一个-MySQL-集群" class="headerlink" title="使用 StatefulSet 搭建一个 MySQL 集群"></a>使用 StatefulSet 搭建一个 MySQL 集群</h1><p>主节点和从节点需要不同的配置文件，可以通过一个 configmap 定义，如下所示，这里定义了 master.cnf 和 slave.cnf 两个 MySQL 的配置文件。</p><ul><li>master.cnf 开启了 log-bin，即使用二进制日志文件的方式进行主从复制，这是一个标准的设置。</li><li>slave.cnf 开启了 super-read-only，表示从节点会拒绝除主节点的数据同步操作外的所有写操作，即它对用户是只读的。</li></ul><p><strong>mysql-configmap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">primary.cnf:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    # 仅在主服务器上应用此配置</span><br><span class="hljs-string">    [mysqld]</span><br><span class="hljs-string">    log-bin    </span><br><span class="hljs-string"></span>  <span class="hljs-attr">replica.cnf:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    # 仅在副本服务器上应用此配置</span><br><span class="hljs-string">    [mysqld]</span><br><span class="hljs-string">    super-read-only  </span><br></code></pre></td></tr></table></figure><blockquote><p>ps：也可以使用下面的命令 <code>&lt;&lt;EOF</code> 写入到文件，它将持续读取你的多行输入，直到你输入一个 EOF。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; mysql-configmap.yaml<br>apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  name: mysql<br>  labels:<br>    app: mysql<br>    app.kubernetes.io/name: mysql<br>data:<br>  primary.cnf: |<br>    # 仅在主服务器上应用此配置<br>    [mysqld]<br>    log-bin<br>  replica.cnf: |<br>    # 仅在副本服务器上应用此配置<br>    [mysqld]<br>    super-read-only<br>EOF<br></code></pre></td></tr></table></figure></blockquote><p>创建这个 cm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f mysql-configmap.yaml</span><br>configmap/mysql created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm</span><br>NAME               DATA   AGE<br>kube-root-ca.crt   1      5d22h<br>mysql              2      27s<br></code></pre></td></tr></table></figure><p>接下来，需要创建两个 Service 来供 StatefulSet 以及用户使用。这两个 Service 的定义如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 为 StatefulSet 成员提供稳定的 DNS 表项的无头服务（Headless Service）</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">mysql</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 用于连接到任一 MySQL 实例执行读操作的客户端服务</span><br><span class="hljs-comment"># 对于写操作，你必须连接到主服务器：mysql-0.mysql</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-read</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">readonly:</span> <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3306</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">mysql</span><br></code></pre></td></tr></table></figure><p>这两个 Service 都代理了含有 label <code>app: mysql</code> 的 Pod，端口映射都是用 Service 的 3306 端口对应 Pod 的 3306 端口，并且其中一个 Service 是 Headless Service（即 ClusterIP 为 None），它将为其代理的 Pod 分配一个 DNS 记录来固定其拓扑状态</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu arm64 使用 apt-get 安装 docker，以及 snap 的一些问题记录</title>
    <link href="/2022/09/10/ubuntu-arm64-an-zhuang-docker/"/>
    <url>/2022/09/10/ubuntu-arm64-an-zhuang-docker/</url>
    
    <content type="html"><![CDATA[<p>使用 snap 可以比较方便的安装 docker，但是有一次出现了 k8s pod 无法拉取镜像的问题，看了下 pod describe，发现是因为走代理的问题（我使用的是 ubuntu 虚拟机，连接宿主机的 clashx 进行代理），连接的代理是宿主机的老地址 192.168.2.5，但是因为重启过路由器，所以宿主机的地址变更为了 192.168.2.3，代理不通自然也拉取不了镜像了，报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Failed <span class="hljs-keyword">to</span> pull image &quot;redis&quot;: rpc error: code = <span class="hljs-type">Unknown</span> <span class="hljs-keyword">desc</span> = Error response <span class="hljs-keyword">from</span> daemon: <span class="hljs-keyword">Get</span> &quot;https://registry-1.docker.io/v2/&quot;: proxyconnect tcp: dial tcp <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span>:<span class="hljs-number">7890</span>: <span class="hljs-keyword">connect</span>: <span class="hljs-keyword">connection</span> refused<br></code></pre></td></tr></table></figure><p>虽然我重新设置了 https_proxy 等相关环境变量，并且 curl google 可以正常返回，但是 pod 这边依旧无法拉取，走的还是 192.168.2.5 这个地址。</p><p>于是我就尝试重启一下 docker 看能不能解决，按照网上提供的几个方案，<code>systemctl restart docker</code>，报错：<code>Failed to restart docker.service: Unit docker.service not found.</code>，于是我又尝试使用 <code>snap restart docker</code>，发现可以重启成功，输出信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Run service command &quot;restart&quot; for running services of snap &quot;docker&quot;<br>Restarted.<br></code></pre></td></tr></table></figure><p>看起来已经重启成功了，但是等我执行 docker ps 时，直接报错：<code>docker ps Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code>，根本就没重启成功！于是我又尝试执行 <code>snap start docker </code> 命令，返回 <code>Started.</code>，但是然并卵，依然报之前的错误，实属是个坑爹玩意。</p><p>没得办法，只能从 snap 中删掉 docker，再重新使用 apt-get 安装了，但是 apt-get 安装就略有繁琐了，参照 <a href="https://zhuanlan.zhihu.com/p/143156163">这篇文章</a> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意这一步，<span class="hljs-built_in">arch</span> 这里，要根据你的机器架构来指定，比如 arm64 或者是 amd64，我一开始就是直接复制文章中的命令，导致加入的是</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">amd64 的软件源，而我的机器是 arm 的，导致后面安装 docker 失败</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用 <span class="hljs-built_in">uname</span> -c 查看机器的架构</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=arm64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></code></pre></td></tr></table></figure><p>使用 apt-get 安装的 docker 就可以使用 systemctl 操作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart docker</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoLand/Idea 启动闪退，报错 NSInternalInconsistencyException 的解决方法</title>
    <link href="/2022/09/08/jetbrain_crash/"/>
    <url>/2022/09/08/jetbrain_crash/</url>
    
    <content type="html"><![CDATA[<p>环境：</p><ul><li>机器：MacBook Air (M1, 2020)</li><li>系统：MacOS 12.5.1</li><li>Goland 版本：2022.2.2</li><li>Idea 版本：2022.1.1</li></ul><p>今天启动 GoLand 发现会立马闪退，提示程序意外退出，后来又试了下 Idea 和 Clion，发现全部都是如此，尝试在终端启动查看错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/Library/Application\ Support/JetBrains/Toolbox/apps/Goland/ch-0/222.3739.57/GoLand.app/Contents/MacOS</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./goland</span><br>2022-09-07 22:53:36.422 goland[12904:58283] allVms required 1.8*,1.8+<br>2022-09-07 22:53:36.425 goland[12904:58286] Current Directory: /Users/zenghao/Library/Application Support/JetBrains/Toolbox/apps/Goland/ch-0/222.3739.57/GoLand.app/Contents/MacOS<br>2022-09-07 22:53:36.425 goland[12904:58286] parseVMOptions: GOLAND_VM_OPTIONS = /Users/zenghao/Downloads/jetbra/vmoptions/goland.vmoptions<br>2022-09-07 22:53:36.428 goland[12904:58286] parseVMOptions: platform=-1 user=-1 file=(null)<br>2022-09-07 22:53:36.531 goland[12904:58286] *** Terminating app due to uncaught exception &#x27;NSInternalInconsistencyException&#x27;, reason: &#x27;NSWindow drag regions should only be invalidated on the Main Thread!&#x27;<br>*** First throw call stack:<br>(<br>0   CoreFoundation                      0x00000001c26951a8 __exceptionPreprocess + 240<br>1   libobjc.A.dylib                     0x00000001c23dfe04 objc_exception_throw + 60<br>2   CoreFoundation                      0x00000001c26c0128 _CFBundleGetValueForInfoKey + 0<br>3   AppKit                              0x00000001c51a3930 -[NSWindow(NSWindow_Theme) _postWindowNeedsToResetDragMarginsUnlessPostingDisabled] + 372<br>4   AppKit                              0x00000001c518e92c -[NSWindow _initContent:styleMask:backing:defer:contentView:] + 948<br>5   AppKit                              0x00000001c533607c -[NSPanel _initContent:styleMask:backing:defer:contentView:] + 48<br>6   AppKit                              0x00000001c518e56c -[NSWindow initWithContentRect:styleMask:backing:defer:] + 56<br>7   AppKit                              0x00000001c5336030 -[NSPanel initWithContentRect:styleMask:backing:defer:] + 48<br>8   AppKit                              0x00000001c518cd94 -[NSWindowTemplate nibInstantiate] + 292<br>9   AppKit                              0x00000001c51579e8 -[NSIBObjectData instantiateObject:] + 236<br>10  AppKit                              0x00000001c515726c -[NSIBObjectData nibInstantiateWithOwner:options:topLevelObjects:] + 392<br>11  AppKit                              0x00000001c514b800 loadNib + 416<br>12  AppKit                              0x00000001c514ad30 +[NSBundle(NSNibLoading) _loadNibFile:nameTable:options:withZone:ownerBundle:] + 800<br>13  AppKit                              0x00000001c514a934 -[NSBundle(NSNibLoading) loadNibNamed:owner:topLevelObjects:] + 220<br>14  AppKit                              0x00000001c54b4674 -[NSAlert init] + 148<br>15  goland                              0x0000000100415270 -[Launcher buildArgsFor:] + 1144<br>16  goland                              0x0000000100415878 -[Launcher launch] + 312<br>17  Foundation                          0x00000001c34f060c __NSThread__start__ + 808<br>18  libsystem_pthread.dylib             0x00000001c254826c _pthread_start + 148<br>19  libsystem_pthread.dylib             0x00000001c254308c thread_start + 8<br>)<br>libc++abi: terminating with uncaught exception of type NSException<br>[1]    12904 abort      ./goland<br></code></pre></td></tr></table></figure><p>发现报错信息是 NSInternalInconsistencyException，最终找到了 <a href="https://youtrack.jetbrains.com/issue/JBR-4296">解决方法</a></p><p>这个 issue 下面有一条回复：</p><blockquote><p>hey I could fix this issue with following instructions:</p><p>open this file &#x2F;Users&#x2F;{USER_NAME}&#x2F;Library&#x2F;LaunchAgents&#x2F;jetbrains.vmoptions.plist</p><p>and then remove all <code>launchctl setenv &quot;*_OPTIONS&quot;</code>.</p><p>save and close it.</p><p>reboot your mac.</p><p>now you can use jetbrain :)</p></blockquote><p>流程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ~/Library/LaunchAgents</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">open jetbrains.vmoptions.plist</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除所有以 launchctl setenv 开头的行，也就是除第一行和最后一行外的所有内容</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启 mac</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">大功告成</span><br></code></pre></td></tr></table></figure><p>不知道是什么原因导致的，个人感觉大概率是因为用了破解的缘故，按照上面的流程重启以后会发现认证信息已经没有了，需要重新执行破解脚本并输入激活码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 虚拟网络设备 Veth-Pair</title>
    <link href="/2022/09/06/linux_veth_pair/"/>
    <url>/2022/09/06/linux_veth_pair/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Veth-Pair-是什么"><a href="#Veth-Pair-是什么" class="headerlink" title="Veth-Pair 是什么"></a>Veth-Pair 是什么</h2><p>顾名思义，Veth-Pair 就是一对的虚拟设备接口，它总是以两张虚拟网卡（Veth Peer）<strong>成对出现</strong>，每个 Veth 都有两端，其中一端连着网络协议栈，另一端连接另一个 Veth。比如下图所示，该 Veth-Pair 有两张虚拟网卡 <code>veth0</code> 和 <code>veth1</code>，它们彼此相连，此外每个虚拟网卡都还连接着网络协议栈。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------------------------------------------<br>|<span class="hljs-string">                                           </span>|<br>|<span class="hljs-string">               网络协议栈                    </span>|<br>|<span class="hljs-string">                                           </span>|<br>---------------------------------------------<br>    ^             ^               ^<br>    |<span class="hljs-string">             </span>|<span class="hljs-string">               </span>|<br>    |<span class="hljs-string">             </span>|<span class="hljs-string">               </span>|<br>    |<span class="hljs-string">         ---------       ---------</span><br><span class="hljs-string">    </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> veth0 </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> veth1 </span>|<br>--------      ---------       ---------<br>|<span class="hljs-string"> eth0 </span>|<span class="hljs-string">          ^              ^</span><br><span class="hljs-string">--------          </span>|<span class="hljs-string">               </span>|<span class="hljs-string"></span><br><span class="hljs-string">                  </span>|<span class="hljs-string">               </span>|<br>                   ---------------<br></code></pre></td></tr></table></figure><p>搞清楚 Veth-Pair 的大致概念了，接下来需要了解一下 Veth-Pair 的作用，其实从上面的图中已经可以大致猜到了，既然这些东西都连在一起，那么一定和数据传输脱不了关系，实际上确实如此，对于 Veth-Pair 而言，从其中一张虚拟网卡发出的数据包，可以被另一张虚拟网卡接收到，而每张虚拟网卡又都连接到了网络协议栈，也就是说，Veth-Pair 可以充当网络协议栈中某些接口设备传递数据的桥梁。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="两个-namespace-间通信"><a href="#两个-namespace-间通信" class="headerlink" title="两个 namespace 间通信"></a>两个 namespace 间通信</h2><h3 id="直接连接"><a href="#直接连接" class="headerlink" title="直接连接"></a>直接连接</h3><p>首先我们创建两个网络 namespace，然后再创建一对 Veth-Pair，并且给该 Veth-Pair 的两个虚拟网卡分配 IP 地址，最后，将这两个虚拟网卡分配给两个 namespace。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 2 个 namespace</span><br>ip netns add ns1<br>ip netns add ns2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看创建的 namespace</span><br>ip netns<br>ns2<br>ns1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一对 veth-pair，分别命名为 veth0 veth1</span><br>ip l a veth0 type veth peer name veth1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以写成：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 veth0 veth1 分别加入两个 ns</span><br>ip l s veth0 netns ns1<br>ip l s veth1 netns ns2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给两个虚拟网卡 veth0 veth1 配上 IP 并启用</span><br>ip netns exec ns1 ip a a 10.1.1.2/24 dev veth0<br>ip netns exec ns1 ip l s veth0 up<br>ip netns exec ns2 ip a a 10.1.1.3/24 dev veth1<br>ip netns exec ns2 ip l s veth1 up<br></code></pre></td></tr></table></figure><p>添加完后可以看一下每个 namespace 的网卡设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns1 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>5: veth0@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 4a:19:b1:f3:af:22 brd ff:ff:ff:ff:ff:ff link-netns ns2<br>    inet 10.1.1.2/24 scope global veth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::4819:b1ff:fef3:af22/64 scope link<br>       valid_lft forever preferred_lft forever<br>    <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns2 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>4: veth1@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether be:61:8a:3f:eb:b2 brd ff:ff:ff:ff:ff:ff link-netns ns1<br>    inet 10.1.1.3/24 scope global veth1<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::bc61:8aff:fe3f:ebb2/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>可以看到每个 namespace 都有一张以 veth 开头的网卡，这正是我们创建的 Veth-Pair 的两张虚拟网卡 <code>veth0</code> 和 <code>veth1</code>，并且每张网卡拥有一个 IP。 现在，我们创建了类似文章开头介绍中的图片的结构：veth0 和 veth1 相互连接，然后 veth0 又连接着 ns1，veth1 又连接着 ns2：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------       ---------<br>|<span class="hljs-string">  ns1  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  ns2  </span>|<br>---------       ---------    <br>    ^               ^<br>    |<span class="hljs-string">               </span>|<br>    |<span class="hljs-string">               </span>|<br>---------       ---------<br>|<span class="hljs-string"> veth0 </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> veth1 </span>|<br>---------       ---------<br>    ^              ^<br>    |<span class="hljs-string">               </span>|<span class="hljs-string"></span><br><span class="hljs-string">    </span>|<span class="hljs-string">               </span>|<br>     ---------------<br></code></pre></td></tr></table></figure><p>现在，两个本来相互隔离，各自拥有独立网络协议栈，像孤岛一样的网络命名空间，通过 Veth-Pair 这个“桥梁”，正式建立起了彼此沟通的渠道。让我们尝试一下，用 ns1 去 ping ns2，看看能不能 ping 通：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从 veth0 ping veth1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns1 ping 10.1.1.3</span><br>PING 10.1.1.3 (10.1.1.3) 56(84) bytes of data.<br>64 bytes from 10.1.1.3: icmp_seq=1 ttl=64 time=0.997 ms<br>64 bytes from 10.1.1.3: icmp_seq=2 ttl=64 time=0.102 ms<br>64 bytes from 10.1.1.3: icmp_seq=3 ttl=64 time=0.063 ms<br>^C<br>--- 10.1.1.3 ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2026ms<br>rtt min/avg/max/mdev = 0.063/0.387/0.997/0.431 ms<br></code></pre></td></tr></table></figure><p>可以看到 ping 能正常工作，说明二者已经可以通信了。</p><h3 id="通过-Bridge-相连"><a href="#通过-Bridge-相连" class="headerlink" title="通过 Bridge 相连"></a>通过 Bridge 相连</h3><p>上面 <strong>直接连接</strong> 的 demo 中，我们通过一对 Veth-Pair 让两个 namespace 之间实现了通信，但是如果我们想让三个，四个，甚至更多的 namespace 之间都能够通信呢？要还是采用直接连接的方式，那可就太复杂了，比如如果有四个 namespace，分别是 ns1，ns2，ns3，ns4，那么 ns1 和 ns2 通信需要一对 Veth-Pair，ns1 和 ns3，ns1 和 ns4，ns2 和 ns3，ns2 和 ns4，ns3 和 ns4 都需要一对 Veth-Pair。。。有什么办法可以解决这个问题呢？</p><p>解决办法就是引入一个新的网络设备：能够起到虚拟交换机作用的 <strong>网桥</strong>，它是一个在 <strong>数据链路层</strong> 工作的设备，主要功能是根据 MAC 地址学习将数据包转发到网桥的不同端口上。</p><blockquote><p>突击测试：什么是 MAC 地址学习？</p></blockquote><p>我们可以通过 Veth-Pair，将各个 namespace 与网桥连接起来，这些 namespace 全部都加入到同一个网桥，相当于都在同一个局域网下，所以彼此之间可以互相通信。</p><blockquote><p>🤔 这些虚拟网卡（连接到 namespace 这一端的，比如下图中的 veth0，veth1，veth2，veth3）的 IP 是否必须要处于同一网段？否则即使都在同一个网桥，也无法进行通信？</p><p>📢 如果两个网卡的IP不在同一个子网，将它们加入到同一个网桥后，它们在网络层（IP层）仍然无法直接通信。这是因为网桥工作在数据链路层，它只负责根据MAC地址转发数据包，并不涉及IP地址的路由。</p><p>待实践</p></blockquote><p>拓扑结构如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">---------       ---------    ---------    ---------<br>|<span class="hljs-string">  ns1  </span>|<span class="hljs-string">       </span>|<span class="hljs-string">  ns2  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  ns3  </span>|<span class="hljs-string">    </span>|<span class="hljs-string">  ns4  </span>|<span class="hljs-string"> </span><br><span class="hljs-string">---------       ---------    ---------    ---------   </span><br><span class="hljs-string">    ^               ^            ^            ^</span><br><span class="hljs-string">    </span>|<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>---------       ---------   ---------    ---------<br>|<span class="hljs-string"> veth0 </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> veth1 </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> veth2 </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> veth3 </span>|<br>---------       ---------    ---------    ---------<br>    ^              ^            ^            ^<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">           </span>|<span class="hljs-string">            </span>|<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<span class="hljs-string">            </span>|<br>    ∨               ∨            ∨            ∨<br>-----------     ------------  ------------  ------------<br>|<span class="hljs-string"> br-veth0 </span>|<span class="hljs-string">    </span>|<span class="hljs-string"> br-veth1 </span>|<span class="hljs-string">  </span>|<span class="hljs-string"> br-veth2 </span>|<span class="hljs-string">  </span>|<span class="hljs-string"> br-veth3 </span>|<br>-----------     ------------  ------------  ------------<br>    ^              ^               ^            ^<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">              </span>|<span class="hljs-string">            </span>|<br>    |<span class="hljs-string">               </span>|<span class="hljs-string">               </span>|<span class="hljs-string">            </span>|<br>    ∨               ∨               ∨            ∨<br>------------------------------------------------------<br>|<span class="hljs-string">                       网桥                          </span>|<br>------------------------------------------------------<br></code></pre></td></tr></table></figure><p>实践：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先创建 bridge br0</span><br>ip l a br0 type bridge<br>ip l s br0 up <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以查看一下创建出来的网桥</span><br>ip link show type bridge<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后我们在之前的基础上，再创建两个 namespace</span><br>ip netns add ns3<br>ip netns add ns4<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后创建 4 对新的 veth-pair</span><br>ip l a veth2 type veth peer name br-veth2<br>ip l a veth3 type veth peer name br-veth3<br>ip l a veth4 type veth peer name br-veth4<br>ip l a veth5 type veth peer name br-veth5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将这 4 对 veth-pair 加入到 ns 和 br0</span><br>ip l s veth2 netns ns1<br>ip l s br-veth2 master br0<br>ip l s br-veth2 up<br><br>ip l s veth3 netns ns2<br>ip l s br-veth3 master br0<br>ip l s br-veth3 up<br><br>ip l s veth4 netns ns3<br>ip l s br-veth4 master br0<br>ip l s br-veth4 up<br><br>ip l s veth5 netns ns4<br>ip l s br-veth5 master br0<br>ip l s br-veth5 up<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">给 veth 配置 IP 并启用</span><br>ip netns exec ns1 ip a a 10.1.2.2/24 dev veth2<br>ip netns exec ns1 ip l s veth2 up<br><br>ip netns exec ns2 ip a a 10.1.2.3/24 dev veth3<br>ip netns exec ns2 ip l s veth3 up<br><br>ip netns exec ns3 ip a a 10.1.2.4/24 dev veth4<br>ip netns exec ns3 ip l s veth4 up<br><br>ip netns exec ns4 ip a a 10.1.2.5/24 dev veth5<br>ip netns exec ns4 ip l s veth5 up<br></code></pre></td></tr></table></figure><p>同样的，我们也可以看一下各个 namespace 的网卡情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns1 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>5: veth0@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 4a:19:b1:f3:af:22 brd ff:ff:ff:ff:ff:ff link-netns ns2<br>    inet 10.1.1.2/24 scope global veth0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::4819:b1ff:fef3:af22/64 scope link<br>       valid_lft forever preferred_lft forever<br>12: veth2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 0e:24:20:80:09:97 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>    inet 10.1.2.2/24 scope global veth2<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::c24:20ff:fe80:997/64 scope link<br>       valid_lft forever preferred_lft forever<br>       <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ip netns <span class="hljs-built_in">exec</span> ns3 ip addr</span><br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>16: veth4@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link/ether 9e:84:97:27:44:c4 brd ff:ff:ff:ff:ff:ff link-netnsid 0<br>    inet 10.1.2.4/24 scope global veth4<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::9c84:97ff:fe27:44c4/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p>这里为了方便只查看了 ns1 和 ns3 这两个 namespace 的情况，因为 ns1 这个 namespace 是之前创建好的，在其基础上又插入了一个 Veth，所以有 veth0 和 veth2 两张网卡，而 ns3 是新创建的，所以只有 veth4 这一张网卡（lo 代表回环网卡，与本次实验无关，可以忽略）。</p><p>然后我们验证一下这几个 namespace 之间的连通情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip netns exec ns4 ping 10.1.2.2<br>ip netns exec ns4 ping 10.1.2.3<br>ip netns exec ns4 ping 10.1.2.4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">.... 就不全部测试了，测过的都可以 ping 通</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">https://www.cnblogs.com/bakari/p/10613710.html</a></p><p><a href="https://segmentfault.com/a/1190000009251098">https://segmentfault.com/a/1190000009251098</a></p><p><a href="https://mp.weixin.qq.com/s/dP12ptPlsxS35qPr0mDjCw">https://mp.weixin.qq.com/s/dP12ptPlsxS35qPr0mDjCw</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个 EOF 引发的低级错误</title>
    <link href="/2022/09/06/EOF_cuo_wu/"/>
    <url>/2022/09/06/EOF_cuo_wu/</url>
    
    <content type="html"><![CDATA[<p>今天更新了一下之前写的 tcp server，结果测试的时候发现了一个十分诡异的 BUG：客户端这边发送完数据，进程都已经退出了，但是服务端却依然源源不断的接收到客户端发来的数据，而且数据包的大小都为 0，这个 BUG 花费了我大半天的时间，终于找到了问题所在，特此记录。</p><p>问题关键就是对 io.EOF 的判断逻辑出了问题，以下是部分代码：</p><p>错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> UnpackHeader(d *DataPack) (*Message, <span class="hljs-type">error</span>) &#123;<br>head := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, d.HeadSize())<br><br>_, err := io.ReadFull(t.socketConn, head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>body, err := d.UnPack(head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> Receive() (*Message, <span class="hljs-type">error</span>) &#123;<br>pack := NewDataPack()<br>header, err := t.UnpackHeader(pack)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>dataLen := header.dataLen<br>msgType := header.typ<br>&#125;<br></code></pre></td></tr></table></figure><p><code>UnpackHeader</code> 这里的判断逻辑是 <code>if err != nil &amp;&amp; err != io.EOF</code>，问题就出在这里，如果 err 是 EOF，那么就不满足条件，也就不会 return err，而是继续走下面的代码，最终的 error return 为 nil。EOF 代表已经无数据可读了，所以返回的 Message 为空，没有读到任何东西。</p><p>然后 <code>Receive</code> 又调用了 <code>UnpackHeader</code>，因为 err &#x3D;&#x3D; nil，所以继续执行到 <code>dataLen := header.dataLen</code> 这里，又因为 EOF 导致 dataLen &#x3D;&#x3D; 0，这便是为何调试时发现数据包大小为 0 的原因。</p><p>而因为没有对 EOF 错误进行 return error，导致 Receive 这边一直返回空包，而我又在另一个函数 Handle 中通过一个死循环来持续调用 Receive，这就导致服务端可以源源不断的接收到客户端发来的数据，实际上这是因为没有对 EOF 进行合理的处理。</p><p>正确：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> UnpackHeader(d *DataPack) (*Message, <span class="hljs-type">error</span>) &#123;<br>head := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, d.HeadSize())<br><br>_, err := io.ReadFull(t.socketConn, head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>body, err := d.UnPack(head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只需要将判断逻辑修改一下即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br></code></pre></td></tr></table></figure><p>只要产生了错误就必须 return err，如果不是 EOF 的话要额外输出错误信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个 go nil pointer 错误记录</title>
    <link href="/2022/09/05/go_nil_pointer/"/>
    <url>/2022/09/05/go_nil_pointer/</url>
    
    <content type="html"><![CDATA[<p>看看下面这段代码的运行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;listen error: %v&quot;</span>, err.Error())<br>    _ = lis<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, format, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(format, msg))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>细心眼尖的你一定立马想到了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run nil_pointer.go</span><br>panic: runtime error: invalid memory address or nil pointer dereference<br>[signal SIGSEGV: segmentation violation code=0x2 addr=0x18 pc=0x100412238]<br><br>goroutine 1 [running]:<br>main.main()<br>/Users/zenghao/pj/justtest/nil_pointer.go:10 +0x38<br>exit status 2<br></code></pre></td></tr></table></figure><p>没错，就是一个普通的空指针错误，发生在 err.Error() 这里，如果 net.Listen 没有产生错误，那么 err &#x3D;&#x3D; nil，err.Error() 自然就会产生空指针异常了。但这个错误居然困扰了许久，虽然 panic 提示了代码行数，但是我一开始硬是没注意到 err.Error() 这里，加上 [signal SIGSEGV: segmentation violation code&#x3D;0x2 addr&#x3D;0x18 pc&#x3D;0x100412238] 这里混淆了我（因为之前跑过一个项目，也是运行就会 panic，提示的也是 SIG 之类的，但是这个项目 panic 的原因是有些包没有适配当时最新的 go1.17 版本，需要使用 go get -u 来更新部分包，即可解决问题），导致我朝着一个错误的方向解决问题。</p><p>问题到这里就算结束了，但是这种低级错误耽误了许多时间，我在想有没有什么工具可以对这种空指针错误进行检测呢？</p><p>使用 go vet：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> vet nil_pointer.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>没有输出任何信息</p><p>此外，GoLand 和 Vscode 也没有任何 warning 警告</p><p>使用 golangci-lint：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ golangci-lint run nil_pointer.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p>也没有输出任何信息</p><p>暂时没有找到可以检测这类问题的工具，虽然 Goland 可以对部分潜在的 nil pointer 问题进行警告，但是在这篇文章的代码中无效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 粘包/拆包问题</title>
    <link href="/2022/09/05/tcp_zhan_bao/"/>
    <url>/2022/09/05/tcp_zhan_bao/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TCP 的粘包拆包也属于老生常谈的问题了，虽然不少人都鄙夷的认为粘包是一个错误的说法，因为 TCP 是面向流传输的，但无论如何，粘包这个词都已经算得上是深入人心了。</p><p>TCP 的流式传输，简单的说就是没有消息边界记录，比如发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包发送(把发送端的缓冲区填满一次性发送。这样接收端收到的整个数据中其实是包含了多个小包，需要将数据拆分，还原成小包，从而才能进行处理，但因为没有消息边界记录，所以如何还原就成了一个问题。</p><p>在上面的例子中，TCP 将多次写入缓冲区的数据包合并为一次发送，就是 <strong>粘包</strong> 问题。</p><p>此外 TCP 还存在 <strong>拆包</strong> 问题，就是发送包的大小超过了缓冲区大小或者 MSS，比如发送端使用 protobuf 编码数据，然后使用 TCP 进行传输，这个编码的数据大小是 10000 byte，超过了 TCP 的发送缓存区大小 5000 byte（随便写的数字，仅用作举例），一次性无法全部发送，所以便会发生拆包，分两次发送，接收端这边第一次只收到了 5000 byte 数据，因为数据使用 protobuf 编码的，不同于文本消息，必须要拿到不多不少刚刚好的 10000 byte 大小的数据，才能反序列化出原始的数据，但因为 TCP 不记录消息长度，所以接收端这边无法知道到底要拿多少数据，这也是一个问题。</p><p>可以看到发生粘包和拆包的原因都是因为 TCP 不记录消息边界（也就是消息长度），既然 TCP 自身不记录，那就只能用户自己解决了，比如设计一个协议，让报文内容由消息头 + 消息两部分构成，在消息头中记录消息的长度，然后将消息头 + 消息本体作为一个整体发送，（这里的消息头是需要定长的，比如固定为 10 byte），接收端这边根据协议定义，去读取这个定长的消息头，从里面获取到消息本体的长度，知道了消息的长度以后，上面的问题就可以很好的解决了。</p><h1 id="拆包演示程序"><a href="#拆包演示程序" class="headerlink" title="拆包演示程序"></a>拆包演示程序</h1><p>下面先使用一个错误的 protobuf 的示例程序来演示一下拆包问题：</p><h2 id="server-端"><a href="#server-端" class="headerlink" title="server 端"></a>server 端</h2><p>server 负责读取报文，然后通过 proto.Unmarshal 还原出原始的数据。其中将缓冲区大小设置为了 client 要发送的大小 279896。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;protobuftest/pb/pbfile&quot;</span><br><br><span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;listen error: %v&quot;</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// b := make([]byte, 1024)// proto: cannot parse invalid wire-format data</span><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">279896</span>)<br>n, err := conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;read %v bytes\n&quot;</span>, n)<br><br><span class="hljs-keyword">var</span> m pbfile.Message<br><span class="hljs-keyword">if</span> err := proto.Unmarshal(b, &amp;m); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(m.Uid)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, format <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(format, err.Error()))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h2><p>client 使用 protobuf 序列化 struct pbfile.Message，然后使用 tcp 发送，这个 struct 中有一个 Data 字段，这里我将一张 140k 的图片读取出来，然后将 Data 字段设置为读取出的 []byte 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span><br><span class="hljs-string">&quot;google.golang.org/protobuf/types/known/wrapperspb&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;protobuftest/pb/pbfile&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>home := os.Getenv(<span class="hljs-string">&quot;HOME&quot;</span>)<br>fp := filepath.Join(home, <span class="hljs-string">&quot;Downloads/jDKUARa.jpg&quot;</span>)<br><br>f, err := os.Open(fp)<br>assert(err, <span class="hljs-string">&quot;open file error: %v&quot;</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br><br>file, err := os.ReadFile(fp)<br>assert(err, <span class="hljs-string">&quot;read file error: %v&quot;</span>)<br><br>msg := pbfile.Message&#123;<br>Uid:         wrapperspb.UInt64(<span class="hljs-number">10086</span>),<br>Data:        file,<br>MessageType: wrapperspb.String(<span class="hljs-string">&quot;image&quot;</span>),<br>&#125;<br><br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;dial error: %v&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>b, err := proto.Marshal(&amp;msg)<br>assert(err, <span class="hljs-string">&quot;proto marshal error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;proto marshal size: %v\n&quot;</span>, <span class="hljs-built_in">len</span>(b))<br><br>n, err := conn.Write(b)<br>assert(err, <span class="hljs-string">&quot;write to conn error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;write %v bytes\n&quot;</span>, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, format <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(format, err.Error()))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax=<span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;/pbfile&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/wrappers.proto&quot;</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Message</span> &#123;<br>  google.protobuf.UInt64Value uid = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">bytes</span> data = <span class="hljs-number">2</span>;<br>  google.protobuf.StringValue messageType = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>分别运行 server 和 client，输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">client</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./client</span><br>proto marshal size: 279896<br>write 279896 bytes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./server</span>          <br>read 81660 bytes<br>proto: cannot parse invalid wire-format data<br></code></pre></td></tr></table></figure><p>可以看到 client 这边发送了 279896 字节的数据，但是 server 这边只读到了 81660 字节，因为 protobuf 使用二进制编码，所以如果数据不完整会无法解析，从而报错：<code>proto: cannot parse invalid wire-format data</code></p><p>部分测试结果可以印证这一点，只要读取的长度不等于 279896 就会解析失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">read 97992 bytes<br>proto: cannot parse invalid wire-format data<br>read 81660 bytes<br>proto: cannot parse invalid wire-format data<br>read 130656 bytes<br>proto: cannot parse invalid wire-format data<br></code></pre></td></tr></table></figure><p>但是有时候又是正常的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">client</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./client</span><br>proto marshal size: 279896<br>write 279896 bytes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">read</span> 279896 bytes</span><br>value:10086<br>EOF<br></code></pre></td></tr></table></figure><blockquote><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>这里有个疑问，既然 server 的缓冲区已经将长度设置为了 279896，刚好等于 client 要发送的包的大小，但是为什么会出现没有读取满的情况？</p><p>可能是因为：发送方虽然发送了 279896 长度的数据，但是这些数据不会直接通过网络传输，而是先添加到 socket 发送缓冲区，至于什么时候发送，发送多少，都是由系统内核来决定的，所以会出现诸如上面这种没有完全发完的情况，偶尔又会出现全部发送的情况。</p></blockquote><h1 id="粘包演示程序"><a href="#粘包演示程序" class="headerlink" title="粘包演示程序"></a>粘包演示程序</h1><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>服务端试图从收到的包中反序列化出原始数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;listen error: %v&quot;</span>)<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := lis.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>n, err := conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;read %v bytes\n&quot;</span>, n)<br><br><span class="hljs-keyword">var</span> m pbfile.Message<br><span class="hljs-keyword">if</span> err := proto.Unmarshal(b, &amp;m); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(m.Uid)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>客户端发送 10 条消息，每条消息设置不同的 Uid，且序列化的对象都比较小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:7788&quot;</span>)<br>assert(err, <span class="hljs-string">&quot;dial error: %v&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>  <span class="hljs-keyword">var</span> totalN <span class="hljs-type">int</span> <br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>msg := pbfile.Message&#123;<br>Uid:         wrapperspb.UInt64(<span class="hljs-type">uint64</span>(i)),<br>Data:        []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>),<br>MessageType: wrapperspb.String(<span class="hljs-string">&quot;text&quot;</span>),<br>&#125;<br><br>b, err := proto.Marshal(&amp;msg)<br>assert(err, <span class="hljs-string">&quot;proto marshal error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;proto marshal size: %v\n&quot;</span>, <span class="hljs-built_in">len</span>(b))<br><br>n, err := conn.Write(b)<br>    totalN += n<br>assert(err, <span class="hljs-string">&quot;write to conn error: %v&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;write %v bytes\n&quot;</span>, n)<br>&#125;<br>  fmt.Printf(<span class="hljs-string">&quot;total write %v bytes\n&quot;</span>, totalN)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run server.go</span><br>read 74 bytes<br>proto: cannot parse invalid wire-format data<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run client.go</span>                                           <br>proto marshal size: 17<br>write 17 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>proto marshal size: 19<br>write 19 bytes<br>total write 188 bytes<br></code></pre></td></tr></table></figure><p>可以看到客户端这边每次发送的报文长度基本都是 19 ，只有第一次是 17，一共发送了 188 bytes 的数据，而服务端这边，第一次从连接中接收到的数据大小是 74 bytes，这显然是有几个包 “粘” 在了一起，最终显然也是无法反序列化成功的。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>我写了一个简单的 tcp server 库，里面解决了上面的粘包拆包问题，思路是自定义一个协议，协议的头部记录了数据的长度，然后接收端在收到报文后，先解析出头部，获取到数据的长度，在进行下一步读取。为了保证读满，可以使用 io.ReadFull 这个函数，大致的读取逻辑如下：</p><p>首先是读取协议头部的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> UnpackHeader(d *DataPack) (*Message, <span class="hljs-type">error</span>) &#123;<br>head := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, d.HeadSize())<br><br>_, err := io.ReadFull(t.socketConn, head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err != io.EOF &#123;<br>log.Println(<span class="hljs-string">&quot;read head error: &quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>body, err := d.UnPack(head)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后是读取数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TCPConn)</span></span> Receive() (*Message, <span class="hljs-type">error</span>) &#123;<br>pack := NewDataPack()<br>header, err := t.UnpackHeader(pack)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>  &#125;<br>  <br>  dataLen := header.dataLen<br>  <br>  <span class="hljs-keyword">var</span> (<br>tmpBuf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4096</span>)<br>needN  = dataLen <span class="hljs-comment">// 还剩多少需要读取</span><br>readN  <span class="hljs-type">int64</span>     <span class="hljs-comment">// 总共需要读取多少</span><br>)<br>  <br>  <span class="hljs-keyword">for</span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, needN)<br><span class="hljs-comment">// 必须读满 len(buf)，否则返回一个 err</span><br>n, err := io.ReadFull(t.socketConn, buf)<br><br><span class="hljs-comment">// 没有读满 buf</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 虽然没读满，但是返回了 EOF 错误，说明没有数据可读了，可能是对方已经断开了连接，</span><br><span class="hljs-comment">// 此时就不需要再尝试读取了</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 将当前读的这部分添加到 tmp 中，暂时保存</span><br>tmpBuf = <span class="hljs-built_in">append</span>(tmpBuf, buf[:n]...)<br>needN -= <span class="hljs-type">uint64</span>(n) <span class="hljs-comment">// 更新 needN 的值</span><br>readN += <span class="hljs-type">int64</span>(n)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 读满了</span><br>tmpBuf = <span class="hljs-built_in">append</span>(tmpBuf, buf...)<br>readN += <span class="hljs-type">int64</span>(n)<br><br><span class="hljs-keyword">if</span> readN == <span class="hljs-type">int64</span>(dataLen) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>m := NewMessage(tmpBuf, msgType)<br><span class="hljs-keyword">return</span> m, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试了前面的粘包拆包代码，发现结果都正确，说明可以解决这类问题，但是目前测试的依据较少，也可能不一定准确。</p><p>附：</p><p><a href="https://github.com/autsu/revrespct">项目地址</a></p><p><a href="https://github.com/autsu/revrespct/tree/master/testdata">用 protobuf 来进行粘包拆包的测试代码</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll 打断/唤醒</title>
    <link href="/2022/09/02/epoll_zhong_duan/"/>
    <url>/2022/09/02/epoll_zhong_duan/</url>
    
    <content type="html"><![CDATA[<p>写这篇文章是因为最近在看 go netpoll 的源码，里面有一部分代码是创建一个管道，一开始没有搞懂用意何在，后来查阅了网上的文章，有说法是这个管道是为了打断 epoll_wait 的等待，将这个管道的 fd 添加到 epoll 中，如果想主动打断 epoll_wait，那么就往管道中写入数据，然后在 epoll_wait 处就会产生事件，终止阻塞。</p><p>搜索 epoll 打断，发现资料非常少，go netpoll 这部分的源码讲解也比较少（主要是 netpollBreak 这个函数），这导致我不明白为什么需要打断 epoll，我的猜测是：可能是为了避免让某条线程持续阻塞在 epoll_wait，这样会导致这条线程比较闲，如果当前系统的任务比较繁忙，为了保证性能就需要让每条线程都 “忙” 起来，就需要主动打断这些阻塞在 epoll_wait 的线程，先给它们分配一些任务，让它们忙起来。</p><p>在一篇博客上还看到了一种说法：</p><blockquote><h3 id="和poll-x2F-epoll搭配使用，一个消费者多生产者场景"><a href="#和poll-x2F-epoll搭配使用，一个消费者多生产者场景" class="headerlink" title="和poll&#x2F;epoll搭配使用，一个消费者多生产者场景"></a>和poll&#x2F;epoll搭配使用，一个消费者多生产者场景</h3><p>实际这种使用场景会多一点，生产者是多个线程，可以通过 eventfd_write 唤醒消费者。消费者是单个线程，后台 loop 处理。使用 epoll 监听 eventfd 的可读事件，这样能做到一旦有请求入队，消费者就立马唤醒处理。所以这里可以总结出 eventfd 在实际场景中可以结合业务，做一个事件通知的通信机制，非常巧妙，而不用轮询这种耗时耗 cpu 的机制。这块就不详细写示例了。</p></blockquote><p>感觉说的挺有道理的，这种用 epoll 唤醒来描述更为合适，而不是 epoll 打断，个人的见解：eventfd 其实和 socket 类似，只不过是用于同一台机器上的一种进程间通信机制，而 socket 因为是网络传输所以可以跨机器。</p><h1 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h1><p>创建一个匿名管道，用 epoll 监听管道的读端，然后 fork 一个子进程，子进程在 sleep 几秒后会向管道写入数据，然后父进程的 epoll_wait 就会被触发事件，进而跳出死循环，执行其他任务（这里逻辑可能不太合理）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVENTS_SIZE 128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">1024</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event1</span>, <span class="hljs-title">event2</span>, <span class="hljs-title">events</span>[<span class="hljs-title">EVENTS_SIZE</span>];</span><br><span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>event1.events = EPOLLIN;<br> event1.data.fd = STDIN_FILENO;<br><span class="hljs-type">int</span> ret = epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event1);<br><span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span> ) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_ctl error: %s\n&quot;</span>, strerror(errno));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (pipe(pipefd) == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br><br><span class="hljs-comment">// 注意要先调用 pipe() 创建管道，再添加到 epoll，否则报错 Bad file descriptor</span><br>event2.events = EPOLLIN;<br>event2.data.fd = pipefd[<span class="hljs-number">0</span>];<br>ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipefd[<span class="hljs-number">0</span>], &amp;event2); <span class="hljs-comment">// 将管道的读端添加到 epoll 监听队列</span><br><span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_ctl error: %s\n&quot;</span>, strerror(errno));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">pid_t</span> cpid = fork();<br><br><span class="hljs-keyword">switch</span> (cpid) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-comment">// child</span><br><span class="hljs-comment">// 发现一个新坑：如果使用 printf 进行调试，必须添加 \n 换行符，否则终端不会输出</span><br><span class="hljs-comment">// 搞得我还以为子进程没有执行</span><br><span class="hljs-comment">// printf(&quot;child in\n&quot;);</span><br>close(pipefd[<span class="hljs-number">0</span>]);<span class="hljs-comment">// 关闭管道的读端，因为子进程只负责向管道写入数据</span><br>sleep(<span class="hljs-number">3</span>);<br><span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;break&quot;</span>;<br>write(pipefd[<span class="hljs-number">1</span>], s, <span class="hljs-built_in">strlen</span>(s));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child send sign to pipe\n&quot;</span>);<br>close(pipefd[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 必须要写这句，不然会出现程序已经退出（终端输出完毕，已经显示新行），</span><br><span class="hljs-comment">// 但是进程依然在执行的迷惑情况（终端输入全部会被当成 epoll 事件）</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// parent</span><br>close(pipefd[<span class="hljs-number">1</span>]);<span class="hljs-comment">// 关闭管道的写端，因为父进程只负责从管道中读取</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll is wait\n&quot;</span>);<br><span class="hljs-type">int</span> n = epoll_wait(epfd, events, EVENTS_SIZE, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 无限阻塞</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-comment">//printf(&quot;event fd: %d\n&quot;, events[i].data.fd);</span><br><span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>read(events[i].data.fd, buf, BUF_SIZE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read from stdin: %s\n&quot;</span>, buf);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].data.fd == pipefd[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe break epoll_wait!\n&quot;</span>);<br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>read(events[i].data.fd, buf, BUF_SIZE);<span class="hljs-comment">// 消费掉事件</span><br>close(pipefd[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">goto</span> STOP_WAIT;<br>&#125;<br>&#125;<br>&#125;<br>STOP_WAIT:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;do something\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">clang pipe_break_epoll.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span><br>epoll is wait<br>pipe break epoll_wait!<br>do something<br>child send sign to pipe<br></code></pre></td></tr></table></figure><p>输出顺序有点问题，但是无伤大雅</p><h1 id="使用-eventfd"><a href="#使用-eventfd" class="headerlink" title="使用 eventfd"></a>使用 eventfd</h1>]]></content>
    
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>孤儿进程与僵尸进程</title>
    <link href="/2022/08/31/gu_er_jin_cheng_he_jiang_shi_jin_cheng/"/>
    <url>/2022/08/31/gu_er_jin_cheng_he_jiang_shi_jin_cheng/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为 1 )所收养，并由 init 进程对它们完成状态收集工作。</p><p><strong>僵尸进程</strong>：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><p>unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号 the process ID,退出状态 the termination status of the process,运行时间 the amount of CPU time taken by the process等)。直到父进程通过 wait &#x2F; waitpid 来取时才释放。 但这样就导致了问题，<strong>如果进程不调用 wait &#x2F; waitpid 的话，</strong> <strong>那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</strong></p><p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。<strong>因此孤儿进程并不会有什么危害。</strong></p><p><strong>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</strong>这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p><p>僵尸进程危害场景：</p><p>例如有个进程，它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用 ps 命令查看的话，就会看到很多状态为 Z 的进程。 <strong>严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程</strong>。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是 <strong>把产生大量僵死进程的那个元凶枪毙掉</strong>（也就是通过 kill 发送 SIGTERM 或者 SIGKILL 信号啦）。<strong>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 init 进程接管，init 进程会 wait() 这些孤儿进程，释放它们占用的系统进程表中的资源</strong>，这样，这些已经僵死的孤儿进程就能瞑目而去了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="孤儿进程测试程序"><a href="#孤儿进程测试程序" class="headerlink" title="孤儿进程测试程序"></a>孤儿进程测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//创建一个进程</span><br>    pid = fork();<br>    <span class="hljs-comment">//创建失败</span><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//子进程</span><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am the child process.\n&quot;</span>);<br>        <span class="hljs-comment">//输出进程ID和父进程ID</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I will sleep five seconds.\n&quot;</span>);<br>        <span class="hljs-comment">//睡眠5s，保证父进程先退出</span><br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process is exited.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//父进程</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.\n&quot;</span>);<br>        <span class="hljs-comment">//父进程睡眠1s，保证子进程输出进程id</span><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is  exited.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致逻辑就是让子进程睡眠更长的时间，以达到比父进程后退出的效果，从而变成孤儿进程。</p><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span><br>I am father process.<br>I am the child process.<br>pid: 15625ppid:15618<br>I will sleep five seconds.<br>father process is  exited.<br>➜  justtest git:(master) ✗ pid: 15625ppid:1<br>child process is exited.<br></code></pre></td></tr></table></figure><p>从 <code>pid: 15625 ppid:1</code> 这里就可以看出子进程被 init 进程接管了（init 进程的 pid 为 1，pid 代表当前进程的 id，ppid 代表当前进程的父进程的 id）。</p><p>（<code>➜  justtest git:(master) ✗ pid: 15625ppid:1</code> 这一行是因为父进程退出后，终端会结束输出，变成待输入状态，所以会出现 <code>justtest git:(master) ✗</code> 这部分，但是等几秒后子进程又会输出 <code>pid: 15625ppid:1</code>，所以就变成了这样的显示效果。而且在输出了 <code>child process is exited.</code>  这句话之后终端会卡住，此时只需要按一下回车即可。）</p><h2 id="僵尸进程测试程序"><a href="#僵尸进程测试程序" class="headerlink" title="僵尸进程测试程序"></a>僵尸进程测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process.I am exiting.\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);<br>    <span class="hljs-comment">//等待子进程先退出</span><br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//输出进程信息</span><br>    system(<span class="hljs-string">&quot;ps -o pid,ppid,state,tty,command&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is exiting.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段程序让子进程先退出，同时不适用 wait 或者 waitpid 来回收。</p><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">./a.out<br>I am father process.I will sleep two seconds<br>I am child process.I am exiting.<br>  PID  PPID STAT TTY      COMMAND<br> 7766  7750 S+   ttys000  -zsh<br> 7771  7751 S    ttys001  -zsh<br>91947  7771 S+   ttys001  ./a.out<br>91956 91947 Z+   ttys001  (a.out) # 僵尸进程<br></code></pre></td></tr></table></figure><p>其中 STAT 为 Z+ 的就是僵尸进程</p><h2 id="僵尸进程测试2"><a href="#僵尸进程测试2" class="headerlink" title="僵尸进程测试2"></a>僵尸进程测试2</h2><p>父进程循环创建子进程，子进程退出，造成多个僵尸进程，程序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span>  pid;<br>    <span class="hljs-comment">//循环创建子进程</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am a child process.\nI am exiting.\n&quot;</span>);<br>            <span class="hljs-comment">//子进程退出，成为僵尸进程</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//父进程休眠20s继续创建子进程</span><br>            sleep(<span class="hljs-number">20</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/abaf1d3a8a58e0f3b3bcc8764c22728fc089faba/img/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%20.png"></p><h1 id="僵尸进程解决方法"><a href="#僵尸进程解决方法" class="headerlink" title="僵尸进程解决方法"></a>僵尸进程解决方法</h1><h2 id="fork-两次"><a href="#fork-两次" class="headerlink" title="fork 两次"></a>fork 两次</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span>  pid;<br>    <span class="hljs-comment">//创建第一个子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//第一个子进程</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//子进程再创建子进程（第二个子进程）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am the first child process.pid:%d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 让第一个子进程退出</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;first procee is exited.\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//第二个子进程</span><br>        <span class="hljs-comment">//睡眠3s保证第一个子进程退出，这样第二个子进程的父亲就是init进程里</span><br>        sleep(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am the second child process.pid: %d\tppid:%d\n&quot;</span>,getpid(),getppid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">//父进程处理第一个子进程退出</span><br>    <span class="hljs-keyword">if</span> (waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) != pid)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;waitepid error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大致思路就是先创建一个子进程，再让这个子进程再创建一个子进程（代称为孙子进程），然后让子进程立马退出，这样孙子进程就会被 init 接管。（使用孙子进程来执行任务）</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。测试程序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sig_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-comment">//创建捕捉子进程退出信号</span><br>    signal(SIGCHLD,sig_child);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;fork error:&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child process,pid id %d.I am exiting.\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am father process.I will sleep two seconds\n&quot;</span>);<br>    <span class="hljs-comment">//等待子进程先退出</span><br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//输出进程信息</span><br>    system(<span class="hljs-string">&quot;ps -o pid,ppid,state,tty,command&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father process is exiting.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sig_child</span><span class="hljs-params">(<span class="hljs-type">int</span> signo)</span><br>&#123;<br>     <span class="hljs-type">pid_t</span>        pid;<br>     <span class="hljs-type">int</span>        stat;<br>     <span class="hljs-comment">//处理僵尸进程</span><br>     <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;stat, WNOHANG)) &gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d terminated.\n&quot;</span>, pid);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何保证缓存和数据库的一致性</title>
    <link href="/2022/08/27/huan_cun_yi_zhi_xing/"/>
    <url>/2022/08/27/huan_cun_yi_zhi_xing/</url>
    
    <content type="html"><![CDATA[<p>一道高频面试题：如何保证缓存和数据库的一致性</p><h1 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h1><p>存在的问题：</p><ol><li><p>更新数据库成功，更新缓存失败</p></li><li><p>并发情况下可能会存在问题，如下（纵轴代表时间线）：</p><table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">更新 DB x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新 DB，x &#x3D; 2</td></tr><tr><td align="center"></td><td align="center">更新缓存，x &#x3D; 2</td></tr><tr><td align="center">更新缓存，x &#x3D; 1</td><td align="center"></td></tr></tbody></table><p>可以看到因为并发操作导致 A 把 B 的更新缓存结果给覆盖了，最终使得数据库结果（x &#x3D; 2）和缓存结果（x &#x3D; 1）不一致</p></li></ol><h1 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h1><p>存在的问题：</p><p>和 <strong>先更新数据库，再更新</strong> 类似，这里就不再赘述了。</p><h1 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h1><p>存在的问题：</p><ol><li><p>删除缓存成功，更新数据库失败</p></li><li><p>并发情况下可能会存在问题，如下（纵轴代表时间线）：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">更新 db，x &#x3D; 2</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读缓存，x &#x3D; 1，但此时 db 中 x &#x3D; 2，不一致</td></tr></tbody></table></li></ol><h1 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h1><p>存在的问题：</p><ol><li>更新数据库成功，删除缓存失败</li><li>并发情况下可能会存在问题，如下（纵轴代表时间线）：<table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">更新 DB，x &#x3D; 2</td></tr><tr><td align="center"></td><td align="center">删除缓存</td></tr><tr><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr></tbody></table></li></ol><p>此时数据库中的 x &#x3D; 2，但缓存中 x &#x3D; 1，存在不一致</p><p>但是这种情况发生的概率非常低，因为缓存的写入速度大概率是要快于数据库的写入速度的（上表中就是因为更新数据库操作快于缓存写入操作，才导致最终不一致）</p><h1 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h1><p>基于 <strong>先删缓存，再更新数据库</strong></p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td><td align="center"></td></tr><tr><td align="center">更新 db，x &#x3D; 2（此时缓存和 db 不一致）</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">延迟一会，删除缓存</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">读缓存，miss，从 db 读取并写入缓存，此时一致</td></tr></tbody></table><p>为什么要延迟一会？</p><p>如果不延迟而是更新 db 后立马删除，可能存在下面的情况：</p><table><thead><tr><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">删缓存</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">读缓存，miss</td></tr><tr><td align="center"></td><td align="center">读 DB，x &#x3D; 1</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center">更新 db，x &#x3D; 2</td><td align="center"></td></tr><tr><td align="center">立马删除缓存</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">写入缓存，x &#x3D; 1</td></tr></tbody></table><p>最终 db 中的 x &#x3D; 2，而缓存中的 x &#x3D; 1，二者又不一致了。如果让 A 延迟一会，等到 B 写完缓存后再删，就不会出现上面的问题了。</p><p>但问题来了，需要延迟多长时间才能达到前面所说的效果呢？毕竟 B 什么时候能写完缓存可是不可预料的，而且如果延迟时间设置的过长，也会导致系统的延迟变高。</p>]]></content>
    
    
    
    <tags>
      
      <tag>缓存</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题收集 1</title>
    <link href="/2022/08/18/mian_shi_ti_shou_ji1/"/>
    <url>/2022/08/18/mian_shi_ti_shou_ji1/</url>
    
    <content type="html"><![CDATA[<h1 id="Go相关"><a href="#Go相关" class="headerlink" title="Go相关"></a>Go相关</h1><h2 id="map、channel、slice-的底层实现"><a href="#map、channel、slice-的底层实现" class="headerlink" title="map、channel、slice 的底层实现"></a>map、channel、slice 的底层实现</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 使用的是拉链法，用哈希桶来保存键值对，每个桶可以保存 8 个键值对，它会用哈希算法计算出 key 的 hash 值，然后用这个哈希值的高 8 位作为 tophash，用于在一个桶中区别出 key，然后桶的数量是 2^b ，用低 b 位来决定这个 key 放到哪个桶。每个桶还会连接一个溢出桶，如果一个桶已经满了，但是依然有 key 落入到这个桶，那么就会将其放到溢出桶中。</p><p>map 的默认负载因子是 6.5，负载因子表示的是当前键值对的数量 &#x2F; 当前桶的数量，如果 map 的负载因子达到了 6.5，那么就说明此时可能所有桶都快装满了，如果再添加键值对，大概率会放到溢出桶中，所以此时就需要进行扩容了，对应的扩容策略是：创建数量是之前桶的 2 倍的新桶，然后将旧桶中的值迁移到新桶中（迁移的策略是怎样的？rehash），还有一种情况是溢出桶的数量过多，可能的原因是键值对数量少，但过于分散，导致桶的数量多，解决办法是创建同样数量的新桶，将旧桶中的数据迁移到这些新桶中，使整体键值对的排布更紧凑。</p><p>此外 go map 扩容采用的渐进式扩容，当执行插入、更新、删除操作时进行小部分扩容，而不是一次性将所有桶进行迁移，这样可以减少搬迁操作对性能的影响。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel 底层主要由一个发送阻塞队列和一个接收阻塞队列，以及一把互斥锁组成，发送阻塞队列存储的是因为发送操作而被阻塞的 goroutine，接收阻塞队列同理，这里面存储的都是被挂起的 goroutine，当执行发送操作时，会先检查接收阻塞队列里有没有值，有的话从队头取出，并将这个 goroutine 唤醒，并将数据拷贝给它，执行接收操作同理。互斥锁用来保证 chan 的线程安全。此外如果是有缓冲的 chan，还会存在一个环形数组，</p><h2 id="sync-map、sync-pool、sync-Once的原理"><a href="#sync-map、sync-pool、sync-Once的原理" class="headerlink" title="sync.map、sync.pool、sync.Once的原理"></a>sync.map、sync.pool、sync.Once的原理</h2><h2 id="GC的过程、写屏障的含义及作用"><a href="#GC的过程、写屏障的含义及作用" class="headerlink" title="GC的过程、写屏障的含义及作用"></a>GC的过程、写屏障的含义及作用</h2><h2 id="GMP-模型，触发-Goroutine-切换的原因有哪些？for-死循环会怎么样？全局-goroutine-里面存储什么？"><a href="#GMP-模型，触发-Goroutine-切换的原因有哪些？for-死循环会怎么样？全局-goroutine-里面存储什么？" class="headerlink" title="GMP 模型，触发 Goroutine 切换的原因有哪些？for 死循环会怎么样？全局 goroutine 里面存储什么？"></a>GMP 模型，触发 Goroutine 切换的原因有哪些？for 死循环会怎么样？全局 goroutine 里面存储什么？</h2><h2 id="interface-的底层实现，怎么判空？"><a href="#interface-的底层实现，怎么判空？" class="headerlink" title="interface 的底层实现，怎么判空？"></a>interface 的底层实现，怎么判空？</h2><h2 id="reflect-的使用"><a href="#reflect-的使用" class="headerlink" title="reflect 的使用"></a>reflect 的使用</h2><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><h2 id="context的使用"><a href="#context的使用" class="headerlink" title="context的使用"></a>context的使用</h2><h2 id="go-性能问题的定位过程（pprof的使用）"><a href="#go-性能问题的定位过程（pprof的使用）" class="headerlink" title="go 性能问题的定位过程（pprof的使用）"></a>go 性能问题的定位过程（pprof的使用）</h2><h2 id="协程池的使用"><a href="#协程池的使用" class="headerlink" title="协程池的使用"></a>协程池的使用</h2><h1 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h1><h2 id="redis的数据类型以及日常的应用"><a href="#redis的数据类型以及日常的应用" class="headerlink" title="redis的数据类型以及日常的应用"></a>redis的数据类型以及日常的应用</h2><ul><li>string 字符串类型</li><li>hashmap 哈希表</li><li>list 双向链表</li><li>set 去重集合</li><li>zset 排序 set</li></ul><h2 id="redis的发布-x2F-订阅的原理"><a href="#redis的发布-x2F-订阅的原理" class="headerlink" title="redis的发布&#x2F;订阅的原理"></a>redis的发布&#x2F;订阅的原理</h2><h2 id="zset的底层实现"><a href="#zset的底层实现" class="headerlink" title="zset的底层实现"></a>zset的底层实现</h2><p>zset 底层使用跳表 + 哈希表实现，</p><h2 id="数据缓存过期策略"><a href="#数据缓存过期策略" class="headerlink" title="数据缓存过期策略"></a>数据缓存过期策略</h2><h2 id="redis的部署模式"><a href="#redis的部署模式" class="headerlink" title="redis的部署模式"></a>redis的部署模式</h2><h2 id="redis为什么速度比较快"><a href="#redis为什么速度比较快" class="headerlink" title="redis为什么速度比较快"></a>redis为什么速度比较快</h2><h2 id="reids的大key、热key的处理"><a href="#reids的大key、热key的处理" class="headerlink" title="reids的大key、热key的处理"></a>reids的大key、热key的处理</h2><h2 id="如何实现分布式锁的"><a href="#如何实现分布式锁的" class="headerlink" title="如何实现分布式锁的"></a>如何实现分布式锁的</h2><h2 id="持久化策略及其对比"><a href="#持久化策略及其对比" class="headerlink" title="持久化策略及其对比"></a>持久化策略及其对比</h2><h2 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h2>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个类似的堆问题：leetcode 347 前 K 个高频元素 和 692. 前 K 个高频单词 </title>
    <link href="/2022/08/17/leetcode_347_and_692/"/>
    <url>/2022/08/17/leetcode_347_and_692/</url>
    
    <content type="html"><![CDATA[<p>首先先来看一下这两个问题：</p><h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><blockquote><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]</p><p>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><p>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p></blockquote><h1 id="692-前-K-个高频单词"><a href="#692-前-K-个高频单词" class="headerlink" title="692. 前 K 个高频单词"></a><a href="https://leetcode.cn/problems/top-k-frequent-words/">692. 前 K 个高频单词</a></h1><blockquote><p>给定一个单词列表 words 和一个整数 k ，返回前 k 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。</p><p>示例 1：</p><p>输入: words &#x3D; [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k &#x3D; 2<br>输出: [“i”, “love”]<br>解析: “i” 和 “love” 为出现次数最多的两个单词，均为2次。<br>    注意，按字母顺序 “i” 在 “love” 之前。</p><p>示例 2：</p><p>输入: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k &#x3D; 4<br>输出: [“the”, “is”, “sunny”, “day”]<br>解析: “the”, “is”, “sunny” 和 “day” 是出现次数最多的四个单词，<br>    出现次数依次为 4, 3, 2 和 1 次。</p><p>注意：</p><p>1 &lt;&#x3D; words.length &lt;&#x3D; 500<br>1 &lt;&#x3D; words[i] &lt;&#x3D; 10<br>words[i] 由小写英文字母组成。<br>k 的取值范围是 [1, 不同 words[i] 的数量]</p><p>进阶：尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。</p></blockquote><p>发现这两个问题有点类似（从名字都能看出来），只不过一个是从 int 数组里找，且结果对顺序没有要求（也就是说如果有两个元素出现的次数相同，那么不需要考虑它们的顺序问题，谁前谁后都可以）；另一个是从 string 数组里找，如果两个单词出现次数相同，那么需要按字典序进行排序，比如 a 和 b 都出现了 10 次，那么 a 要排在前面。</p><p>像这种 topk 问题，貌似都可以使用 <strong>堆</strong> 来解决，大致逻辑是：用最小堆来解决，建一个大小为 K 的堆，然后遍历数组，如果当前堆的元素不到 K 个，则直接将元素添加到堆中，如果堆的元素 &gt;&#x3D; K，此时堆顶保存的是整个堆中最小的元素，那么就比较当前元素是否小于堆顶，如果比堆顶还小，那么直接跳过，如果大于堆顶，那么可以将堆顶这个最小的元素 pop 掉，然后把 push 当前元素，因为堆会自动调整结构，所以 push 后堆顶依然是整个堆中最小的元素。当数组遍历完后，整个堆中保存的就是最大的 K 个元素。</p><p>以上只是大致的逻辑，但是相对来说还是比较通用的，只是比较的规则需要调整一下，按照上面的逻辑写一下这两道题。</p><h1 id="347-代码"><a href="#347-代码" class="headerlink" title="347 代码"></a>347 代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">int</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.mp[m.s[i]] &lt; m.mp[m.s[j]]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    h := &amp;myheap&#123;mp : <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        h.mp[v]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> h.mp &#123;<br>        <span class="hljs-keyword">if</span> h.Len() &lt; k &#123;<br>            heap.Push(h, v)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> h.mp[h.s[<span class="hljs-number">0</span>]] &lt; h.mp[v] &#123;<br>                heap.Pop(h)<br>                heap.Push(h, v)<br>            &#125; <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> h.s<br>&#125;<br></code></pre></td></tr></table></figure><p>（不得不吐槽一下 go 的容器库，实在太蛋疼了，没有泛型就算了，只提供一个最基本的 heap，需要自己实现  2 个接口 5 个方法，写起来实在繁琐，不像其他语言的优先队列用起来那么方便 ）</p><p>因为题目要求的是出现次数，所以需要用一个 map 来保存所有元素的出现次数，然后基于这个 map 来进行比较，这里需要注意的是 Less() 这个方法，它的实现逻辑是 <code>return m.mp[m.s[i]] &lt; m.mp[m.s[j]]</code>，也就是基于元素的出现次数来作为堆的比较依据；还有当前元素和堆顶的比较逻辑 <code>h.mp[h.s[0]] &lt; h.mp[v]</code> 也是基于元素的出现次数进行比较。除了这两点以外，基本和之前的通用逻辑相似。</p><h1 id="692-代码"><a href="#692-代码" class="headerlink" title="692 代码"></a>692 代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">string</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) (res <span class="hljs-type">bool</span>) &#123;<br>    o1 := m.s[i]<br>    o2 := m.s[j]<br>    m1 := m.mp[o1]<br>    m2 := m.mp[o2]<br>    <span class="hljs-keyword">if</span> m1 == m2 &#123;<br>        <span class="hljs-keyword">return</span> o1 &gt; o2 <span class="hljs-comment">// 如果出现频率相同，按字典序排列</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m1 &lt; m2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">string</span>) &#123;<br>    m := &amp;myheap&#123;<br>        mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>),<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> words &#123;<br>        m.mp[v]++<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        <span class="hljs-keyword">if</span> m.Len() &lt; k &#123;<br>            heap.Push(m, v)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (m.mp[v] == m.mp[m.s[<span class="hljs-number">0</span>]] &amp;&amp; v &lt; m.s[<span class="hljs-number">0</span>]) ||<br>                    m.mp[v] &gt; m.mp[m.s[<span class="hljs-number">0</span>]] &#123;<br>                heap.Pop(m)<br>                heap.Push(m, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>  res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, m.Len())<br>    <span class="hljs-keyword">for</span> i := k; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        res[i<span class="hljs-number">-1</span>] = heap.Pop(m).(<span class="hljs-type">string</span>)<br>    &#125;<br>    <span class="hljs-comment">//for i := 0; i &lt; k; i++ &#123;</span><br>    <span class="hljs-comment">//    res = append(res, heap.Pop(m).(string))</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">// 因为是小顶堆，堆顶为出现次数最小的，而题目要求次数多的排在前面，所以需要反转结果</span><br>    <span class="hljs-comment">//for i, j := 0, len(res)-1; i &lt; j; i++ &#123;</span><br>    <span class="hljs-comment">//    res[i], res[j] = res[j], res[i]</span><br>    <span class="hljs-comment">//    j--</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这道题相比 347 要麻烦一些，当时写的时候有一个比较迷的地方，就是 Less() 里的判断逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">o1 := m.s[i]<br>o2 := m.s[j]<br>m1 := m.mp[o1]<br>m2 := m.mp[o2]<br><br><span class="hljs-keyword">if</span> m1 == m2 &#123;<br>   <span class="hljs-keyword">return</span> o1 &gt; o2 <span class="hljs-comment">// 如果出现频率相同，按字典序排列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当时没搞懂为什么是 o1 &gt; o2，其实这里需要理解 go heap 的底层实现，Less() 是用来判断是否需要交换元素的，如果 Less 返回 true 才需要交换，也就是说如果 o1 &gt; o2（这是两个 string，且 o1 对应下标 i，o2 对应下标 j，这里假设 i 在前，j 在后），那么按照字典序排列，应该是小在前大在后（也就是 i 对应的元素要小于 j 对应的元素），所以需要进行交换，把小的 o2 换到前面，大的 o1 换到后面。</p><p>此外还有和堆顶比较的逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> (m.mp[v] == m.mp[m.s[<span class="hljs-number">0</span>]] &amp;&amp; v &lt; m.s[<span class="hljs-number">0</span>]) ||<br>                    m.mp[v] &gt; m.mp[m.s[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><p>这里为什么又是 <code>v &lt; m.s[0])</code> 呢？还是因为字典序。比如 [“i”,”love”,”leetcode”,”i”,”love”,”coding”]，k&#x3D;3 这个测试用例，最终的结果是[“i”,”love”,”coding”]，leetcode 和 coding 都出现了 1 次，所以要比较它们的字典序，而 coding &lt; leetcode，所以选择 coding 这个较小的。对应到堆，如果此时堆顶为 leetcode，现在要添加 coding 到堆中，需要判断逻辑为：在出现次数相同的情况下，如果当前元素的字典序小于堆顶，则 pop 堆顶，并 push 当前元素，这样才能让这个较小的元素入堆。</p><p>此外，因为题目要求返回的答案按单词出现频率由高到低排序，所以也不能像 347 那样，直接把堆中的元素返回，因为堆是不保证整体有序的，它只保证两个子节点都小于（大于）父节点，那如何让其有序呢？只需要不断 pop 即可，这里 go heap 的 pop 接口实现看起来有点诡异：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里难免会有点纳闷，我明明是要 pop 堆顶元素，不应该是移除 m.s[0] 才对吗？为什么这里要移除最后一个元素？这里又得看源码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(h Interface)</span></span> any &#123;<br>n := h.Len() - <span class="hljs-number">1</span><br>h.Swap(<span class="hljs-number">0</span>, n)<br>down(h, <span class="hljs-number">0</span>, n)<br><span class="hljs-keyword">return</span> h.Pop()<br>&#125;<br></code></pre></td></tr></table></figure><p>这下明白了，原来底层实现会将堆顶换到堆尾，所以才需要移除最后一个元素。同时也知道了，在交换堆顶到堆尾后，会从堆顶开始，执行 down 操作，调整整体的堆，让堆顶继续是整个堆中最小的元素（会忽略末尾元素，也就是刚刚被换到末尾的那个最小的元素），所以每次 pop 都是当前堆中最小的那个元素，进而保证有序。</p><p>代码里将 pop 的元素保存到一个 slice 里面，因为是小顶堆，所以 pop 的元素是由小到大的，<del>而这不满足题目 “由大到小” 的要求，需要将 slice 翻转，变成降序排列。其实这里用一个链表保存更合理，每次 pop 往链表头部添加即可，如果是 slice 的话，每次都往头部添加会导致开销特别大（频繁的分配拷贝，效率还不如整体翻转），但是题目给的定义是返回一个 slice，也只能这么做了（java 版本的题目定义返回的就是一个 linkedlist）。</del>  而题目要求的是由大到小，只需要先预分配 slice 的空间为堆的长度，然后从尾部向头部添加就可以了。</p><h1 id="另一种模板"><a href="#另一种模板" class="headerlink" title="另一种模板"></a>另一种模板</h1><p>看了一些题解，发现他们的写法略有不同，主要是在添加到堆的逻辑这里，不需要和堆顶元素进行比较，而是先 push 进去，如果发现长度大于 K 了，则执行 pop，感觉这种写法的代码会比较简洁明了容易理解，但是可能效率会低一些，像之前的逻辑会和堆顶进行比较，如果不满足某些条件会直接跳过，不执行任何操作，而这里的逻辑是遍历的每个元素都先无脑 push 进去，push 还需要执行堆的调整操作，所以相比叫而言会多做一些无用功。</p><h2 id="692"><a href="#692" class="headerlink" title="692"></a>692</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">string</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    o1 := m.s[i]<br>    o2 := m.s[j]<br>    m1 := m.mp[o1]<br>    m2 := m.mp[o2]<br>    <span class="hljs-keyword">if</span> m1 == m2 &#123;<br>        <span class="hljs-keyword">return</span> o1 &gt; o2 <span class="hljs-comment">// 如果出现频率相同，按字典序排列</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m1 &lt; m2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">string</span>) &#123;<br>    m := &amp;myheap&#123;<br>        mp: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>),<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> words &#123;<br>        m.mp[v]++<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        heap.Push(m, v)<br>        <span class="hljs-keyword">if</span> m.Len() &gt; k &#123;<br>            heap.Pop(m)<br>        &#125;<br>    &#125;<br>  <br>  res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, m.Len())<br>    <span class="hljs-keyword">for</span> i := k; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        res[i<span class="hljs-number">-1</span>] = heap.Pop(m).(<span class="hljs-type">string</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不得不说确实简洁很多，主要是 range m.mp 这里的逻辑，对比一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种写法</span><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        <span class="hljs-keyword">if</span> m.Len() &lt; k &#123;<br>            heap.Push(m, v)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (m.mp[v] == m.mp[m.s[<span class="hljs-number">0</span>]] &amp;&amp; v &lt; m.s[<span class="hljs-number">0</span>]) ||<br>                    m.mp[v] &gt; m.mp[m.s[<span class="hljs-number">0</span>]] &#123;<br>                heap.Pop(m)<br>                heap.Push(m, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 第二种写法    </span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> m.mp &#123;<br>        heap.Push(m, v)<br>        <span class="hljs-keyword">if</span> m.Len() &gt; k &#123;<br>            heap.Pop(m)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="347"><a href="#347" class="headerlink" title="347"></a>347</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap <span class="hljs-keyword">struct</span> &#123;<br>    s []<span class="hljs-type">int</span><br>    mp <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>    m.s[i], m.s[j] = m.s[j], m.s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m.s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m myheap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.mp[m.s[i]] &lt; m.mp[m.s[j]]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    m.s = <span class="hljs-built_in">append</span>(m.s, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *myheap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    p := m.s[<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    m.s = m.s[:<span class="hljs-built_in">len</span>(m.s)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> (res []<span class="hljs-type">int</span>) &#123;<br>    h := &amp;myheap&#123;mp : <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        h.mp[v]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> h.mp &#123;<br>        heap.Push(h, v)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> h.s<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go binary 使用指南 </title>
    <link href="/2022/08/08/go_binary/"/>
    <url>/2022/08/08/go_binary/</url>
    
    <content type="html"><![CDATA[<p>一个示例 demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/binary&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>Do()<br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-type">int64</span><br>Name [<span class="hljs-number">10</span>]<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *S)</span></span> Do() &#123; fmt.Println(<span class="hljs-string">&quot;Do&quot;</span>) &#125;<br><br><span class="hljs-keyword">var</span> _ I = &amp;S&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(b io.Writer, i I)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := binary.Write(b, binary.BigEndian, i); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(b io.Reader, i I)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := binary.Read(b, binary.BigEndian, i); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>buf = <span class="hljs-built_in">new</span>(bytes.Buffer)<br><span class="hljs-comment">//_buf = make([]byte, 4096)</span><br><span class="hljs-comment">//buf  = bytes.NewBuffer(_buf) 这样写会导致无法 read 出数据，原因未知</span><br>s = &amp;S&#123;<br>Id:   <span class="hljs-number">10001</span>,<br>Name: [<span class="hljs-number">10</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;,<br>&#125;<br>s_ = &amp;S&#123;&#125;<br>)<br>write(buf, s)<br>read(buf, s_)<br>fmt.Println(s_)<br>s_.Do()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">&amp;&#123;10001 [97 98 99 0 0 0 0 0 0 0]&#125;<br>Do<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="1-如果写入的是结构体，那么结构体中不能有非定长的数据类型"><a href="#1-如果写入的是结构体，那么结构体中不能有非定长的数据类型" class="headerlink" title="1. 如果写入的是结构体，那么结构体中不能有非定长的数据类型"></a>1. 如果写入的是结构体，那么结构体中不能有非定长的数据类型</h2><p>比如 int 和 string，这两个都是不定长的，int 会根据操作系统来决定长度，而 string 代表的是字符串，可以进行拼接&#x2F;删除等操作，所以也不是定长的，这些类型都无法通过 binary.Write 进行写入。如果想写入 int 类型的变量，应该显示指定其长度，比如 int64。切片类型也是不定长的，所以只能传入需要指定长度的数组。</p><p>如果将 demo 中的结构体 S 修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span> &#123;<br>  pri  <span class="hljs-type">int64</span><br>Id   <span class="hljs-type">int64</span><br>Name []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><code>panic: binary.Write: invalid type *main.S</code></p><h2 id="2-但是可以单独写入-byte"><a href="#2-但是可以单独写入-byte" class="headerlink" title="2. 但是可以单独写入 []byte"></a>2. 但是可以单独写入 []byte</h2><p>比如下面的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/binary&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;bytes&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    b := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;123&quot;</span>)<br>    <span class="hljs-comment">//b := &quot;123456&quot;</span><br>    buf := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>    bb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b), <span class="hljs-built_in">len</span>(b))<br><br>    <span class="hljs-keyword">if</span> err := binary.Write(buf, binary.BigEndian, b); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> err := binary.Read(buf, binary.BigEndian, bb); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br><br>    fmt.Println(b, bb)<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// [49 50 51] [49 50 51]</span><br></code></pre></td></tr></table></figure><p>这里单独将 b 写入，发现是可以正常运行的，但是 string 类型依然不能写入，会报错：panic: binary.Write: invalid type string</p><h2 id="3-如果写入的是-struct，需要保证所有字段为-public，但是结构体本身可以为-private"><a href="#3-如果写入的是-struct，需要保证所有字段为-public，但是结构体本身可以为-private" class="headerlink" title="3. 如果写入的是 struct，需要保证所有字段为 public，但是结构体本身可以为 private"></a>3. 如果写入的是 struct，需要保证所有字段为 public，但是结构体本身可以为 private</h2><p>注意是 <strong>所有字段</strong>，如果有非导出（private）字段，会报错：reflect: reflect.Value.SetInt using value obtained using unexported field</p><h2 id="4-可以写入接口类型"><a href="#4-可以写入接口类型" class="headerlink" title="4. 可以写入接口类型"></a>4. 可以写入接口类型</h2><p>通过开头的示例程序，说明是可以写入接口类型的（也就是说，binary.Read 和 binary.Write 的第三个参数可以传入接口类型）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 拥塞控制</title>
    <link href="/2022/08/02/tcp_yong_se_kong_zhi/"/>
    <url>/2022/08/02/tcp_yong_se_kong_zhi/</url>
    
    <content type="html"><![CDATA[<p>发送方维护一个叫做 <strong>拥塞窗口 cwnd</strong> 的状态变量，其值 <strong>取决于网络的拥塞程度</strong>，并且 <strong>动态变化</strong>。</p><ul><li>拥塞窗口 <strong>cwnd 的维护原则</strong>：只要网络 <strong>没有出现拥塞</strong>，<strong>拥塞窗口</strong> 就再 <strong>增大</strong> 一些；但只要网络 <strong>出现拥塞</strong>，<strong>拥塞窗口就减少一些。</strong></li><li>判断出现 <strong>网络拥塞的依据</strong>：没有按时收到应当到达的确认报文（即<strong>发生超时重传</strong>）。</li></ul><p>发送方将拥塞窗口作为 <strong>发送窗口 swnd</strong>，即 <strong>swnd &#x3D; cwnd</strong>。**拥塞窗口的大小也就是发送方能发送的报文的数量，即：cwnd增加1也就是相当于字节数增加1个MSS大小 <del>（这里存疑，是数量还是总大小？）</del>**。</p><p>维护一个 <strong>慢开始门限 ssthresh</strong> 状态变量：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法；</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法，该用拥塞避免算法；</li><li>当 cwnd &#x3D; ssthresh 时，即可以使用慢开始算法，也可以使用拥塞避免算法；</li></ul><h1 id="1-慢开始"><a href="#1-慢开始" class="headerlink" title="1. 慢开始"></a>1. 慢开始</h1><p>发送方发送报文后，如果收到了对方的确认报文（可以简称为一个 <strong>传输轮次</strong>），那么就将自己的 cwnd 在 <strong>原基础上乘以 2</strong>，比如从 1 开始，之后的窗口大小依次是：2，4，8，16，32，64…（按指数规律增长）</p><p>慢开始可以理解为 “在死亡边缘不断试探”，一开始试探性的向网络中发送少量报文，如果没有出现拥塞，就 “得寸进尺” 的多发送一些，以此类推。所以不要被慢开始的“慢”字给欺骗了，它可一点都不慢，慢开始并不是指 cwnd 的增长速度慢，而是指一开始向网络注入的报文段少。</p><h2 id="慢开始何时结束？"><a href="#慢开始何时结束？" class="headerlink" title="慢开始何时结束？"></a>慢开始何时结束？</h2><p>既然慢开始的增长速度如此之快，那么肯定不能让其无限制增长，当出现以下情况时，会停止慢开始阶段，进入拥塞避免阶段：</p><ul><li><p>当 cwnd 达到 ssthresh 时，会进入拥塞避免阶段。</p></li><li><p>发送超时重传时，此时网络可能出现了阻塞（也就是说，<strong>TCP 判断网络是否阻塞的依据是是否发生了超时重传</strong>）</p></li></ul><blockquote><p>疑问：sshthresh 的值默认是多少？</p><p>在一片博客上看的答案是：对于大多数 TCP 实现来说，ssthresh 的值是 65536(同样以字节计算)，这里的字节计算是什么意思，是 cwnd 的门限值 &#x3D; 65535&#x2F;mss 的意思吗？</p></blockquote><h1 id="2-拥塞避免"><a href="#2-拥塞避免" class="headerlink" title="2. 拥塞避免"></a>2. 拥塞避免</h1><p>到了拥塞避免阶段，就说明发送报文的数量可能快引起拥塞了（cwnd &#x3D; ssthresh），或者可能已经出现了拥塞（发生了超时重传），此时的拥塞窗口值就不能再像慢开始那样快速增长了，对于这两种情况，有不同的处理方法。</p><h2 id="当-cwnd-达到-ssthresh-时"><a href="#当-cwnd-达到-ssthresh-时" class="headerlink" title="当 cwnd 达到  ssthresh 时"></a>当 cwnd 达到  ssthresh 时</h2><p>此时说明发送报文的数量可能快引起拥塞了，不能再指数级增长了，变为线性增长，也就是每个传输轮次只将 cwnd + 1。</p><h2 id="发送超时重传"><a href="#发送超时重传" class="headerlink" title="发送超时重传"></a>发送超时重传</h2><p>如果 <strong>发送方发生了超时重传</strong>，那么说明此时网络可能已经出现拥塞，此时需要做以下工作：</p><ol><li>将慢开始门限值 ssthresh 更新为发生拥塞时拥塞窗口值的一半。比如在 cwnd&#x3D;24 时发生了超时重传，那么就会将 ssthresh 更新为 12.</li><li>将 cwnd 更新为 1，并重新开始慢开始算法。</li></ol><p>拥塞避免 <strong>并非指完全能够避免拥塞</strong>，而是指在拥塞避免阶段将 <strong>拥塞窗口控制为按线性规律增长</strong>，使网络不容易出现拥塞。</p><p>拥塞控制的整个流程如下图所示：</p><p>（图片出自：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=61&vd_source=2ff613424b86c58a71ba91b7304ffe9b">计算机网络微课堂（有字幕无背景音乐版）</a>）</p><p><img src="https://raw.githubusercontent.com/youseebiggirl/diagrams/2559f2fca5561b35e08edbdd0103ba1feaa3ec22/img/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg"></p><h1 id="3-快重传"><a href="#3-快重传" class="headerlink" title="3. 快重传"></a>3. 快重传</h1><p>报文发生了超时重传，并不一定就代表网络发生了拥塞，也有可能是别的原因，比如因为误码，被路由器给扔了，或者网络出现了延迟，如果直接简单粗暴的进入到拥塞避免阶段，让 cwnd 回归到 1，可能会导致网络的传输效率降低。</p><p><strong>快重传算法可以让发送方尽早知道发生了个别报文段的丢失</strong>。</p><p>所谓快重传，就是使发送方 <strong>尽快进行重传</strong>，而 <strong>不是等待超时重传计时器超时</strong> 再重传。</p><ul><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</li><li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦收到 3 个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li></ul><p>比如下图的情况，M3 在网络传输过程中丢失了，接收方在收到 M4 后，发现 M3 还没收到，于是回复 ACK&#x3D;2，表示已经收到 M2 包了，希望接下来收到 M3 包，之后发送的 M4，M5 也都是如此。此时发送方发现收到了 3 个 ACK&#x3D;2，知道了 M2 这个包对方没有收到，于是就可以立马重传了，而不是等到 M3 的超时重传到期后再重传。</p><p>这样对于个别丢失的报文段，<strong>发送方就不会出现超时重传，也就不会误认为出现了拥塞</strong>，避免了将拥塞窗口  cwnd 降低为 1。使用快重传可以使整个网络的吞吐量提高约 20 %。</p><p><img src="https://raw.githubusercontent.com/youseebiggirl/diagrams/2559f2fca5561b35e08edbdd0103ba1feaa3ec22/img/%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg"></p><h1 id="4-快恢复"><a href="#4-快恢复" class="headerlink" title="4. 快恢复"></a>4. 快恢复</h1><p>发送方一旦 <strong>收到 3 个重复确认</strong>，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而 <strong>执行快恢复算法</strong>；</p><ul><li><p><strong>发送方将慢开始门限 ssthresh 值和拥塞窗口 cwnd 值调整为当前窗口的一半；开始执行拥塞避免算法</strong>。</p></li><li><p>也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd 值再增大一些，即等于新的 ssthresh +3。</p><ul><li><p>既然发送方收到3个重复的确认，就表明有3个数据报文段己经离开了网络：</p></li><li><p>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</p></li><li><p>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</p></li></ul></li></ul><p>下图描述了整个流程，可以看到快恢复是将 cwnd 调整为发生重复确认时，窗口的一半，而不是像拥塞避免直接将 cwnd 调整为 1，一定程度上提高了吞吐率。</p><p><img src="https://raw.githubusercontent.com/youseebiggirl/diagrams/2559f2fca5561b35e08edbdd0103ba1feaa3ec22/img/%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg"></p><h1 id="参考-x2F-引用"><a href="#参考-x2F-引用" class="headerlink" title="参考&#x2F;引用"></a>参考&#x2F;引用</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=61&vd_source=2ff613424b86c58a71ba91b7304ffe9b">计算机网络微课堂（有字幕无背景音乐版）</a></p><p><a href="https://blog.csdn.net/ydyang1126/article/details/72842274">TCP慢启动、拥塞避免、快速重传、快速恢复</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么 go 需要 nil chan</title>
    <link href="/2022/07/18/wei-shen-me-go-you-nil-chan/"/>
    <url>/2022/07/18/wei-shen-me-go-you-nil-chan/</url>
    
    <content type="html"><![CDATA[<p>如果没有调用 make 来对一个 chan 进行初始化，那么这个 chan 就是 nil chan。</p><p>对于 nil chan：</p><ul><li>从 nil chan 接收将永远阻塞</li><li>发送值到 nil chan 会永远阻塞</li><li>close 一个 nil chan 会引发 panic</li></ul><p>看到这里我不禁有点疑问，这样设计的意义在哪里？为什么写入和读取要阻塞，而不是像 nil map 一样直接 panic？</p><p>带着这个问题找到了一篇文章：<a href="https://medium.com/justforfunc/why-are-there-nil-channels-in-go-9877cc0b2308">Why are there nil channels in Go?</a></p><p>中译版：<a href="https://lingchao.xin/post/why-are-there-nil-channels-in-go.html">为什么 Go 会有 nil channels</a></p><p>里面提到了 nil chan 的意义，这里简单概括一下：</p><p><strong>nil chan 主要是为了防止 select 的空转。</strong></p><p>比如以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> v := &lt;- c1:<br>    <span class="hljs-keyword">case</span> v := &lt;- c2:<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果某个时间 c1，c2 都被关闭了，按照 chan 的规则，如果尝试读取一个已关闭的 chan，将会读取出类型的空值，所以此时的 <code>case v := &lt;- c1:</code>  和 <code>case v := &lt;- c2:</code> 分支依然是会被选择的，而一个 chan 被关闭则说明我们已经不需要它了，这显然是一个多余的操作。</p><p>而 select 的规则是，如果所有 case 都满足，则随机选择一个，此时的 c1，c2 依然满足条件，所以 select 会随机选择一个，又因为 select 定义在一个死循环里面，所以会导致 cpu 空转。</p><p>现在终于知道 nil chan 阻塞的意义何在了，将上面的代码修改如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(c1 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, c2 <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>  <span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> v, ok := &lt;- c1:<br>      <span class="hljs-keyword">if</span> !ok &#123;c1 = <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-keyword">case</span> v, ok := &lt;- c2:<br>      <span class="hljs-keyword">if</span> !ok &#123;c2 = <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-keyword">default</span>:  <br>      <span class="hljs-keyword">return</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果某个 chan 被 close 了，那么将其设置为 nil，而 nil chan 的读取会阻塞，所以 select 就不会选择这个分支了，这样就避免了上述情况的空准，但是不要忘记加一个 <code>default</code> 分支，不然这个 select 就被永久阻塞了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq 学习笔记</title>
    <link href="/2022/07/14/go-rabbitmq/"/>
    <url>/2022/07/14/go-rabbitmq/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记主要记录 go rabbitmq 库的使用示例，同时结合学习 rabbitmq</p></blockquote><h1 id="一个基本的发布-x2F-订阅程序示例"><a href="#一个基本的发布-x2F-订阅程序示例" class="headerlink" title="一个基本的发布&#x2F;订阅程序示例"></a>一个基本的发布&#x2F;订阅程序示例</h1><p>首先可以通过一个最基础的程序，来一览 rabbitmq 的大致面貌：</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br>amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 1. 尝试连接 RabbitMQ，建立连接</span><br><span class="hljs-comment">// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 2. 接下来，我们创建一个通道，大多数 API 都是用过该通道操作的。</span><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 3. 声明消息要发送到的队列</span><br>q, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-comment">// name</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// durable 是否为持久化队列</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,     <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br><br>log.Printf(<span class="hljs-string">&quot;Enter q or Q to exit.&quot;</span>)<br>scanner := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br><span class="hljs-keyword">if</span> scanner.Err() != <span class="hljs-literal">nil</span> &#123;<br>Assert(scanner.Err(), <span class="hljs-string">&quot;read stdin error&quot;</span>)<br>&#125;<br>body := scanner.Bytes()<br><span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;q&quot;</span> || <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;bye^&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// 4.将消息发布到声明的队列</span><br>err = ch.Publish(<br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// exchange</span><br>q.Name, <span class="hljs-comment">// routing key</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// mandatory</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// immediate</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        body,<br><span class="hljs-comment">// 是否持久化消息，瞬态（0 或 1）或持久（2）</span><br>DeliveryMode: amqp.Transient,<br>&#125;)<br>Assert(err, <span class="hljs-string">&quot;Failed to publish a message&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br>q, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-comment">// name</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,     <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br><br><br>msgs, err := ch.Consume(<br>q.Name, <span class="hljs-comment">// queue</span><br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// consumer</span><br><span class="hljs-literal">true</span>,   <span class="hljs-comment">// auto-ack</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-local</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,    <span class="hljs-comment">// args</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to register a consumer&quot;</span>)<br><br><span class="hljs-keyword">var</span> forever <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> msgs &#123;<br>log.Printf(<span class="hljs-string">&quot;Received a message: %s&quot;</span>, d.Body)<br>&#125;<br>&#125;()<br><br>log.Printf(<span class="hljs-string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)<br>&lt;-forever<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>通过上面的程序，可以看到上面代码中有几个核心方法：</p><h3 id="QueueDeclare"><a href="#QueueDeclare" class="headerlink" title="QueueDeclare"></a>QueueDeclare</h3><p>用于创建一个 <strong>队列</strong>，或者连接到一个已存在的队列，需要提供以下参数：</p><ul><li>name：指定队列的名称，如果留空且执行的是创建操作，则会随机分配一个名称</li><li>durable：是否持久化</li><li>autoDelete: 是否自动删除队列，如果为 true 表示没有消息也没有消费者连接自动删除队列</li><li>exclusive: 是否独占，即当前声明队列的连接关闭后即被删除</li><li>noWait: 是否等待服务器返回 ok</li><li>args:</li></ul><h3 id="Consume"><a href="#Consume" class="headerlink" title="Consume"></a>Consume</h3><ul><li>queue：要消费的队列的名字</li><li>consumer：</li><li>autoAck：如果为 true，代表 mq 会自动把发送出去的消息置为确认，不会考虑消费者是否真正的消费了这条消息</li><li>exclusive </li><li>noLocal</li><li>noWait </li><li>args</li></ul><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><ul><li>exchange：交换机的名称，用于确定消息要投放到哪个交换机</li><li>key：路由键，类似路由的功能，可以为一个交换机定义多个路由键，通过不同路由键连接到不同的队列</li><li>mandatory ：</li><li>immediate ：</li><li>msg：要推送的消息，字节类型</li></ul><h1 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h1><h1 id="exchange-交换器"><a href="#exchange-交换器" class="headerlink" title="exchange 交换器"></a>exchange 交换器</h1><p>exchange 是消息交换机，它指定消息按什么规则,路由到哪个队列。</p><p>比如下图，x 就是一个交换机，它定义了 3 个 routing_key，routing_key 就是上面说的规则，不同的 routing_key 关联到不同的队列，在下图中，orange 这个 key 关联到了队列 Q1，black 和 green 这两个 key 关联到了队列 Q2，消费者可以根据 routing_key 来消费不同的队列。</p><p><img src="https://www.liwenzhou.com/images/Go/rabbitmq/tutorials04/direct-exchange.png"></p><p>exchange 的程序大致流程是：</p><p>生产者：</p><ol><li>定义或者连接一个 exchange</li><li>推送消息到这个 exchange</li></ol><p>消费者：</p><ol><li>定义一个队列</li><li>将队列和上面的 exchange 绑定</li><li>然后就可以从队列中消费了</li></ol><p>其实上面的流程不是固定的，只需要记住一个固定的规则即可：<strong>消费者只能从队列消费，队列必须绑定一个 exchange</strong>，所以队列的定义和绑定（也就是消费者流程的 1，2 步）完全也可以让生产者去做，消费者直接进行消费就可以了，只要保证 rabbitmq 中存在这个已经绑定到 exchange 的队列即可。</p><p>这里可能会有一个疑问：在文章最开始的示例中，并没有创建一个 exchange，也没有进行绑定操作，生产者和消费者都是直接操作队列，这是如何做到的呢？其实在 rabbitmq 中存在一个 <strong>默认的 exchange</strong>，如果没有指定 exchange，那么就会使用这个默认交换器，对于 routing key 也是一样的，如果没有指定，则使用默认的。</p><p>绑定调用的函数是 QueueBind，其签名如下：</p><h3 id="QueueBind"><a href="#QueueBind" class="headerlink" title="QueueBind"></a>QueueBind</h3><ul><li>name</li><li>key</li><li>exchange</li><li>noWait</li><li>args</li></ul><p>exchange 有多种类型，下面会详细介绍，可以抽象出一个通用的程序，通过命令行参数来定义不同的 exchange</p><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br>amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> ExchangeKind = <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>ExchangeKind_Direct  ExchangeKind = <span class="hljs-string">&quot;direct&quot;</span><br>ExchangeKind_Topic   ExchangeKind = <span class="hljs-string">&quot;topic&quot;</span><br>ExchangeKind_Headers ExchangeKind = <span class="hljs-string">&quot;headers&quot;</span><br>ExchangeKind_Fanout  ExchangeKind = <span class="hljs-string">&quot;fanout&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 检查输入的 exchange kind 是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkExchangeKind</span><span class="hljs-params">(kind <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;<br>ExchangeKind_Direct:  <span class="hljs-literal">true</span>,<br>ExchangeKind_Topic:   <span class="hljs-literal">true</span>,<br>ExchangeKind_Headers: <span class="hljs-literal">true</span>,<br>ExchangeKind_Fanout:  <span class="hljs-literal">true</span>,<br>&#125;<br><span class="hljs-keyword">if</span> exist := m[kind]; exist &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;not found this kind&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;usage: ./main -e [exchange name] -k [exchange kind]&quot;</span>)<br><span class="hljs-keyword">var</span> (<br>exchangeName = flag.String(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exchange name&quot;</span>)<br>exchangeKind = flag.String(<span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exchange kind&quot;</span>)<br>)<br>flag.Parse()<br><br><span class="hljs-keyword">if</span> err := checkExchangeKind(*exchangeKind); err != <span class="hljs-literal">nil</span> &#123;<br>Assert(err, <span class="hljs-string">&quot;check exchange kind error: &quot;</span>)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;exchangeName: %v, exchangeKind: %v\n&quot;</span>,<br>*exchangeName, *exchangeKind)<br><br><span class="hljs-comment">// 1. 尝试连接 RabbitMQ，建立连接</span><br><span class="hljs-comment">// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 2. 接下来，我们创建一个通道，大多数 API 都是用过该通道操作的。</span><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 声明一个交换器 exchange</span><br>err = ch.ExchangeDeclare(<br>*exchangeName, <span class="hljs-comment">// name 交换器名</span><br>*exchangeKind, <span class="hljs-comment">// type 交换器类型</span><br><span class="hljs-literal">true</span>,          <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,         <span class="hljs-comment">// auto-deleted</span><br><span class="hljs-literal">false</span>,         <span class="hljs-comment">// internal</span><br><span class="hljs-literal">false</span>,         <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,           <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a exchange&quot;</span>)<br><br>log.Printf(<span class="hljs-string">&quot;Enter q or Q to exit.&quot;</span>)<br>log.Printf(<span class="hljs-string">&quot;usage: &lt;routing_key&gt;:&lt;message&gt;&quot;</span>)<br>scanner := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br><span class="hljs-keyword">if</span> scanner.Err() != <span class="hljs-literal">nil</span> &#123;<br>Assert(scanner.Err(), <span class="hljs-string">&quot;read stdin error&quot;</span>)<br>&#125;<br>body := scanner.Bytes()<br><span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;q&quot;</span> || <span class="hljs-type">string</span>(body) == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;bye^&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>    <span class="hljs-comment">// 输入的格式：&lt;路由键&gt;:&lt;消息实体&gt;</span><br>before, after, found := bytes.Cut(body, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;:&quot;</span>))<br><span class="hljs-keyword">if</span> !found &#123;<br>log.Printf(<span class="hljs-string">&quot;usage: &lt;routing_key&gt;:&lt;message&gt;&quot;</span>)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;routingKey: %s, message: %s\n&quot;</span>, before, after)<br><br><span class="hljs-comment">// 4.将消息发布到 exchange 而不是某个单独的队列</span><br>err = ch.Publish(<br>*exchangeName,  <span class="hljs-comment">// exchange</span><br><span class="hljs-type">string</span>(before), <span class="hljs-comment">// routing key</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// mandatory</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// immediate</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        after,<br><span class="hljs-comment">// 是否持久化消息，瞬态（0 或 1）或持久（2）</span><br>DeliveryMode: amqp.Transient,<br>&#125;)<br>Assert(err, <span class="hljs-string">&quot;Failed to publish a message&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./producer_exchange -e [exchange name] -k [exchange kind]<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">推送消息到名为 logs_direct ，类型为 direct 的 exchange</span><br>./producer_exchange -e logs_direct -k direct<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送消息到名为 logs_topic ，类型为 topic 的 exchange</span><br>./producer_exchange -e logs_topic -k topic<br></code></pre></td></tr></table></figure><h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>amqp <span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;rabbitmq&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><br><span class="hljs-keyword">type</span> routingKeys []<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *routingKeys)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, *s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *routingKeys)</span></span> Set(value <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>ss := strings.Split(value, <span class="hljs-string">&quot;,&quot;</span>)<br>*s = <span class="hljs-built_in">append</span>(*s, ss...)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>, msg <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Panicf(<span class="hljs-string">&quot;%s: %s&quot;</span>, msg, err)<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">`</span><br><span class="hljs-string">usage: ./main </span><br><span class="hljs-string">-q [queue name] </span><br><span class="hljs-string">-e [exchange name] </span><br><span class="hljs-string">-r [routing key, can provide more, use &#x27;,&#x27; to sep, </span><br><span class="hljs-string">example: info,error,warning (don&#x27;t have space) ]</span><br><span class="hljs-string">`</span>)<br><span class="hljs-keyword">var</span> (<br>exchangeName = flag.String(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;exchange name&quot;</span>)<br>queueName    = flag.String(<span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;queue name&quot;</span>)<br>rks          routingKeys<br>)<br>flag.Var(&amp;rks, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-string">&quot;routing key&quot;</span>)<br>flag.Parse()<br><br>log.Printf(<span class="hljs-string">&quot;queueName: %v, exchangeName: %v, routingKey: %v\n&quot;</span>,<br>*queueName, *exchangeName, &amp;rks)<br><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>Assert(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br><br>ch, err := conn.Channel()<br>Assert(err, <span class="hljs-string">&quot;Failed to open a channel&quot;</span>)<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 声明一个临时队列，一旦消费者断开连接，该队列就会被删除</span><br>q, err := ch.QueueDeclare(<br>*queueName, <span class="hljs-comment">// name 空字符串作为队列名称，表示使用随机名称</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">true</span>,       <span class="hljs-comment">// exclusive 独占队列（当前声明队列的连接关闭后即被删除）</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,        <span class="hljs-comment">// arguments</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rks) == <span class="hljs-number">0</span> &#123;<br>err = ch.QueueBind(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br>*exchangeName,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to bind a queue&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> rks &#123;<br><span class="hljs-comment">// 将 queue 绑定到对应的 exchange，使用 exchangeName + routingKeys 进行匹配</span><br>err = ch.QueueBind(<br>q.Name,<br>key,<br>*exchangeName,<br><span class="hljs-literal">false</span>,<br><span class="hljs-literal">nil</span>,<br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to bind a queue&quot;</span>)<br>&#125;<br>&#125;<br><br>msgs, err := ch.Consume(<br>q.Name, <span class="hljs-comment">// queue</span><br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// consumer</span><br><span class="hljs-literal">true</span>,   <span class="hljs-comment">// auto-ack</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-local</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,    <span class="hljs-comment">// args</span><br>)<br>Assert(err, <span class="hljs-string">&quot;Failed to register a consumer&quot;</span>)<br><br><span class="hljs-keyword">var</span> forever <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> d := <span class="hljs-keyword">range</span> msgs &#123;<br><span class="hljs-comment">// 如果您调用 Channel.Consume 时将 autoAck 设置为 true，那么服务器将自动确认</span><br><span class="hljs-comment">// 每条消息，并且不应调用此方法。否则，您必须在成功处理此交付后调用 Delivery.Ack。</span><br><span class="hljs-comment">// 参数是什么意思？</span><br><span class="hljs-comment">// d.Ack(false)</span><br>log.Printf(<span class="hljs-string">&quot;Received a message: %s&quot;</span>, d.Body)<br>&#125;<br>&#125;()<br><br>log.Printf(<span class="hljs-string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)<br>&lt;-forever<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">usage: ./main <br>-q [queue name] <br>-e [exchange name] <br>-r [routing key, 可以提供多个, 使用 , 来分隔, 比如: info,error,warning (注意 , 前后不要有空格) ]<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">// ./consumer_exchange -e logs_direct -r error<br>// ./consumer_exchange -e logs_direct -r error,info,warning<br>//<br>// ./consumer_exchange -e logs_topic -r &quot;*.orange.*&quot;<br>// ./consumer_exchange -e logs_topic -r &quot;*.*.rabbit&quot;,&quot;lazy.#&quot;<br></code></pre></td></tr></table></figure><h2 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h2><p>fanout 类型的 exchange 提供广播功能，即将消息投递到所有与该 exchange 所绑定的 queue 上，此时指定的 routing key 会被忽略</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这里直接使用上面的通用代码，只要在运行时指定不同的 flag 即可</p><h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./producer_exchange -e logs -k fanout<br></code></pre></td></tr></table></figure><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者 1"></a>消费者 1</h4><p>因为 fanout 会忽略 routing key，所以 -r 也不需要指定了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./consumer_exchange -e logs<br></code></pre></td></tr></table></figure><h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者 2"></a>消费者 2</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./consumer_exchange -e logs <br></code></pre></td></tr></table></figure><p>先执行生产者，再执行消费者1，2</p><p>生产者执行后在终端输入消息（消息格式是 &lt;路由键&gt;:&lt;消息&gt;，因为是 fanout 类型，所以无需指定路由键）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./producer_exchange -e logs -k fanout</span> <br>2022/07/24 12:16:22 usage: ./main -e [exchange name] -k [exchange kind]<br>2022/07/24 12:16:22 exchangeName: logs, exchangeKind: fanout<br>2022/07/24 12:16:22 Enter q or Q to exit.<br>2022/07/24 12:16:22 usage: &lt;routing_key&gt;:&lt;message&gt;<br>:123<br>2022/07/24 12:20:27 routingKey: , message: 123<br><br></code></pre></td></tr></table></figure><p>之后观察两个消费者的 terminal，发现都收到了消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./consumer_exchange -e logs</span> <br>2022/07/24 12:20:23 <br>        usage: ./main <br>        -q [queue name] <br>        -e [exchange name] <br>        -r [routing key, can provide more, use &#x27;,&#x27; to sep, <br>                example: info,error,warning (don&#x27;t have space) ]<br>2022/07/24 12:20:23 queueName: , exchangeName: logs, routingKey: []<br>2022/07/24 12:20:23  [*] Waiting for messages. To exit press CTRL+C<br>2022/07/24 12:20:27 Received a message: 123<br></code></pre></td></tr></table></figure><h2 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h2><p>direct 类型的 exchange 会严格按照 routing key 进行精准匹配</p><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>topic 类型的 exchange 提供了 routing key 的通配符匹配功能，支持 * 和 # 语法，”#” 代表匹配一个或多个单词，”*” 则匹配不多不少刚好一个单词</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>这里直接使用上面的通用代码，只要在运行时指定不同的 flag 即可</p><h4 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./producer_exchange -e logs_topic -k topic</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开始输入</span><br>quick.orange.rabbit:666<br>lazy.orange.elephant:aaa<br>quick.orange.fox:888<br></code></pre></td></tr></table></figure><h4 id="消费者-1-1"><a href="#消费者-1-1" class="headerlink" title="消费者 1"></a>消费者 1</h4><p>这个消费者消费 routing key 匹配 <code>*.orange.*</code>  的消息，表示单词个数必须是 3 个，且中间的必须是 orange</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./consumer_exchange -e logs_topic -r <span class="hljs-string">&quot;*.orange.*&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="消费者-2-1"><a href="#消费者-2-1" class="headerlink" title="消费者 2"></a>消费者 2</h4><p>注意这里要用 “” 将 routing key 包裹起来，否则 * 会被 shell 错误解析</p><p><code>*.*.rabbit</code>表示单词个数必须是 3 个，且最后一个单词必须是 rabbit</p><p><code>lazy.#</code> 表示的是只要第一个单词为 lazy 即可，之后的内容忽略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./consumer_exchange -e logs_topic -r <span class="hljs-string">&quot;*.*.rabbit&quot;</span>,<span class="hljs-string">&quot;lazy.#&quot;</span></span><br></code></pre></td></tr></table></figure><p>匹配情况：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>    &gt; quick.orange.rabbit:<span class="hljs-number">666</span>=&gt; *.orange.*  | *.*.rabbit<br><span class="hljs-regexp">//</span>&gt; lazy.orange.elephant:aaa=&gt;*.orange.*<br><span class="hljs-regexp">//</span>&gt; quick.orange.fox:<span class="hljs-number">888</span>=&gt;*.orange.*<br><span class="hljs-regexp">//</span>&gt; lazy.brown.fox:<span class="hljs-number">666</span>=&gt;lazy.<span class="hljs-comment">#</span><br><span class="hljs-regexp">//</span>&gt; lazy.pink.rabbit:xxx=&gt;lazy.<span class="hljs-comment"># | *.*.rabbit</span><br><span class="hljs-regexp">//</span>&gt; quick.brown.fox:yyy=&gt;<br><span class="hljs-regexp">//</span>&gt; orange:ccc=&gt;<br><span class="hljs-regexp">//</span> &gt; quick.orange.male.rabbit:bbb=&gt;<br><span class="hljs-regexp">//</span>&gt; lazy.orange.male.rabbit:ooo=&gt;lazy.<span class="hljs-comment">#</span><br><span class="hljs-regexp">//</span>&gt; lazy.orange.male.rabbit.io:zzz=&gt;lazy.<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>可以按照上表的内容自己实践一下，看看不同的 routing_key 会传递给哪个消费者</p><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><p>延迟队列可以用于订单超时取消的场景，可以用 rabbitmq 的死信队列来实现一个延迟队列。</p><p><strong>死信队列</strong>，顾名思义，就是用来存储那些无法被消费的，已经“死掉“的消息，和普通队列一样，也是由 exchange、routing_key 和 queue 三大组件构成的。</p><p>什么条件下会将消息放到死信队列？</p><ul><li>消息被拒绝，并且 requeue 参数为 false，这个参数代表是否将被拒绝的消息重新放回队列，让其他消费者进行消费</li><li>消息的 TTL 过期</li><li>队列达到最大长度或队列空间已满，此时需要 queue 的拒绝策略设置为 reject-public-dlx，后续投递至该队列的消息会重新投递到死信队列中</li></ul><p>这里需要注意的一点是：消息的 TTL 和消息的 ACK 是不相干的，比如设置了消息的 TTL 为 5s，但是消息超过 5s 没有回复 ACK，此时是不会判定这条消息过期的，引用书上的一段话：<strong>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者费一条消息的时间可以很久很久。</strong> </p><p>消息过期的依据是：如果一条消息超过 TTL 还没有被消费，则判断为过期。而 ACK 是在已经消费的情况下才能回复的东西，所以这两个东西当然不相干。</p><p>之所以会记录上面的问题，是因为我在写代码时犯了这个错误，我在消费者开了两个线程，分别消费普通队列和死信队列，生产者这边会先将消息投放到普通队列，然后我的逻辑是消息普通队列的时候加一个随机的 sleep，让部分消息的 ACK 超过 TTL 的时间，从而让消息超时进入死信队列，但是运行时我发现消息始终不会进入死信队列，除非是直接结束掉消费者进程，然后生产者这边投放几条消息，等过了 TTL 时间后再运行消费者进程，此时就会从死信队列里消费到过期消息。</p><p><strong>实现延迟队列的基本逻辑</strong></p><p>生产者：</p><ol><li>创建一个正常交换机</li><li>创建一个死信交换机</li><li>创建一个正常队列，并绑定正常交换机和 routing_key，同时设置以下几个参数：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;x-message-ttl&quot;</span>:             <span class="hljs-number">5000</span>,            <span class="hljs-regexp">//</span> 消息过期时间,毫秒<br><span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>:    dlxExchangeName, <span class="hljs-regexp">//</span> 指定死信交换机<br><span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>: dlxRoutingKey,   <span class="hljs-regexp">//</span> 指定死信 routing-key<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个死信队列，并绑定死信交换机和 routing_key</li><li>推送消息到正常交换机</li></ol><p>消费者：</p><p>因为队列和交换机都已经由生产者创建好了，所以消费者这边直接消费即可，并且只需要从死信交换机进行消费即可，这样一来，生产者放到正常队列里的消息在 TTL 之后过期，会放到死信队列，这样消费者就可以直接进行消费了。</p><p>比如订单超时未支付自动取消的场景，当用户提交订单时，生产者将订单信息放到正常队列，同时设置过期时间，当到达时间后进入死信队列，消费者这边就可以开始进行消费了，具体的业务逻辑这里就不展开了，比如可以查询一下订单 ID，看支付状态是否为未支付，如果未支付就说明可以取消这个订单了。</p><h1 id="架构及组件"><a href="#架构及组件" class="headerlink" title="架构及组件"></a>架构及组件</h1>]]></content>
    
    
    
    <tags>
      
      <tag>mq</tag>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>minikube 问题汇总</title>
    <link href="/2022/07/14/minikube_wen_ti_hui_zong/"/>
    <url>/2022/07/14/minikube_wen_ti_hui_zong/</url>
    
    <content type="html"><![CDATA[<h1 id="设置代理后，minikube-kubectl-无响应"><a href="#设置代理后，minikube-kubectl-无响应" class="headerlink" title="设置代理后，minikube kubectl 无响应"></a>设置代理后，minikube kubectl 无响应</h1><p>在给虚拟机设置了代理后，整个网络体验爽快多了，再也不用担心拉不下来包了。。。</p><p>只需要将虚拟机的网络设置为桥接模式，然后开启 clashx 的 “允许局域网连接”（非常重要的一步，之前就是因为忽略了这一步，导致虚拟机无法使用宿主机代理），然后再点击 clashx 的 “复制终端代理命令”，将里面的 127.0.0.1 替换为宿主机的 ip，然后粘贴到虚拟机的终端上允许，即可成功开启代理。</p><p>为了方便起见，可以封装成两个函数，放到 .zshrc（或者 .bashrc）里面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">host_ip=&quot;192.168.2.5&quot; # 宿主机 IP<br><br>function proxy_on() &#123;<br>    export https_proxy=http://$host_ip:7890 http_proxy=http://$host_ip:7890 all_proxy=socks5://$host_ip:7890<br>    # curl https://www.google.com/<br>    # echo -e &quot;\n&quot;<br>    echo -e &quot;\033[32m已开启代理\033[0m&quot;<br>&#125;<br><br>function proxy_off() &#123;<br>    unset http_proxy<br>    unset https_proxy<br>    unset all_proxy<br>    echo -e &quot;已关闭代理&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后重新载入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.zshrc<br></code></pre></td></tr></table></figure><p>现在在终端可以输入 <code>proxy_on</code> 来开启代理了，同样可以输入 <code>proxy_off</code> 来关闭。</p><p>但是之后发现了一个问题，kubectl 命令无响应，不管是使用 snap 下载的 kubectl，还是使用 minikube kubectl 下载的 kubectl 都是如此。</p><p>如果执行 kubectl get po 会一直阻塞，但是 kubectl version 在等待一会后会返回错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube kubectl version</span><br>WARNING: This version information is deprecated and will be replaced with the output from kubectl version --short.  Use --output=yaml|json to get the full version.<br>Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;24&quot;, GitVersion:&quot;v1.24.3&quot;, GitCommit:&quot;aef86a93758dc3cb2c658dd9657ab4ad4afc21cb&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-07-13T14:30:46Z&quot;, GoVersion:&quot;go1.18.3&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/arm64&quot;&#125;<br>Kustomize Version: v4.5.4<br>error: Get &quot;https://192.168.49.2:8443/version?timeout=32s&quot;: context deadline exceeded - error from a previous attempt: read tcp 192.168.2.2:35044-&gt;192.168.2.5:7890: read: connection reset by peer<br></code></pre></td></tr></table></figure><p>看到这里的 192.168.2.2:35044-&gt;192.168.2.5:7890，我才发现有点不对劲，这不是我设置的代理地址吗？难道问题出在这里？</p><p>然后查阅了一下 minikube 的官方文档，发现里面专门 <a href="https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/">有一节</a> 专门提到了代理的问题：</p><p>里面特别提到了：</p><blockquote><p>如果需要 HTTP 代理来访问互联网，您可能需要使用环境变量将代理连接信息传递给 minikube 和 Docker：</p><ul><li><code>HTTP_PROXY</code>- 您的 HTTP 代理的 URL</li><li><code>HTTPS_PROXY</code>- HTTPS 代理的 URL</li><li><code>NO_PROXY</code>- 不应通过代理的主机的逗号分隔列表。</li></ul><p>这里的 NO_PROXY 变量很重要：如果不设置它，minikube 可能无法访问 VM 内的资源。minikube 使用四个默认 IP 范围，它们不应通过代理：</p><ul><li><strong>192.168.59.0&#x2F;24</strong>：由 minikube VM 使用。可通过以下方式为某些管理程序配置<code>--host-only-cidr</code></li><li><strong>192.168.39.0&#x2F;24</strong>：由 minikube kvm2 驱动程序使用。</li><li><strong>192.168.49.0&#x2F;24</strong>：由 minikube docker 驱动程序的第一个集群使用。</li><li><strong>10.96.0.0&#x2F;12</strong>：由服务集群 IP 使用。可通过以下方式配置 <code>--service-cluster-ip-range</code></li></ul></blockquote><p>并且给出了示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export HTTP_PROXY=http://&lt;proxy hostname:port&gt;<br>export HTTPS_PROXY=https://&lt;proxy hostname:port&gt;<br>export NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24<br></code></pre></td></tr></table></figure><p>现在照猫画虎，修改之前的 proxy_on 函数（这里我同样删除了 all_proxy 配置，不知道这个配置是否有影响）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">host_ip=&quot;192.168.2.5&quot;<br><br>function proxy_on() &#123;<br>    export no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24<br>    export https_proxy=http://$host_ip:7890<br>    export http_proxy=http://$host_ip:7890<br>    # curl https://www.google.com/<br>    # echo -e &quot;\n&quot;<br>    echo -e &quot;\033[32m已开启代理\033[0m&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在 kubectl 就可以正常使用了。</p><p>更新：</p><p>最近发现又出现这个问题了，我的 proxy_on 函数也没有发生任何修改，报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl version</span><br>WARNING: This version information is deprecated and will be replaced with the output from kubectl version --short.  Use --output=yaml|json to get the full version.<br>Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;24&quot;, GitVersion:&quot;v1.24.4&quot;, GitCommit:&quot;95ee5ab382d64cfe6c28967f36b53970b8374491&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-08-18T02:40:28Z&quot;, GoVersion:&quot;go1.18.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/arm64&quot;&#125;<br>Kustomize Version: v4.5.4<br>error: Get &quot;https://192.168.58.2:8443/version?timeout=32s&quot;: context deadline exceeded - error from a previous attempt: read tcp 192.168.2.4:45562-&gt;192.168.2.3:7890: read: connection reset by peer<br></code></pre></td></tr></table></figure><p>这里我注意到了 “<a href="https://192.168.58.2:8443/version?timeout=32s">https://192.168.58.2:8443/version?timeout=32s</a>“ 这部分，发现请求的是 192.168.58.2 这个地址，我尝试将这个地址段（也就是 192.168.58.0&#x2F;24）也添加到 no_proxy 列表中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">function proxy_on() &#123;<br>    export no_proxy=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24,192.168.58.0/24<br>    export https_proxy=http://$host_ip:7890<br>    export http_proxy=http://$host_ip:7890<br>    # curl https://www.google.com/<br>    # echo -e &quot;\n&quot;<br>    echo &quot;host_ip: $host_ip&quot;<br>    echo -e &quot;\033[32m已开启代理\033[0m&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加后 source .zshrc，proxy_off 一下，再重新 proxy_on，发现 kubectl 可以正常执行了。</p><p>不过具体原因还不清楚，我的 minikube version 是 v1.26.1，是官方文档与这个版本不匹配吗？或者可能是因为 192.168.59.0 这个网段被占用了，导致 minikube 重新选择了 192.168.58.0 这个网段？暂时不知道原因，不过只要按照 kubectl version 里的报错信息，将请求的网段添加到 no_proxy 环境变量里就可以解决问题了。</p><h1 id="minikube-无法启动"><a href="#minikube-无法启动" class="headerlink" title="minikube 无法启动"></a>minikube 无法启动</h1><p>重装了一下 docker，发现 minikube 无法启动了，部分报错信息如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[kubelet-check] Initial <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">of</span> <span class="hljs-number">40</span>s passed.<br><br>Unfortunately, an <span class="hljs-keyword">error</span> has occurred:<br>timed out waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> condition<br><br>This <span class="hljs-keyword">error</span> <span class="hljs-keyword">is</span> likely caused <span class="hljs-keyword">by</span>:<br>- The kubelet <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">running</span><br>- The kubelet <span class="hljs-keyword">is</span> unhealthy due <span class="hljs-keyword">to</span> a misconfiguration <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> node <span class="hljs-keyword">in</span> <span class="hljs-keyword">some</span> way (required cgroups disabled)<br><br>If you are <span class="hljs-keyword">on</span> a systemd-powered system, you can <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> troubleshoot <span class="hljs-keyword">the</span> <span class="hljs-keyword">error</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> following commands:<br>- &#x27;systemctl status kubelet&#x27;<br>- &#x27;journalctl -xeu kubelet&#x27;<br></code></pre></td></tr></table></figure><p>解决方法，<a href="https://github.com/kubernetes/minikube/issues/14477">参考这里</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube delete</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube start --kubernetes-version=v1.23.8</span><br></code></pre></td></tr></table></figure><p>可能是 kubernetes 1.24 的问题导致的</p><h1 id="创建-pod-错误，Error-ImagePullBackOff"><a href="#创建-pod-错误，Error-ImagePullBackOff" class="headerlink" title="创建 pod 错误，Error: ImagePullBackOff"></a>创建 pod 错误，Error: ImagePullBackOff</h1><p>一个 redis yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">6379</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>这是我之前使用过的 redis yaml，yaml 本身应该没问题，但是 <code>kubectl apply -f redis.yaml</code> 后，pod 无法创建成功，处于 ImagePullBackOff 状态，查看 describe，报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">Events:<br>  Type     Reason     Age                     From               Message<br>  ----     ------     ----                    ----               -------<br>  Normal   Scheduled  9m47s                   default-scheduler  Successfully assigned default/redis to minikube<br>  Warning  Failed     9m31s                   kubelet            Failed to pull image &quot;redis&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: context deadline exceeded (Client.Timeout exceeded while awaiting headers)<br>  Warning  Failed     8m21s (x2 over 9m2s)    kubelet            Failed to pull image &quot;redis&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)<br>  Normal   Pulling    7m26s (x4 over 9m47s)   kubelet            Pulling image &quot;redis&quot;<br>  Warning  Failed     7m11s (x4 over 9m31s)   kubelet            Error: ErrImagePull<br>  Warning  Failed     7m11s                   kubelet            Failed to pull image &quot;redis&quot;: rpc error: code = Unknown desc = Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: dial tcp 54.242.59.189:443: i/o timeout<br>  Warning  Failed     6m56s (x6 over 9m31s)   kubelet            Error: ImagePullBackOff<br>  Normal   BackOff    4m37s (x14 over 9m31s)  kubelet            Back-off pulling image &quot;redis&quot;<br></code></pre></td></tr></table></figure><p>但是我使用 docker pull redis 是成功的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker pull redis</span><br>Using default tag: latest<br>latest: Pulling from library/redis<br>5b1423465504: Pull complete<br>4216a986e3df: Pull complete<br>f74254280149: Pull complete<br>64dfe9963acc: Pull complete<br>097894d6d055: Pull complete<br>b9381c45e088: Pull complete<br>Digest: sha256:495732ba570db6a3626370a1fb949e98273a13d41eb3e26f7ecb1f6e31ad4041<br>Status: Downloaded newer image for redis:latest<br>docker.io/library/redis:latest<br></code></pre></td></tr></table></figure><p>而且我注意到 docker pull 的地址是 library&#x2F;redis，而 k8s pod get 的地址是 registry-1.docker.io&#x2F;v2&#x2F;，因为虚拟机我挂了代理，应该也不是网络的问题。我又将 redis.yaml 里面的 spec.containers[0].image 改为了 library&#x2F;redis，依旧创建失败，还是会 Get <a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a> 这个地址。</p><p>不知道问题出在哪里，试了下用 k3s 执行同样的操作，可以创建成功</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>minikube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS 握手流程</title>
    <link href="/2022/07/14/tls_wo_shou/"/>
    <url>/2022/07/14/tls_wo_shou/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：以下内容引用自 <a href="https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/">cloudflare 学习中心</a></p></blockquote><h1 id="TLS-握手有哪些步骤？"><a href="#TLS-握手有哪些步骤？" class="headerlink" title="TLS 握手有哪些步骤？"></a>TLS 握手有哪些步骤？</h1><p>TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。</p><p>TLS 握手的确切步骤将根据所使用的密钥交换算法的类型以及双方支持的密码套件而有所不同。RSA 密钥交换算法最为常用。具体如下：</p><ol><li><p><strong>“客户端问候（client hello）” 消息：</strong> 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含 <strong>客户端支持的 TLS 版本，支持的密码套件</strong>，以及称为一串称为“<strong>客户端随机数（client random）</strong>”的随机字节。</p></li><li><p><strong>“服务器问候（server hello）”消息：</strong> 作为对 client hello 消息的回复，服务器发送一条消息，内含<strong>服务器的 <a href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">SSL 证书</a><strong>、</strong>服务器选择的密码套件（从客户端支持的套件中选择）</strong>，以及“<strong>服务器随机数</strong>（server random）”，即由服务器生成的另一串随机字节。</p></li><li><p><strong>身份验证：</strong> 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</p></li><li><p><strong>预主密钥：</strong> 客户端再发送一串随机字节，即“<strong>预主密钥（premaster secret）</strong>”。预主密钥是使用公钥加密的，只能使用服务器的私钥解密。（客户端从服务器的 SSL 证书中获得<a href="https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/">公钥</a>。），也就是说，客户端将使用公钥加密预主密钥，然后发送给服务端。</p></li><li><p><strong>私钥被使用</strong>：服务器使用自己的 <strong>私钥</strong> 对预主密钥进行解密。</p></li><li><p><strong>生成会话密钥</strong>：至此，客户端和服务端经过一系列信息交换后，各自都拥有了以下数据：</p><ol><li><p>客户端生成的随机数</p></li><li><p>服务端生成的随机数 </p></li><li><p>预主密钥</p></li></ol><p> 然后，客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成 <strong>会话密钥</strong>。双方应得到相同的结果。</p></li><li><p><strong>客户端就绪</strong>：客户端发送一条“已完成”消息，该消息用会话密钥加密。</p></li><li><p><strong>服务器就绪</strong>：服务器发送一条“已完成”消息，该消息用会话密钥加密。</p></li><li><p><strong>实现安全对称加密</strong>：已完成握手，并使用 <strong>会话密钥</strong> 继续进行通信，之后的通信都会使用该密钥，以 <strong>对称加密</strong> 的方式进行通信。</p></li></ol><p>具体的流程可以用下面这张图来概括：</p><blockquote><p>图片来源：<a href="https://segmentfault.com/a/1190000021559557">https://segmentfault.com/a/1190000021559557</a></p></blockquote><p><img src="https://raw.githubusercontent.com/autsu/diagrams/2d20c2027f78f57ae0087ea3b33de34456234cbf/img/tls%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B.png"></p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li><p>为什么不直接使用非对称加密进行通信？</p><p> 非对称加密的计算量比较大，加解密速度较慢，因此在数据量较大的情况下，使用非对称加密进行加解密会比较耗时，不利于高效的通信。而对称加密的计算量较小，加解密速度较快，可以很好地满足数据传输的需求。因此，<strong>TLS 在握手阶段使用非对称加密来协商对称密钥</strong>，并且之后的通信过程中使用对称加密方式，以保证通信的安全性和高效性。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入 url 到浏览器显示网页，期间发生了什么？（未完）</title>
    <link href="/2022/07/14/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/"/>
    <url>/2022/07/14/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/</url>
    
    <content type="html"><![CDATA[<ol><li><p>从请求 URL 中获取请求域名，通过 DNS 获取域名对应的 IP 地址</p><ol><li><p>首先需要知道 DNS <strong>域名服务器</strong> 的 IP 地址，这样才能给它发送 DNS 请求报文，而根据网络模型，光有 IP 地址是不够的，还需要知道 MAC 地址才能构建数据链路层的报文，所以需要通过 ARP 协议来根据 IP 获取对应的 MAC 地址。域名服务器的 IP 地址一般是默认配置好的，所以这里假定已经知道了 IP 地址，只需要获取 MAC 地址。</p><p>首先，主机会先检查一下自己的 ARP 表，看看有没有该 IP 缓存记录，有的话可以直接获取到对应的 MAC 地址，如果没有，就需要构建一个 ARP 请求报文，源 IP 和源 MAC 填写自己的，目的 IP 填写域名服务器的，目的 MAC 填写广播地址（FF-FF-FF-FF-FF-FF-FF），然后这个报文会发送给当前子网的所有主机，每个主机会查看报文里的目的 IP 地址是否与自己的 IP 地址相同，如果相同的话，就会回复 ARP 响应报文，里面有自己的 MAC 地址；如果不相同则会直接丢弃报文。主机获得域名服务器的 MAC 地址后，记录到自己的 ARP 表中，至此，主机已经获取到域名服务器的 MAC 地址了。</p></li><li><p>知道了域名服务器的 IP 地址和 MAC 地址后，就可以向其发送 DNS 请求报文了，DNS 请求报文在运输层被封装为 UDP 用户数据报，目的端口号为 53；UDP 用户数据报在网络层被封装为 IP 数据包，目的 IP 地址为域名服务器的 IP 地址；IP 数据报被封装在以太单播帧中发送，目的 MAC 地址为之前 ARP 请求获得的 MAC 地址，该单播帧通过交换机转发给本地域名服务器，本地域名服务器在收到报文后逐层解封，知道这是一个 DNS 请求，于是进入域名解析阶段。<del>给主机发送 DNS 响应报文，里面包含了域名对应的 IP 地址。</del></p></li></ol></li><li><p>域名解析</p><ol><li>根据域名的层级关系，由大到小为：<strong>根域、顶级域、权威域</strong>，层级代表的意思是：<del>高层级里面保存了下一层级的域名到 IP 的映射记录</del>，对应到域名是从右往左，也就是右边最大，左边最小，比如 <a href="http://www.baidu.com/">www.baidu.com</a> 这个域名，（最高层的根域在这个域名里没有体现出来，看了下别的博客，说的是实际是最后还有一个隐藏的 . 代表的就是根域名，这里暂时先不研究了），根域里保存的下一级顶级域的记录，也就是最右边的 .com 的记录，而 .com 又保存了 baidu.com 这个权威域的记录，最终再从 baidu.com 这个权威域里面找到最终的域名 <a href="http://www.baidu.com/">www.baidu.com</a> 的记录</li></ol></li><li><p>构建 HTTP 请求报文</p></li><li><p>运输层封装应用层的 HTTP 报文</p><ol><li>因为 HTTP 底层使用的运输层协议是 TCP，所以会将应用层的报文封装到一个 TCP 报文中，然后添加上 TCP 的报文头，目的端口通过请求的 URL 获取，如果没有指定，则使用 HTTP 默认的 80 端口，或者 HTTPS 的默认端口 443，源端口取决于是否显式指定，如果没有则会由系统随机分配一个。</li><li>然后就可以发起三次握手来建立连接了</li></ol></li><li><p>网络层封装传输层的 TCP 报文</p><ol><li>和运输层类似，将 TCP 报文封装到一个 IP 数据报中，添加上 IP 的报文头，源地址填写自己的 IP，目的地址填写之前从 DNS 获取到的 IP</li></ol></li><li><p>MAC</p><ol><li>可以通过 ARP 获取请求 IP 对应的 MAC 地址，这里有个问题：ARP 只能在一个子网内工作，如果请求的 IP 不是一个子网内的，此时该如何获取对应的 MAC 地址呢？原来在每个子网中，都配置了一台网关路由器，它连接了其他几个子网的交换机，当请求的 IP 不属于同一个子网时，就需要这台网关路由器来做转发（也就是将 MAC 地址填写为这个网关路由器的 MAC 地址），传递到另一个子网，具体如何转发取决于路由表，整个流程就像坐公交使用地图导航一样，选择一条路径，在不同的公交站间穿梭前进，网络也是这样的，多个子网相互连接组成一个大网络，数据报在这些互联的子网中选择一条道路前进，经过一个个子网，最终到达目的地。这里也发现了一个问题：<strong>在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</strong>可能这也是为什么需要 IP 和 MAC 两个地址的一点原因。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go mutex 原理</title>
    <link href="/2022/07/12/go-mutex-yuan-ma/"/>
    <url>/2022/07/12/go-mutex-yuan-ma/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<br><a href="https://www.bilibili.com/video/BV15V411n7fM?p=2&spm_id_from=pageDriver&vd_source=2ff613424b86c58a71ba91b7304ffe9b">https://www.bilibili.com/video/BV15V411n7fM?p=2&amp;spm_id_from=pageDriver&amp;vd_source=2ff613424b86c58a71ba91b7304ffe9b</a></p></blockquote><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>mutex 的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>state <span class="hljs-type">int32</span><br>sema  <span class="hljs-type">uint32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>mutex 零值可用，代表一个未锁定的锁。</p><p><code>state</code> 存储的是互斥锁的状态，加锁和解锁都是通过 cas 来实现的<br>加锁：atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)，其中 mutexLocked &#x3D; 1<br>解锁：atomic.AddInt32(&amp;m.state, -mutexLocked)，代表将 state 变为 0，因为只有加锁状态下才能解锁，如果对一个未加锁的锁执行解锁操作会 panic，而加锁状态下的 state &#x3D; 1，这个操作又是将 state - 1，所以会将 state 变为 0。</p><p><code>sema</code> 用作一个信号量，主要用作等待队列</p><p>mutex 有两种模式：<strong>正常模式</strong> 和 <strong>饥饿模式</strong></p><p>在 <strong>正常模式</strong> 下，一个尝试加锁的 goroutine 会先自旋几次，尝试通过原子操作获得锁，若几次自旋后仍然不能获得锁，则通过信号量排队等待（？啥叫通过信号量排队，信号量是如何工作的？），所有的等待者会按照先入先出的顺序排队。</p><p>但是当锁释放，第一个等待者被唤醒后并不会直接拥有锁，而是要和后来者竞争，后来者也就是新的 goroutine，它们处于自旋状态，且尚未排队，这些后来者因为占有了 CPU，且数量可能不少，而队列中被唤醒的 goroutine 只有一个，所以被唤醒的 goroutine 大概率抢不到锁，这种情况下，它会重新插入到队列的头部，而不是尾部。</p><p>当一个 goroutine 本次加锁等待时间超过了 1ms 后，它会把当前 mutex 从正常模式切换到 <strong>饥饿模式</strong>，<strong>在饥饿模式下，mutex 的所有权从执行 unlock 的 goroutine 直接传递给等待队列头部的 goroutine</strong>，后来者不会自旋，也不会尝试获得锁，而是直接到队尾排队等待。</p><p><strong>何时从饥饿模式切换到正常模式</strong><br>当一个等待者获得锁之后，它会在以下情况将锁从饥饿模式切换到正常模式：</p><ol><li>它的等待时间小于 1ms</li><li>它是队列的最后一个元素，也就是除自己以外没有其他等待者了，自然也就没有饥饿的 goroutine 了。</li></ol><p>正常模式下性能更好，但是可能会出现队列尾端的 goroutine 迟迟抢不到锁的情况，也就是尾端延迟，而饥饿模式下，goroutine 不再自旋，所有 goroutine 都要排队，严格的先来后到，可以有效解决尾端延迟问题，但是性能会差一些。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go chan 原理（人话版）</title>
    <link href="/2022/06/26/go-chan-yuan-ma/"/>
    <url>/2022/06/26/go-chan-yuan-ma/</url>
    
    <content type="html"><![CDATA[<h1 id="chan-原理（人话版）"><a href="#chan-原理（人话版）" class="headerlink" title="chan 原理（人话版）"></a>chan 原理（人话版）</h1><blockquote><p>说明：这里只是用大白话来阐述 chan 的大致原理，不保证严谨性，也不考虑一些繁枝细节（比如 sudog，gopark，goready），仅作为一个简单的参考理解，如果想深入理解 chan 的底层实现，请自行参阅其他博客</p></blockquote><p>chan 底层有两个队列：<code>sendq</code> 和 <code>recvq</code>，这两个队列保存的都是被阻塞的 goroutine（简称 g），顾名思义，<code>sendq</code> 里面保存的是因为发送操作而被阻塞的 g，而 <code>recvq</code> 保存的是因为接收操作被阻塞的 g，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>  ch &lt;- <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为没有接收者，所以 ch &lt;- 1 这个操作会被阻塞，那么就会把执行这个 chan 的 g 给放到 sendq 中</p><p>当执行 <strong>发送</strong> 操作时，会先看看 recvq 中有没有因为接收操作而被阻塞的 g，如果有的话，那么出队 g，并将数据拷贝给它，之后再将其唤醒；</p><p>同理，当执行 <strong>接收</strong> 操作时，会先看看 sendq 中有没有因为发送而被阻塞的 g，如果有，则执行和上面相同的操作。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>  ch &lt;- <span class="hljs-number">1</span><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    v := &lt;-ch<br>  &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>ch &lt;- 1 这个操作对应的 main goroutine 被阻塞，会放到 ch 的 sendq 中，之后的 &lt;-ch 会检查 ch 的 sendq，发现里面有元素，那么就将这个元素取出来，并将值拷贝给接收者 v，并唤醒 main goroutine ，让其不再是阻塞状态。</p><p>用过 chan 的同学都知道这是一个并发安全的数据结构，那么这里是如何实现的呢？其实也是加锁，chan 的底层有一个 mutex 锁来对其他字段进行保护。</p><p>此外，上面提到的发送和接收操作都是基于无缓存的 chan，如果是有缓存的 chan，那么流程会有所不同。</p><p>缓存（简称 buf）在底层其实是一个 <strong>环形队列</strong>，这是一个非常经典的数据结构，这里就不多阐述了，发送和接收的流程如下：</p><p><strong>发送</strong>：</p><ol><li>先看看 recvq 中有没有元素，有的话直接按照之前的操作，将数据拷贝给对应的接收者，就不需要经过缓存这一部分了</li><li>如果 recvq 中没有元素，则先检查缓存是否已满，则将数据拷贝到缓存中；如果缓存已满，那么将当前的 g 阻塞并放到 sendq 中</li></ol><p><strong>接收</strong>：</p><ol><li>如果 sendq 中有元素，此时又分为两种情况：<ol><li>无缓存 chan，直接取出 sendq 中的队头 g，并将 g 的数据拷贝给当前的接收者，并唤醒该 g</li><li>有缓存 chan，先从缓存中取出一个数据（通过 recvx 取出），并拷贝给接收者，此时缓存中相当于空了一个位置（环形队列，可以用覆盖值代替显式删除），所以可以取出 sendq 中的队头元素，放到这个空位里</li></ol></li><li>如果 sendq 为空：<ol><li>看缓存里有没有值，有的话则取出，并执行拷贝操作</li><li>缓存中没有值，将当前执行接收操作的 g 阻塞并放到 recvq 中</li></ol></li></ol><p>buf 底层是一个数组，通过两个变量 <code>sendx</code> 和 <code>recvx</code>  来完成 <strong>环形</strong> 的操作，通过下图来进行说明：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1656262263446.png"></p><h1 id="附：部分源码注释"><a href="#附：部分源码注释" class="headerlink" title="附：部分源码注释"></a>附：部分源码注释</h1><h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// channel 的数据结构</span><br><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 环形队列（buf）中元素的个数</span><br>qcount <span class="hljs-type">uint</span> <span class="hljs-comment">// total data in the queue</span><br><br><span class="hljs-comment">// 环形队列容量，即可以存放的元素个数</span><br><span class="hljs-comment">// 即 make(chan int, 2) 的第二个参数，如果不指定则为 0</span><br>dataqsiz <span class="hljs-type">uint</span> <span class="hljs-comment">// size of the circular queue</span><br><br><span class="hljs-comment">// 指针，指向环形队列头节点</span><br>buf unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span><br><br><span class="hljs-comment">// 队列中每个元素的大小</span><br>elemsize <span class="hljs-type">uint16</span><br><br><span class="hljs-comment">// chan 是否关闭</span><br>closed <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// 队列中的元素数据类型</span><br>elemtype *_type <span class="hljs-comment">// element type</span><br><br><span class="hljs-comment">// 队列已发送位置的索引</span><br>sendx <span class="hljs-type">uint</span> <span class="hljs-comment">// send index</span><br><br><span class="hljs-comment">// 队列已接收位置的索引</span><br>recvx <span class="hljs-type">uint</span> <span class="hljs-comment">// receive index</span><br><br><span class="hljs-comment">// sendq 和 recvq 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，</span><br><span class="hljs-comment">// 这些等待队列使用双向链表 runtime.waitq 表示：</span><br><span class="hljs-comment">// type waitq struct &#123;</span><br><span class="hljs-comment">//first *sudog</span><br><span class="hljs-comment">//last  *sudog</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 链表中所有的元素都是 runtime.sudog 结构：</span><br><br><span class="hljs-comment">// 等待读消息的 goroutine 队列</span><br><span class="hljs-comment">// 存储试图从 channel 接收数据(&lt;-ch)的阻塞 goroutines</span><br>recvq waitq <span class="hljs-comment">// list of recv waiters</span><br><br><span class="hljs-comment">// 等待写消息的 goroutine 队列</span><br><span class="hljs-comment">// 存储试图发送数据(ch&lt;-)到 channel 的阻塞 goroutines</span><br>sendq waitq <span class="hljs-comment">// list of send waiters</span><br><br><span class="hljs-comment">// lock protects all fields in hchan, as well as several</span><br><span class="hljs-comment">// fields in sudogs blocked on this channel.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Do not change another G&#x27;s status while holding this lock</span><br><span class="hljs-comment">// (in particular, do not ready a G), as this can deadlock</span><br><span class="hljs-comment">// with stack shrinking.</span><br>lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chansend"><a href="#chansend" class="headerlink" title="chansend"></a>chansend</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 发送数据到 channel 时，直观的理解是将数据放到 chan 的环形队列中，不过 go 做了一些优化：</span><br><span class="hljs-comment">// 先判断是否有等待接收数据的 groutine，如果有，直接将数据发给 Groutine，唤醒 groutine，</span><br><span class="hljs-comment">// 就不放入队列中了。当然还有另外一种情况就是：buf 如果满了，那就只能放到队列中等待，直到有</span><br><span class="hljs-comment">// 数据被取走才能发送。</span><br><br><span class="hljs-comment">// 核心逻辑：</span><br><span class="hljs-comment">// 如果 recvq 不为空，从 recvq 中取出一个等待接收数据的 Groutine，将数据发送给该 Groutine</span><br><span class="hljs-comment">// 如果 recvq 为空，才将数据放入 buf 中</span><br><span class="hljs-comment">// 如果 buf 已满，则将要发送的数据和当前的 Groutine 打包成 Sudog 对象放入 sendq，</span><br><span class="hljs-comment">// 并将 groutine 置为等待状态</span><br><br><span class="hljs-comment">// ep    指向要发送数据的首地址</span><br><span class="hljs-comment">// c     chan</span><br><span class="hljs-comment">// block 是否阻塞</span><br><span class="hljs-comment">// callerpc 调用地址</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 比较迷惑的是这个 block 参数，block 是为了实现如下代码的语义：</span><br><span class="hljs-comment">// 因为加了 default，所以是非阻塞</span><br><span class="hljs-comment">// c := make(chan int)</span><br><span class="hljs-comment">//        // ...</span><br><span class="hljs-comment">//    select &#123;</span><br><span class="hljs-comment">//    case &lt;-c:</span><br><span class="hljs-comment">//        // ...</span><br><span class="hljs-comment">//    default:</span><br><span class="hljs-comment">//        // ...</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 上面这段代码被编译成对 selectnbsend 的调用：</span><br><span class="hljs-comment">// if selectnbsend(c, v) &#123;</span><br><span class="hljs-comment">//    ... foo</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//    ... bar</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// selectnbsend 的实现如下</span><br><span class="hljs-comment">// func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) &#123;</span><br><span class="hljs-comment">// block 设置为 false</span><br><span class="hljs-comment">//    return chansend(c, elem, false, getcallerpc()) // 非阻塞的发送</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chansend: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// After observing that the channel is not closed, we observe that the channel is</span><br><span class="hljs-comment">// not ready for sending. Each of these observations is a single word-sized read</span><br><span class="hljs-comment">// (first c.closed and second full()).</span><br><span class="hljs-comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span><br><span class="hljs-comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span><br><span class="hljs-comment">// they imply a moment between the two when the channel was both not yet closed</span><br><span class="hljs-comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span><br><span class="hljs-comment">// and report that the send cannot proceed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span><br><span class="hljs-comment">// ready for sending and then observe that it is not closed, that implies that the</span><br><span class="hljs-comment">// channel wasn&#x27;t closed during the first observation. However, nothing here</span><br><span class="hljs-comment">// guarantees forward progress. We rely on the side effects of lock release in</span><br><span class="hljs-comment">// chanrecv() and closechan() to update this thread&#x27;s view of c.closed and full().</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 加锁</span><br>lock(&amp;c.lock)<br><br><span class="hljs-comment">// 如果向已关闭的 channel 中发送数据，会引发 panic</span><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// blog1. 从接收队列中（存放等待接收的 goroutine）取出 goroutine，</span><br><span class="hljs-comment">// 如果取到数据，就将数据传过去</span><br><br><span class="hljs-comment">// blog3. 如果目标 Channel 没有被关闭并且已经有处于读等待的 Goroutine，</span><br><span class="hljs-comment">// 那么 runtime.chansend 会从接收队列 recvq 中取出最先陷入等待的 Goroutine</span><br><span class="hljs-comment">// 并直接向它发送数据：</span><br><br><span class="hljs-comment">// 如果 recvq 不为空，从 recvq 中取出一个等待接收数据的 Groutine，将数据发送给该 Groutine</span><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span><br><span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="hljs-comment">// 找到一个等待的接收者。我们将要发送的值直接传递给接收者，绕过 chan buf（如果有）</span><br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 返回</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明 recvq 为空，没有等待接收的 goroutine，此时会判断 hchan.buf 是否可用</span><br><span class="hljs-comment">// 对于有缓冲的 channel 来说，如果当前缓冲区 hchan.buf 有可用空间，那么会将数据拷贝至缓冲区</span><br><span class="hljs-comment">// 如果用户使用的是无缓冲 channel，则 c.dataqsiz = 0，不满足 c.qcount &lt; c.dataqsiz 条件</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br><span class="hljs-comment">// c.sendx 是已发送的索引位置，这个方法通过指针偏移找到索引位置</span><br><span class="hljs-comment">// 相当于 c.buf[c.sendx]</span><br><span class="hljs-comment">// 计算出下一个可以存储数据的位置</span><br><span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span><br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// typememmove 会调用 memmove 方法，完成数据的拷贝工作，是用汇编实现的</span><br><span class="hljs-comment">// 将要发送的数据拷贝到 buf 中</span><br>typedmemmove(c.elemtype, qp, ep)<br><span class="hljs-comment">// 发送索引号 + 1</span><br>c.sendx++<br><span class="hljs-comment">// 因为存储数据元素的结构是循环队列，所以当当前索引号已经到队末时，将索引号调整到队头</span><br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">// 当前循环队列中存储元素数 + 1</span><br>c.qcount++<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 走到这里，说明缓冲区也写满了</span><br><span class="hljs-comment">// 对于非阻塞的情况，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 代码执行到这里，意味着：</span><br><span class="hljs-comment">// 1. 如果是有缓冲的 channel，则当前 hchan.buf 已满；</span><br><span class="hljs-comment">// 2. 如果是无缓冲的 channel，则当前没有接收的 goroutine</span><br><span class="hljs-comment">// 此时会将当前发送 goroutine 置于 sendq 中排队，并在运行时中挂起。</span><br><span class="hljs-comment">// Block on the channel. Some receiver will complete our operation for us.</span><br>gp := getg() <span class="hljs-comment">// 获取当前执行的 goroutine</span><br><br><span class="hljs-comment">// 执行 runtime.acquireSudog 获取 runtime.sudog 结构并设置这一次阻塞发送的相关信息，</span><br><span class="hljs-comment">// 例如发送的 Channel、是否在 select 中和待发送数据的内存地址等</span><br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">// 将要发送的数据和当前 goroutine 打包成 sudog 对象放入到 sendq 中</span><br>c.sendq.enqueue(mysg)<br><span class="hljs-comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span><br><span class="hljs-comment">// to park on a channel. The window between when this G&#x27;s status</span><br><span class="hljs-comment">// changes and when we set gp.activeStackChans is not safe for</span><br><span class="hljs-comment">// stack shrinking.</span><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// gopark 将当前 goroutine 转为 waiting 态</span><br><span class="hljs-comment">// 在用户看来，向 channel 发送数据的代码语句会阻塞</span><br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// Ensure the value being sent is kept alive until the</span><br><span class="hljs-comment">// receiver copies it out. The sudog has a pointer to the</span><br><span class="hljs-comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span><br><span class="hljs-comment">// stack tracer.</span><br>KeepAlive(ep)<br><br><span class="hljs-comment">// someone woke us up.</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="send"><a href="#send" class="headerlink" title="send"></a>send</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// send processes a send operation on an empty channel c.</span><br><span class="hljs-comment">// The value ep sent by the sender is copied to the receiver sg.</span><br><span class="hljs-comment">// The receiver is then woken up to go on its merry way.</span><br><span class="hljs-comment">// Channel c must be empty and locked.  send unlocks c with unlockf.</span><br><span class="hljs-comment">// sg must already be dequeued from c.</span><br><span class="hljs-comment">// ep must be non-nil and point to the heap or the caller&#x27;s stack.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// send 在 recvq 不为空时调用，sg 就是从 recvq 中取出的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br>racesync(c, sg)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Pretend we go through the buffer, even though</span><br><span class="hljs-comment">// we copy directly. Note that we need to increment</span><br><span class="hljs-comment">// the head/tail locations only when raceenabled.</span><br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>racenotify(c, c.recvx, sg)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// ep -&gt; sg</span><br>sendDirect(c.elemtype, sg, ep)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 使得之前在接收等待队列中的第一个 goroutine 的状态变为 runnable，</span><br><span class="hljs-comment">// 这样 go 的调度器就可以重新让该 goroutine 得到执行。</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chanrecv"><a href="#chanrecv" class="headerlink" title="chanrecv"></a>chanrecv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// chanrecv receives on channel c and writes the received data to ep.</span><br><span class="hljs-comment">// ep may be nil, in which case received data is ignored.</span><br><span class="hljs-comment">// If block == false and no elements are available, returns (false, false).</span><br><span class="hljs-comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span><br><span class="hljs-comment">// Otherwise, fills in *ep with an element and returns (true, true).</span><br><span class="hljs-comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在通道 c 上接收并将接收到的数据写入 ep，ep 可能为 nil，在这种情况下，接收到的数据会被忽略，</span><br><span class="hljs-comment">// 如果 block == false 并且没有可用的元素，则返回 (false, false)，</span><br><span class="hljs-comment">// 否则，如果 c 关闭，则将 ep 清零并返回 (true, false)。</span><br><span class="hljs-comment">// 否则，用一个元素填充 ep 并返回 (true, true)。</span><br><span class="hljs-comment">// 非 nil ep 必须指向堆或调用者的堆栈。</span><br><span class="hljs-comment">// block 貌似是用于 select</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span><br><span class="hljs-comment">// or is new memory allocated by reflect.</span><br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chanrecv: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果 c 为空且是非阻塞调用，那么直接返回 (false,false)</span><br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 阻塞调用直接等待</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-comment">// After observing that the channel is not ready for receiving, we observe whether the</span><br><span class="hljs-comment">// channel is closed.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Reordering of these checks could lead to incorrect behavior when racing with a close.</span><br><span class="hljs-comment">// For example, if the channel was open and not empty, was closed, and then drained,</span><br><span class="hljs-comment">// reordered reads could incorrectly indicate &quot;open and empty&quot;. To prevent reordering,</span><br><span class="hljs-comment">// we use atomic loads for both checks, and rely on emptying and closing to happen in</span><br><span class="hljs-comment">// separate critical sections under the same lock.  This assumption fails when closing</span><br><span class="hljs-comment">// an unbuffered channel with a blocked send, but that is an error condition anyway.</span><br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Because a channel cannot be reopened, the later observation of the channel</span><br><span class="hljs-comment">// being not closed implies that it was also not closed at the moment of the</span><br><span class="hljs-comment">// first observation. We behave as if we observed the channel at that moment</span><br><span class="hljs-comment">// and report that the receive cannot proceed.</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// The channel is irreversibly closed. Re-check whether the channel has any pending data</span><br><span class="hljs-comment">// to receive, which could have arrived between the empty and closed checks above.</span><br><span class="hljs-comment">// Sequential consistency is also required here, when racing with such a send.</span><br><span class="hljs-keyword">if</span> empty(c) &#123;<br><span class="hljs-comment">// The channel is irreversibly closed and empty.</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 如果 sendq 中有 goroutine，则取出一个，将数据发送给它</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Found a waiting sender. If buffer is size 0, receive value</span><br><span class="hljs-comment">// directly from sender. Otherwise, receive from head of queue</span><br><span class="hljs-comment">// and add sender&#x27;s value to the tail of the queue (both map to</span><br><span class="hljs-comment">// the same buffer slot because the queue is full).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果是无缓冲 chan，则直接从 sg 中接收数据，</span><br><span class="hljs-comment">// 如果是有缓冲 chan，则接收 buf 中第一个元素的数据，并将 sg 中的数据放到 buf 的末尾</span><br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明 sendq 中没有等待的 goroutine</span><br><br><span class="hljs-comment">// 如果缓冲区中有数据，那么就从 buf 中获取</span><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Receive directly from queue</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-comment">// 从缓冲区复制数据到 ep</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// typedmemclr 的作用是将 ep 指向的类型为 elemtype 的内存块置为 0 值。</span><br><span class="hljs-comment">// 这里就是将 buf[recvx] 置为 0，因为这里的元素已经拷贝给了 ep</span><br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 非阻塞，直接返回</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明即没有等待的 groutine，环形队列中也没有数据，则阻塞该 groutine，</span><br><span class="hljs-comment">// 并将 goroutine 打包为 sudog 加入到 recevq 等待队列中</span><br><span class="hljs-comment">// no sender available: block on this channel.</span><br>gp := getg()<br><span class="hljs-comment">// 创建 sudog</span><br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span><br><span class="hljs-comment">// on gp.waiting where copystack can find it.</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>c.recvq.enqueue(mysg)<br><span class="hljs-comment">// Signal to anyone trying to shrink our stack that we&#x27;re about</span><br><span class="hljs-comment">// to park on a channel. The window between when this G&#x27;s status</span><br><span class="hljs-comment">// changes and when we set gp.activeStackChans is not safe for</span><br><span class="hljs-comment">// stack shrinking.</span><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// someone woke us up</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// recv processes a receive operation on a full channel c.</span><br><span class="hljs-comment">// There are 2 parts:</span><br><span class="hljs-comment">// 1) The value sent by the sender sg is put into the channel</span><br><span class="hljs-comment">//    and the sender is woken up to go on its merry way.</span><br><span class="hljs-comment">// 2) The value received by the receiver (the current G) is</span><br><span class="hljs-comment">//    written to ep.</span><br><span class="hljs-comment">// For synchronous channels, both values are the same.</span><br><span class="hljs-comment">// For asynchronous channels, the receiver gets its data from</span><br><span class="hljs-comment">// the channel buffer and the sender&#x27;s data is put in the</span><br><span class="hljs-comment">// channel buffer.</span><br><span class="hljs-comment">// Channel c must be full and locked. recv unlocks c with unlockf.</span><br><span class="hljs-comment">// sg must already be dequeued from c.</span><br><span class="hljs-comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// recv 被 chanrecv() 调用，调用条件是 sendq 中有等待的 g</span><br><span class="hljs-comment">// c: chan</span><br><span class="hljs-comment">// sg: sendq 中的等待 goroutine</span><br><span class="hljs-comment">// ep: 用来接收数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 如果是无缓冲区 chan</span><br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racesync(c, sg)<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// copy data from sender</span><br><span class="hljs-comment">// 将 sg（sendq 中的对象）中的数据拷贝到 ep 中</span><br>recvDirect(c.elemtype, sg, ep)<br>&#125;<br><span class="hljs-comment">// 有缓冲区chan</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Queue is full. Take the item at the</span><br><span class="hljs-comment">// head of the queue. Make the sender enqueue</span><br><span class="hljs-comment">// its item at the tail of the queue. Since the</span><br><span class="hljs-comment">// queue is full, those are both the same slot.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 由于有发送者在等待，所以缓冲区一定是满的，因为 recv 的第二个参数 sudog</span><br><span class="hljs-comment">// 传入的是被阻塞的发送者，在 chanrecv 中的表现是：</span><br><span class="hljs-comment">// if sg := c.sendq.dequeue(); sg != nil &#123;</span><br><span class="hljs-comment">// recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="hljs-comment">//return true, true</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>racenotify(c, c.recvx, sg)<br>&#125;<br><span class="hljs-comment">// copy data from queue to receiver</span><br><span class="hljs-comment">// 先将 buf 中的第一个数据（recvx）移动到 ep</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// copy data from sender to queue</span><br><span class="hljs-comment">// 因为已经将 buf 中的一个数据拷贝给 ep 了，等于此时的 ep 已经空了一个</span><br><span class="hljs-comment">// 位置了，所以可以将 sudog 中的元素放到这个空位置里</span><br><span class="hljs-comment">// 下面的逻辑也没有对 c.qcount 进行更新，因为移除了一个后又新添加了一个,</span><br><span class="hljs-comment">// 相当于长度没有发生改变</span><br>typedmemmove(c.elemtype, qp, sg.elem)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>127.0.0.1，localhost，0.0.0.0 的区别（包含虚拟网卡相关操作）</title>
    <link href="/2022/06/24/127.0.0.1_localhost_0.0.0.0/"/>
    <url>/2022/06/24/127.0.0.1_localhost_0.0.0.0/</url>
    
    <content type="html"><![CDATA[<h1 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h1><p><code>127.0.0.1</code> 是 <strong>回环地址</strong>，当报文的目的地址是回环地址时，依然会走一遍网络协议栈，但是不会经过物理网卡，而是经过一个名为 lo 的虚拟网卡（mac 上交 lo0），具体的流程是：</p><p>从应用层到传输层再到网络层，到了网络层，系统会根据目的IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。</p><p>当发现 <strong>目标IP是外网IP</strong> 时，会从”真网卡”发出。</p><p>当发现 <strong>目标IP是回环地址</strong> 时，就会选择 <strong>本地网卡</strong>。</p><p>本地网卡，其实就是个”<strong>假网卡</strong>“，它不像”真网卡”那样有个<code>ring buffer</code>什么的，”假网卡”会把数据推到一个叫 <code>input_pkt_queue</code> 的 <strong>链表</strong> 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个 <strong>软中断</strong>。</p><p>专门处理软中断的工具人”<strong>ksoftirqd</strong>“ （这是个<strong>内核线程</strong>），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</p><p><strong>之所以把 127.0.0.1 叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，而是在本机打个转就又回来了</strong>。所以即便断网，也依然能 <code>ping</code> 通 <code>127.0.0.1</code>。</p><p>以上内容摘自：</p><p>硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？<a href="https://www.eet-china.com/mp/a67490.html">https://www.eet-china.com/mp/a67490.html</a></p><blockquote><p>问题记录：</p><p>ping 127.0.0.1 走不走物理网卡？</p><p>网上的博客有说走的（<a href="https://blog.csdn.net/bandaoyu/article/details/87259631%EF%BC%8C">https://blog.csdn.net/bandaoyu/article/details/87259631，</a> 127.0.0.1 回环地址，不经过[链路层，<a href="https://so.csdn.net/so/search?q=%E7%89%A9%E7%90%86%E5%B1%82&spm=1001.2101.3001.7020">物理层</a>](网络接口层），在IP层就回去，依赖网卡，并受到网络防火墙和网卡相关的限制），也有说不走的，这时只能自己动手测试了，刚好有台闲置的 windows 笔记本可以拿来测试，执行 <code>netsh interface set interface wlan diable</code> 来关闭网卡，此时执行 <code>ping 127.0.0.1</code>，发现是可以 ping 通的，说明 127.0.0.1 是不走物理网卡的，但是会走 lo 虚拟网卡</p><p><a href="https://www.zhihu.com/question/43590414">https://www.zhihu.com/question/43590414</a></p></blockquote><h1 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h1><p>localhost是个 <strong>域名</strong> ，而不是一个 ip 地址。之所以我们经常把 localhost 与 127.0.0.1 认为是同一个东西，是因为我们使用的大多数电脑上都将 localhost 指向了 127.0.0.1 这个地址，在 linux 中这个文件的位置是 &#x2F;etc&#x2F;hosts ： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /etc/hosts</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Your system has configured <span class="hljs-string">&#x27;manage_etc_hosts&#x27;</span> as True.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">As a result, <span class="hljs-keyword">if</span> you wish <span class="hljs-keyword">for</span> changes to this file to persist</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">then</span> you will need to either</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">a.) make changes to the master file <span class="hljs-keyword">in</span> /etc/cloud/templates/hosts.debian.tmpl</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">b.) change or remove the value of <span class="hljs-string">&#x27;manage_etc_hosts&#x27;</span> <span class="hljs-keyword">in</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    /etc/cloud/cloud.cfg or cloud-config from user-data</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">127.0.1.1 primary primary</span><br>127.0.0.1 localhost<br></code></pre></td></tr></table></figure><h1 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h1><p><code>0.0.0.0</code> 可以作为监听地址使用，代表监听本机的所有 IP 地址（如果一台机器上有多个网卡，就会有多个 IP 地址），可以做一个实践测试一下：</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>创建一块虚拟网卡（在虚拟机上）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig enp0s1:0 192.168.64.8 up</span><br></code></pre></td></tr></table></figure><p>语句格式是：ifconfig [现有网卡名称]:[任意值,也可以为空] [虚拟网卡的 IP] up</p><p>按照上面的格式，继续创建多块虚拟网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig enp0s1: 192.168.64.9 up</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig enp0s1:__ 192.168.64.10 up</span><br></code></pre></td></tr></table></figure><p>查看现在的网卡情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig</span><br>enp0s1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.7  netmask 255.255.255.0  broadcast 192.168.64.255<br>        inet6 fe80::5054:ff:fe97:e2bd  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        inet6 fd02:feab:6557:b7c6:5054:ff:fe97:e2bd  prefixlen 64  scopeid 0x0&lt;global&gt;<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br>        RX packets 45586  bytes 61327352 (61.3 MB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 27086  bytes 2915213 (2.9 MB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>enp0s1:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.8  netmask 255.255.255.0  broadcast 192.168.64.255<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br><br>enp0s1:: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.9  netmask 255.255.255.0  broadcast 192.168.64.255<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br><br>enp0s1:__: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.64.10  netmask 255.255.255.0  broadcast 192.168.64.255<br>        ether 52:54:00:97:e2:bd  txqueuelen 1000  (Ethernet)<br></code></pre></td></tr></table></figure><p>用 Go 写一个 TCP server 进行测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net&quot;</span><br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;flag&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> host = flag.String(<span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;listen host&quot;</span>)<br><span class="hljs-keyword">var</span> port = flag.String(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;listen port&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        flag.Parse()<br>        addr := fmt.Sprintf(<span class="hljs-string">&quot;%v:%v&quot;</span>, *host, *port)<br>        l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>        fmt.Printf(<span class="hljs-string">&quot;listen in %v\n&quot;</span>, addr)<br>        <span class="hljs-keyword">for</span> &#123;<br>                conn, err := l.Accept()<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                        fmt.Println(<span class="hljs-string">&quot;accept error: &quot;</span>, err)<br>                        <span class="hljs-keyword">continue</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> _, err := conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>                        fmt.Println(<span class="hljs-string">&quot;write error: &quot;</span>, err)<br>                        <span class="hljs-keyword">continue</span><br>                &#125;<br>                conn.Close()<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序（虚拟机上）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run hello_tcpserver.go -h 0.0.0.0</span><br>listen in 0.0.0.0:8080<br></code></pre></td></tr></table></figure><p>在 <strong>宿主机</strong> 上测试一下效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.7 8080</span><br>Hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.8 8080</span><br>Hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.9 8080</span><br>Hello<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.10 8080</span><br>Hello<br></code></pre></td></tr></table></figure><p>发现使用任意一个 IP 地址都可以访问到服务</p><p>此外，有的博客里说 <code>0.0.0.0</code> 是 ping 不通的，但是在我的虚拟机上却并非如此：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">uname</span> -a</span><br>Linux primary 5.4.0-120-generic #136-Ubuntu SMP Fri Jun 10 13:46:10 UTC 2022 aarch64 aarch64 aarch64 GNU/Linux<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping 0.0.0.0</span><br>PING 0.0.0.0 (127.0.0.1) 56(84) bytes of data.<br>64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.299 ms<br>64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.091 ms<br>64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.076 ms<br>64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.108 ms<br>^C<br>--- 0.0.0.0 ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 3244ms<br>rtt min/avg/max/mdev = 0.076/0.143/0.299/0.090 ms<br></code></pre></td></tr></table></figure><p>不知道什么情况</p><blockquote><p>监听 127.0.0.1 和 监听 0.0.0.0 有什么区别？</p><p>监听 127.0.0.1 的话就只能在本地访问了，外部是无法访问的，localhost 当然也是一样的</p><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run hello_tcpserver.go -h localhost</span><br>listen in localhost:8080<br></code></pre></td></tr></table></figure><p>在宿主机上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc -v 192.168.64.9 8080</span><br>nc: connectx to 192.168.64.9 port 8080 (tcp) failed: Connection refused<br></code></pre></td></tr></table></figure><p>说到这里又让我想起了一件事：之前我部署过一个 Go HTTP 小程序到腾讯云服务器上，当时 listen 的地址就是 localhost，但是从外部依然能够访问到该服务，貌似是因为当时是用 docker 部署的，做了端口映射，所以才可以访问到</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 熔断器 gobreaker 源码阅读</title>
    <link href="/2022/06/11/gobreaker/"/>
    <url>/2022/06/11/gobreaker/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该文章仅作为本人笔记，不具备太大的参考价值</p><p>该文章着重记录源码，没有对熔断器这一概念做过多理念上的说明解释</p><p>该文章排版、思路较为混乱，后续可能会进行修改</p></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><p>官方示例有点太简单了，完全无法体会到 <strong>熔断</strong> 这一概念</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/sony/gobreaker&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> cb *gobreaker.CircuitBreaker<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> st gobreaker.Settings<br>st.Name = <span class="hljs-string">&quot;HTTP GET&quot;</span><br>st.ReadyToTrip = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts gobreaker.Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br>failureRatio := <span class="hljs-type">float64</span>(counts.TotalFailures) / <span class="hljs-type">float64</span>(counts.Requests)<br><span class="hljs-keyword">return</span> counts.Requests &gt;= <span class="hljs-number">3</span> &amp;&amp; failureRatio &gt;= <span class="hljs-number">0.6</span><br>&#125;<br><br>cb = gobreaker.NewCircuitBreaker(st)<br>&#125;<br><br><span class="hljs-comment">// Get wraps http.Get in CircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>body, err := cb.Execute(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>body, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body.([]<span class="hljs-type">byte</span>), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>body, err := Get(<span class="hljs-string">&quot;http://www.google.com/robots.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Println(<span class="hljs-type">string</span>(body))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="我的示例"><a href="#我的示例" class="headerlink" title="我的示例"></a>我的示例</h2><p>先写一个 http server，他会随机为请求返回 200 或者 500</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> canVisit <span class="hljs-type">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().Unix())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>t := rand.Int63n(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Duration(t) * time.Second):<br>canVisit = !canVisit<br>&#125;<br>&#125;<br>&#125;()<br><br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> canVisit &#123;<br>w.WriteHeader(http.StatusInternalServerError)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;server error&quot;</span>))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>w.WriteHeader(http.StatusOK)<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;success&quot;</span>))<br>&#125;<br>&#125;)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:9000&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>熔断器程序，会一直访问上面的 http server，返回 200 算请求成功，500 算失败，来观察熔断器的状态和效果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-string">&quot;github.com/sony/gobreaker&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> cb *gobreaker.CircuitBreaker<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> st gobreaker.Settings<br>st.Name = <span class="hljs-string">&quot;HTTP GET&quot;</span><br>st.ReadyToTrip = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts gobreaker.Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br>failureRatio := <span class="hljs-type">float64</span>(counts.TotalFailures) / <span class="hljs-type">float64</span>(counts.Requests)<br><span class="hljs-keyword">return</span> counts.Requests &gt;= <span class="hljs-number">3</span> &amp;&amp; failureRatio &gt;= <span class="hljs-number">0.5</span><br>&#125;<br>st.Timeout = time.Second * <span class="hljs-number">10</span><span class="hljs-comment">// 从开启切换到半开的时间</span><br>st.OnStateChange = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from, to gobreaker.State)</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;state change: [%v] -&gt; [%v]\n&quot;</span>, from, to)<br>&#125;<br>cb = gobreaker.NewCircuitBreaker(st)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>body, err := cb.Execute(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><span class="hljs-keyword">if</span> resp.StatusCode &gt;= <span class="hljs-number">400</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;[%v]%v&quot;</span>, resp.StatusCode, http.StatusText(resp.StatusCode))<br>&#125;<br>body, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> body, <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> body.([]<span class="hljs-type">byte</span>), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>body, err := Get(<span class="hljs-string">&quot;http://localhost:9000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;%v, %+v\n&quot;</span>, cb.State(), cb.Counts())<br>fmt.Println(<span class="hljs-type">string</span>(body))<br>time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/06/10 22:02:36 closed, &#123;Requests:1 TotalSuccesses:1 TotalFailures:0 ConsecutiveSuccesses:1 ConsecutiveFailures:0&#125;<br>....<br><br>2022/06/10 22:03:26 [500]Internal Server Error<br>2022/06/10 22:03:26 closed, &#123;Requests:101 TotalSuccesses:51 TotalFailures:50 ConsecutiveSuccesses:0 ConsecutiveFailures:8&#125;<br><br>2022/06/10 22:03:26 state change: [closed] -&gt; [open]<br>2022/06/10 22:03:26 [500]Internal Server Error<br>2022/06/10 22:03:26 open, &#123;Requests:0 TotalSuccesses:0 TotalFailures:0 ConsecutiveSuccesses:0 ConsecutiveFailures:0&#125;<br></code></pre></td></tr></table></figure><p>第二段日志记录了错误，此时的总请求次数是 101，总错误是 50，还没达到 ReadyToTrip 的条件（错误率 &gt;&#x3D; 50%），然后第三段日志，发现此时请求依然失败，此时总请求 102，总错误 51，达到了 50%，所以发生了状态转换，熔断器进行开启模式。</p><p>后续应该会一直保持开启状态，直到 10s 后切换为半开状态，这里日志就没记录了。</p><h1 id="熔断器的-3-种状态"><a href="#熔断器的-3-种状态" class="headerlink" title="熔断器的 3 种状态"></a>熔断器的 3 种状态</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// State is a type that represents a state of CircuitBreaker.</span><br><span class="hljs-keyword">type</span> State <span class="hljs-type">int</span><br><br><span class="hljs-comment">// These constants are states of CircuitBreaker.</span><br><span class="hljs-comment">// 熔断器的状态</span><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// StateClosed 表示关闭状态，此时所有请求都会通过</span><br>StateClosed State = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// StateHalfOpen 半开状态，会根据情况变更为开启或者关闭状态</span><br>StateHalfOpen<br><span class="hljs-comment">// StateOpen 开启状态，此时会拒绝所有请求</span><br>StateOpen<br>)<br></code></pre></td></tr></table></figure><p>熔断器有三种状态：</p><ul><li>开启：所有请求都会拒绝</li><li>关闭：所有请求都会通过</li><li>半开启：开启状态自然不能一直维持，需要某个条件将其切换到一种中间状态：也就是这里的半开启状态。当开启状态持续了一段时间后，就会变更为半开启状态，表示可以做试探了，如果此时请求依然失败，则变更为开启状态；如果成功次数达到了我们的需求，则变更为关闭状态</li></ul><h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><p>计数器保存了熔断器的所有信息，具体属性如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Counts 保存请求的数量及其成功失败的次数。</span><br><span class="hljs-comment">// CircuitBreaker 在状态更改或关闭状态间隔时清除内部计数。</span><br><span class="hljs-comment">// Counts 会忽略在清除之前发送的请求的结果。</span><br><span class="hljs-keyword">type</span> Counts <span class="hljs-keyword">struct</span> &#123;<br>Requests             <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总请求次数</span><br>TotalSuccesses       <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总成功次数</span><br>TotalFailures        <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总失败次数</span><br>ConsecutiveSuccesses <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续成功次数</span><br>ConsecutiveFailures  <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续失败次数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外还提供了一些列更新计数的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onRequest() &#123;<br>c.Requests++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onSuccess() &#123;<br>c.TotalSuccesses++<br>c.ConsecutiveSuccesses++<br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onFailure() &#123;<br>c.TotalFailures++<br>c.ConsecutiveFailures++<br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> clear() &#123;<br>c.Requests = <span class="hljs-number">0</span><br>c.TotalSuccesses = <span class="hljs-number">0</span><br>c.TotalFailures = <span class="hljs-number">0</span><br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h1><p>CircuitBreaker 定义了熔断器结构体，这也是最核心的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CircuitBreaker is a state machine to prevent sending requests that are likely to fail.</span><br><span class="hljs-keyword">type</span> CircuitBreaker <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 虚线内的属性和 Settings 中的相同，如果 Settings 中没有设置，则使用默认值来填充</span><br><span class="hljs-comment">// ==================</span><br>name        <span class="hljs-type">string</span><br>  <span class="hljs-comment">// 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>maxRequests <span class="hljs-type">uint32</span><br>  <br><span class="hljs-comment">// 关闭状态下定期清空计数的时间，如果为 0，则不清空</span><br>  <span class="hljs-comment">// 这里我不太明白清空计数的原因，在网上找了一个分析，意思是如果一直处于成功状态，</span><br><span class="hljs-comment">// 那么计数的意义就不是很大，此外如果请求量过大可能会导致溢出，所以需要定期清空</span><br>interval      time.Duration<br>  <br><span class="hljs-comment">// 打开状态的持续时间，到时后会变更为半打开状态。</span><br>timeout time.Duration<br>  <br><span class="hljs-comment">// 关闭状态下会调用该回调函数，如果返回 true，则进入打开状态</span><br>readyToTrip   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br>  <br>  <span class="hljs-comment">// 用来判断请求是否成功的回调函数</span><br>isSuccessful  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br>  <br>  <span class="hljs-comment">// 发生状态变更时的回调函数</span><br>onStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br>  <span class="hljs-comment">// ====================</span><br><br>mutex      sync.Mutex<br>state      State<br>generation <span class="hljs-type">uint64</span><br>counts     Counts<br>  <span class="hljs-comment">// 这个变量貌似有两种情况：</span><br><span class="hljs-comment">// 1. 开启状态下，代表切换到半开启的绝对时间（time.Time 代表一个绝对时间）</span><br><span class="hljs-comment">//    具体值是 time.Now + timeout</span><br><span class="hljs-comment">// 2. 关闭状态下，代表进入下一个周期的绝对时间（进入下一个周期会清空计数）</span><br><span class="hljs-comment">//   具体值是 time.Now + interval</span><br>expiry time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的一部分值是通过配置类来指定的，如果不指定则会设置为默认配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCircuitBreaker</span><span class="hljs-params">(st Settings)</span></span> *CircuitBreaker &#123;<br>cb := <span class="hljs-built_in">new</span>(CircuitBreaker)<br><br>cb.name = st.Name<br>cb.onStateChange = st.OnStateChange<br><br><span class="hljs-keyword">if</span> st.MaxRequests == <span class="hljs-number">0</span> &#123;<br>cb.maxRequests = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.maxRequests = st.MaxRequests<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Interval &lt;= <span class="hljs-number">0</span> &#123;<br>cb.interval = defaultInterval<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.interval = st.Interval<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Timeout &lt;= <span class="hljs-number">0</span> &#123;<br>cb.timeout = defaultTimeout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.timeout = st.Timeout<br>&#125;<br><br><span class="hljs-keyword">if</span> st.ReadyToTrip == <span class="hljs-literal">nil</span> &#123;<br>cb.readyToTrip = defaultReadyToTrip<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.readyToTrip = st.ReadyToTrip<br>&#125;<br><br><span class="hljs-keyword">if</span> st.IsSuccessful == <span class="hljs-literal">nil</span> &#123;<br>cb.isSuccessful = defaultIsSuccessful<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.isSuccessful = st.IsSuccessful<br>&#125;<br><br>cb.toNewGeneration(time.Now())<br><br><span class="hljs-keyword">return</span> cb<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Settings <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 熔断器的名称</span><br>Name <span class="hljs-type">string</span><br><br><span class="hljs-comment">// MaxRequests 是 CircuitBreaker 半开时允许通过的最大请求数。</span><br><span class="hljs-comment">// 如果 MaxRequests 为 0，则 CircuitBreaker 只允许 1 个请求。</span><br><span class="hljs-comment">// FIXME 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>MaxRequests <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// Interval 是熔断器处于关闭状态时，定期清除内部 Counts 的时间。</span><br><span class="hljs-comment">// 如果 Interval 小于或等于 0，CircuitBreaker 在关闭状态期间不会清除内部计数。</span><br><span class="hljs-comment">// FIXME 这个东西暂时没发现用处何在</span><br><span class="hljs-comment">// 在网上找了一个分析，意思是如果一直处于成功状态，那么计数的意义就不是很大，</span><br><span class="hljs-comment">// 需要定期清空，不然可能会溢出</span><br>Interval time.Duration<br><br><span class="hljs-comment">// Timeout 是打开状态的持续时间，到时后会变更为半打开状态。</span><br><span class="hljs-comment">// 如果 Timeout 小于或等于 0，则将 CircuitBreaker 的超时值设置为 60 秒。</span><br>Timeout time.Duration<br><br><span class="hljs-comment">// 每当请求在关闭状态下失败时，就会调用 ReadyToTrip，参数传递的是 Counts 的副本。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 返回 true，CircuitBreaker 将进入打开状态。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 为 nil，则使用默认 ReadyToTrip。</span><br><span class="hljs-comment">// 当连续失败次数超过 5 次时，默认 ReadyToTrip 返回 true。</span><br>ReadyToTrip <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// OnStateChange 是熔断器状态变更时的回调函数</span><br>OnStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br><br><span class="hljs-comment">// IsSuccessful 判断请求是否成功，传入的 err 是执行用户请求函数后返回的。</span><br><span class="hljs-comment">// （也就是 CircuitBreaker.Execute 的参数 req）</span><br><span class="hljs-comment">// 如果 IsSuccessful 返回 true， 则说明请求发生了错误，否则说明没有错误。</span><br><span class="hljs-comment">// 如果 IsSuccessful 为 nil， 则使用默认 IsSuccessful，该默认函数的逻辑是：</span><br><span class="hljs-comment">// if err == nil &#123; return true &#125;</span><br>IsSuccessful <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> defaultInterval = time.Duration(<span class="hljs-number">0</span>) * time.Second<br><span class="hljs-keyword">const</span> defaultTimeout = time.Duration(<span class="hljs-number">60</span>) * time.Second<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultReadyToTrip</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> counts.ConsecutiveFailures &gt; <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultIsSuccessful</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> err == <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h1><p>一共有一下几种状态转换：</p><ul><li>关闭 -&gt; 开启</li><li>开启 -&gt; 半开</li><li>半开 -&gt; 开启</li><li>半开 -&gt; 关闭</li></ul><p>gobreaker 定义了一些方法来完成上面的状态转换，顾名思义，如下所示：</p><h2 id="CircuitBreaker-onSuccess"><a href="#CircuitBreaker-onSuccess" class="headerlink" title="CircuitBreaker.onSuccess"></a><strong>CircuitBreaker.onSuccess</strong></h2><p>这个函数定义了 <strong>半开 -&gt; 关闭</strong> 的状态转换 ，是通过 cb.setState 来完成的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 熔断器请求成功时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onSuccess(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-keyword">case</span> StateClosed: <span class="hljs-comment">// 如果此时是关闭状态，则更新计数</span><br>cb.counts.onSuccess()<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态</span><br>cb.counts.onSuccess() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 连续成功总数超过了设置的 maxRequests，变更为关闭状态</span><br><span class="hljs-keyword">if</span> cb.counts.ConsecutiveSuccesses &gt;= cb.maxRequests &#123;<br>cb.setState(StateClosed, now)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CircuitBreaker-onFailure"><a href="#CircuitBreaker-onFailure" class="headerlink" title="CircuitBreaker.onFailure"></a><strong>CircuitBreaker.onFailure</strong></h2><p>这个函数定义了 **半开 -&gt; 开启 ** 和 <strong>关闭 -&gt; 开启</strong> 的状态转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 熔断器请求失败时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onFailure(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-comment">// 关闭状态下请求失败了</span><br><span class="hljs-keyword">case</span> StateClosed:<br>cb.counts.onFailure() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 如果回调函数 readyToTrip 返回 true</span><br><span class="hljs-comment">// 因为一次失败可能不足以直接判定为需要熔断，所以可能失败多次后才会返回 true</span><br><span class="hljs-comment">// 比如官方示例中设置的回调函数是：</span><br><span class="hljs-comment">// st.ReadyToTrip = func(counts gobreaker.Counts) bool &#123;</span><br><span class="hljs-comment">//failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)</span><br><span class="hljs-comment">//return counts.Requests &gt;= 3 &amp;&amp; failureRatio &gt;= 0.6</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">// 可以看到这里需要请求次数大于3，且总失败率大于等于 60% 才会返回 true</span><br><span class="hljs-keyword">if</span> cb.readyToTrip(cb.counts) &#123;<br>cb.setState(StateOpen, now) <span class="hljs-comment">// 变更熔断器为开启状态</span><br>&#125;<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态下失败了，变更为开启状态</span><br>cb.setState(StateOpen, now)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CircuitBreaker-currentState"><a href="#CircuitBreaker-currentState" class="headerlink" title="CircuitBreaker.currentState"></a><strong>CircuitBreaker.currentState</strong></h2><p>这个函数定义了 <strong>开启 -&gt; 半开</strong> 的状态转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// currentState 返回熔断器当前的状态，now 用来判断是否发生了状态变更</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> currentState(now time.Time) (State, <span class="hljs-type">uint64</span>) &#123;<br>   <span class="hljs-comment">// func toNewGeneration</span><br>   <span class="hljs-comment">// case StateClosed:</span><br>   <span class="hljs-comment">//    if cb.interval == 0 &#123;</span><br>   <span class="hljs-comment">//       cb.expiry = zero</span><br>   <span class="hljs-comment">//    &#125; else &#123;</span><br>   <span class="hljs-comment">//       cb.expiry = now.Add(cb.interval)</span><br>   <span class="hljs-comment">//    &#125;</span><br>   <span class="hljs-keyword">switch</span> cb.state &#123;<br>   <span class="hljs-comment">// 如上面的注释代码所示，如果 cb.interval 为 0，那么 cb.expiry 会设置为 zero，</span><br>   <span class="hljs-comment">// 此时下面的 if 条件就不满足了，关闭状态下也不会调用 cb.toNewGeneration 来清空计数</span><br>   <span class="hljs-comment">// 如果设置了 cb.interval，那么会设置 cb.expiry 的时间，如果处于关闭状态且达到了</span><br>   <span class="hljs-comment">// expiry 的时间，就会调用 cb.toNewGeneration 来清空计数</span><br>   <span class="hljs-keyword">case</span> StateClosed:<br>      <span class="hljs-keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;<br>         cb.toNewGeneration(now)<br>      &#125;<br>   <span class="hljs-keyword">case</span> StateOpen:<br>      <span class="hljs-comment">// 超过了 expiry 的时间，可以切换到半开状态了</span><br>      <span class="hljs-keyword">if</span> cb.expiry.Before(now) &#123;<br>         cb.setState(StateHalfOpen, now)<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> cb.state, cb.generation<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="核心方法-Execute"><a href="#核心方法-Execute" class="headerlink" title="核心方法 Execute"></a>核心方法 Execute</h1><p>这个方法就是熔断器的执行方法，用户传入一个函数，熔断器会根据当前状态进行相应的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Execute(req <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>generation, err := cb.beforeRequest()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>e := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>cb.afterRequest(generation, <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;()<br><br>result, err := req()<br>cb.afterRequest(generation, cb.isSuccessful(err))<br><span class="hljs-keyword">return</span> result, err<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其中调用了用户传入的函数，此外还有两个函数：beforeRequest() 和 afterRequest() 代表执行请求前和执行请求后，这两个函数内部会更新熔断器的计数以及状态</p><h1 id="beforeRequest"><a href="#beforeRequest" class="headerlink" title="beforeRequest"></a><strong>beforeRequest</strong></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> beforeRequest() (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><br><span class="hljs-comment">// 如果熔断器处于开启状态，直接返回错误，因为该方法在 Execute 中先于用户请求执行，</span><br><span class="hljs-comment">// 且逻辑是有 err 直接 return，所以不会执行之后的代码，具体查看 Execute，下面是截取的部分：</span><br><span class="hljs-comment">// generation, err := cb.beforeRequest()</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return nil, err</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span> state == StateOpen &#123;<br><span class="hljs-keyword">return</span> generation, ErrOpenState<br><span class="hljs-comment">// 请求前如果处于半开状态，会进行限流操作</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests &#123;<br><span class="hljs-keyword">return</span> generation, ErrTooManyRequests<br>&#125;<br><br>cb.counts.onRequest() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-keyword">return</span> generation, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="afterRequest"><a href="#afterRequest" class="headerlink" title="afterRequest"></a><strong>afterRequest</strong></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> afterRequest(before <span class="hljs-type">uint64</span>, success <span class="hljs-type">bool</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><span class="hljs-keyword">if</span> generation != before &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>  <span class="hljs-comment">// 更新状态和计数</span><br><span class="hljs-keyword">if</span> success &#123;<br>cb.onSuccess(state, now)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.onFailure(state, now)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数又调用了同一个函数 <code>cb.currentState</code></p><h1 id="currentState"><a href="#currentState" class="headerlink" title="currentState"></a>currentState</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// currentState 返回熔断器当前的状态，now 用来判断是否需要执行某些操作，这些操作包括：</span><br><span class="hljs-comment">// 1. 关闭状态下清空计数（如果设置了 interval 且达到了清空时间）</span><br><span class="hljs-comment">// 2. 开启状态转换为半开启状态（到达了转换时间）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> currentState(now time.Time) (State, <span class="hljs-type">uint64</span>) &#123;<br><span class="hljs-comment">// func toNewGeneration</span><br><span class="hljs-comment">// case StateClosed:</span><br><span class="hljs-comment">//if cb.interval == 0 &#123;</span><br><span class="hljs-comment">//cb.expiry = zero</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//cb.expiry = now.Add(cb.interval)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">switch</span> cb.state &#123;<br><span class="hljs-comment">// 如上面的注释代码所示，如果 cb.interval 为 0，那么 cb.expiry 会设置为 zero，</span><br><span class="hljs-comment">// 此时下面的 if 条件就不满足了，关闭状态下也不会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-comment">// 如果设置了 cb.interval，那么会设置 cb.expiry 的时间，如果处于关闭状态且达到了</span><br><span class="hljs-comment">// expiry 的时间，就会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;<br>cb.toNewGeneration(now)<br>&#125;<br><span class="hljs-keyword">case</span> StateOpen:<br><span class="hljs-comment">// 超过了 expiry 的时间，可以切换到半开状态了</span><br><span class="hljs-keyword">if</span> cb.expiry.Before(now) &#123;<br>cb.setState(StateHalfOpen, now)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cb.state, cb.generation<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数又调用了另一个函数 <code>toNewGeneration</code></p><h1 id="toNewGeneration"><a href="#toNewGeneration" class="headerlink" title="toNewGeneration"></a>toNewGeneration</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 进入一个新周期，会清空计数，并对 cb.expiry 进行更新</span><br><span class="hljs-comment">// 该函数会在 setState、currentState、NewCircuitBreaker 调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> toNewGeneration(now time.Time) &#123;<br>   cb.generation++<br>   cb.counts.clear()<br><br>   <span class="hljs-keyword">var</span> zero time.Time<br>   <span class="hljs-keyword">switch</span> cb.state &#123;<br>   <span class="hljs-keyword">case</span> StateClosed:<br>      <span class="hljs-keyword">if</span> cb.interval == <span class="hljs-number">0</span> &#123;<br>         cb.expiry = zero<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         cb.expiry = now.Add(cb.interval)<br>      &#125;<br>   <span class="hljs-keyword">case</span> StateOpen:<br>      cb.expiry = now.Add(cb.timeout) <span class="hljs-comment">// 设置 open -&gt; halfOpen 的绝对时间</span><br>   <span class="hljs-keyword">default</span>: <span class="hljs-comment">// StateHalfOpen</span><br>      cb.expiry = zero<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>光看文档感觉熔断器并不是一个多么复杂的东西，但是等实际阅读代码才发现还是有点小复杂的，何况这个开源库还只是对熔断器的一个最精简实现，还有其他的更复杂的实现库，阅读这个源码主要有一些不清楚的点在于，里面的属性<code> CircuitBreaker.expiry</code> 和 <code>CircuitBreaker.maxRequests</code> 在不同情况下有不同的意义，导致看的有点头疼，状态的转换看着也有点绕，还有一开始对 <code>CircuitBreaker.interval</code> 这个属性的意义也不太理解</p><h1 id="完整源码注释"><a href="#完整源码注释" class="headerlink" title="完整源码注释"></a>完整源码注释</h1><p><a href="https://github.com/youseebiggirl/gobreaker_annotation">https://github.com/youseebiggirl/gobreaker_annotation</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package gobreaker implements the Circuit Breaker pattern.</span><br><span class="hljs-comment">// See https://msdn.microsoft.com/en-us/library/dn589784.aspx.</span><br><span class="hljs-keyword">package</span> gobreaker<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// State is a type that represents a state of CircuitBreaker.</span><br><span class="hljs-keyword">type</span> State <span class="hljs-type">int</span><br><br><span class="hljs-comment">// These constants are states of CircuitBreaker.</span><br><span class="hljs-comment">// 熔断器的状态</span><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// StateClosed 表示关闭状态，此时所有请求都会通过</span><br>StateClosed State = <span class="hljs-literal">iota</span><br><span class="hljs-comment">// StateHalfOpen 半开状态，会根据情况变更为开启或者关闭状态</span><br>StateHalfOpen<br><span class="hljs-comment">// StateOpen 开启状态，此时会拒绝所有请求</span><br>StateOpen<br>)<br><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// ErrTooManyRequests is returned when the CB state is half open and the requests count is over the cb maxRequests</span><br><span class="hljs-comment">// 该错误在状态为半开且请求数超过 maxRequests 时返回</span><br>ErrTooManyRequests = errors.New(<span class="hljs-string">&quot;too many requests&quot;</span>)<br><span class="hljs-comment">// ErrOpenState is returned when the CB state is open</span><br><span class="hljs-comment">// 该错误在状态为开启时返回</span><br>ErrOpenState = errors.New(<span class="hljs-string">&quot;circuit breaker is open&quot;</span>)<br>)<br><br><span class="hljs-comment">// String implements stringer interface.</span><br><span class="hljs-comment">// String 继承了 stringer 接口，相当于自定义了 fmt.Println(State) 的输出</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s State)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;closed&quot;</span><br><span class="hljs-keyword">case</span> StateHalfOpen:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;half-open&quot;</span><br><span class="hljs-keyword">case</span> StateOpen:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;open&quot;</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;unknown state: %d&quot;</span>, s)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Counts holds the numbers of requests and their successes/failures.</span><br><span class="hljs-comment">// CircuitBreaker clears the internal Counts either</span><br><span class="hljs-comment">// on the change of the state or at the closed-state intervals.</span><br><span class="hljs-comment">// Counts ignores the results of the requests sent before clearing.</span><br><span class="hljs-comment">// Counts 保存请求的数量及其成功失败的次数。</span><br><span class="hljs-comment">// CircuitBreaker 在状态更改或关闭状态间隔时清除内部计数。</span><br><span class="hljs-comment">// Counts 会忽略在清除之前发送的请求的结果。</span><br><span class="hljs-keyword">type</span> Counts <span class="hljs-keyword">struct</span> &#123;<br>Requests             <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总请求次数</span><br>TotalSuccesses       <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总成功次数</span><br>TotalFailures        <span class="hljs-type">uint32</span> <span class="hljs-comment">// 总失败次数</span><br>ConsecutiveSuccesses <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续成功次数</span><br>ConsecutiveFailures  <span class="hljs-type">uint32</span> <span class="hljs-comment">// 连续失败次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onRequest() &#123;<br>c.Requests++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onSuccess() &#123;<br>c.TotalSuccesses++<br>c.ConsecutiveSuccesses++<br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> onFailure() &#123;<br>c.TotalFailures++<br>c.ConsecutiveFailures++<br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counts)</span></span> clear() &#123;<br>c.Requests = <span class="hljs-number">0</span><br>c.TotalSuccesses = <span class="hljs-number">0</span><br>c.TotalFailures = <span class="hljs-number">0</span><br>c.ConsecutiveSuccesses = <span class="hljs-number">0</span><br>c.ConsecutiveFailures = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Settings configures CircuitBreaker:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Name is the name of the CircuitBreaker.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// MaxRequests is the maximum number of requests allowed to pass through</span><br><span class="hljs-comment">// when the CircuitBreaker is half-open.</span><br><span class="hljs-comment">// If MaxRequests is 0, the CircuitBreaker allows only 1 request.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Interval is the cyclic period of the closed state</span><br><span class="hljs-comment">// for the CircuitBreaker to clear the internal Counts.</span><br><span class="hljs-comment">// If Interval is less than or equal to 0, the CircuitBreaker doesn&#x27;t clear internal Counts during the closed state.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Timeout is the period of the open state,</span><br><span class="hljs-comment">// after which the state of the CircuitBreaker becomes half-open.</span><br><span class="hljs-comment">// If Timeout is less than or equal to 0, the timeout value of the CircuitBreaker is set to 60 seconds.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ReadyToTrip is called with a copy of Counts whenever a request fails in the closed state.</span><br><span class="hljs-comment">// If ReadyToTrip returns true, the CircuitBreaker will be placed into the open state.</span><br><span class="hljs-comment">// If ReadyToTrip is nil, default ReadyToTrip is used.</span><br><span class="hljs-comment">// Default ReadyToTrip returns true when the number of consecutive failures is more than 5.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// OnStateChange is called whenever the state of the CircuitBreaker changes.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// IsSuccessful is called with the error returned from a request.</span><br><span class="hljs-comment">// If IsSuccessful returns true, the error is counted as a success.</span><br><span class="hljs-comment">// Otherwise the error is counted as a failure.</span><br><span class="hljs-comment">// If IsSuccessful is nil, default IsSuccessful is used, which returns false for all non-nil errors.</span><br><span class="hljs-keyword">type</span> Settings <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 熔断器的名称</span><br>Name <span class="hljs-type">string</span><br><br><span class="hljs-comment">// MaxRequests 是 CircuitBreaker 半开时允许通过的最大请求数。</span><br><span class="hljs-comment">// 如果 MaxRequests 为 0，则 CircuitBreaker 只允许 1 个请求。</span><br><span class="hljs-comment">// FIXME 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>MaxRequests <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// Interval 是熔断器处于关闭状态时，定期清除内部 Counts 的时间。</span><br><span class="hljs-comment">// 如果 Interval 小于或等于 0，CircuitBreaker 在关闭状态期间不会清除内部计数。</span><br><span class="hljs-comment">// FIXME 这个东西暂时没发现用处何在</span><br><span class="hljs-comment">// 在网上找了一个分析，意思是如果一直处于成功状态，那么计数的意义就不是很大，</span><br><span class="hljs-comment">// 需要定期清空，不然可能会溢出</span><br>Interval time.Duration<br><br><span class="hljs-comment">// Timeout 是打开状态的持续时间，到时后会变更为半打开状态。</span><br><span class="hljs-comment">// 如果 Timeout 小于或等于 0，则将 CircuitBreaker 的超时值设置为 60 秒。</span><br>Timeout time.Duration<br><br><span class="hljs-comment">// 每当请求在关闭状态下失败时，就会调用 ReadyToTrip，参数传递的是 Counts 的副本。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 返回 true，CircuitBreaker 将进入打开状态。</span><br><span class="hljs-comment">// 如果 ReadyToTrip 为 nil，则使用默认 ReadyToTrip。</span><br><span class="hljs-comment">// 当连续失败次数超过 5 次时，默认 ReadyToTrip 返回 true。</span><br>ReadyToTrip <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// OnStateChange 是熔断器状态变更时的回调函数</span><br>OnStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br><br><span class="hljs-comment">// IsSuccessful 判断请求是否成功，传入的 err 是执行用户请求函数后返回的。</span><br><span class="hljs-comment">// （也就是 CircuitBreaker.Execute 的参数 req）</span><br><span class="hljs-comment">// 如果 IsSuccessful 返回 true， 则说明请求发生了错误，否则说明没有错误。</span><br><span class="hljs-comment">// 如果 IsSuccessful 为 nil， 则使用默认 IsSuccessful，该默认函数的逻辑是：</span><br><span class="hljs-comment">// if err == nil &#123; return true &#125;</span><br>IsSuccessful <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// CircuitBreaker is a state machine to prevent sending requests that are likely to fail.</span><br><span class="hljs-keyword">type</span> CircuitBreaker <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 虚线内的属性和 Settings 中的相同，如果 Settings 中没有设置，则使用默认值来填充</span><br><span class="hljs-comment">// ==================</span><br>name <span class="hljs-type">string</span><br><span class="hljs-comment">// 比较迷的一个变量，源码里有两种情况：</span><br><span class="hljs-comment">// 1. 请求总数（Requests） &gt;= MaxRequests，那么会返回请求过多的错误</span><br><span class="hljs-comment">// 2. 连续成功次数（ConsecutiveSuccesses） &gt;= MaxRequests，那么变更为关闭状态</span><br><span class="hljs-comment">// 1 在 beforeRequest() 函数中，2 在 afterRequest() -&gt; onSuccess() 的 HalfOpen 分支中</span><br><span class="hljs-comment">// 也就是在请求前会确保请求总数不超过 MaxRequest，请求后如果处于半开状态且连续成功数 &gt;= MaxRequest</span><br><span class="hljs-comment">// 那么会变更为关闭状态</span><br>maxRequests <span class="hljs-type">uint32</span><br><br><span class="hljs-comment">// 关闭状态下定期清空计数的时间，如果为 0，则不清空</span><br><span class="hljs-comment">// 这里我不太明白清空计数的原因，在网上找了一个分析，意思是如果一直处于成功状态，</span><br><span class="hljs-comment">// 那么计数的意义就不是很大，此外如果请求量过大可能会导致溢出，所以需要定期清空</span><br>interval time.Duration<br><br><span class="hljs-comment">// 打开状态的持续时间，到时后会变更为半打开状态。</span><br>timeout time.Duration<br><br><span class="hljs-comment">// 关闭状态下会调用该回调函数，如果返回 true，则进入打开状态</span><br>readyToTrip <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// 用来判断请求是否成功的回调函数</span><br>isSuccessful <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// 发生状态变更时的回调函数</span><br>onStateChange <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>, from State, to State)</span></span><br><span class="hljs-comment">// ====================</span><br><br>mutex      sync.Mutex<br>state      State<br>generation <span class="hljs-type">uint64</span><br>counts     Counts<br><span class="hljs-comment">// 这个变量貌似有两种情况：</span><br><span class="hljs-comment">// 1. 开启状态下，代表切换到半开启的绝对时间（time.Time 代表一个绝对时间）</span><br><span class="hljs-comment">//    具体值是 time.Now + timeout</span><br><span class="hljs-comment">// 2. 关闭状态下，代表进入下一个周期的绝对时间（进入下一个周期会清空计数）</span><br><span class="hljs-comment">//   具体值是 time.Now + interval</span><br>expiry time.Time<br>&#125;<br><br><span class="hljs-comment">// TwoStepCircuitBreaker is like CircuitBreaker but instead of surrounding a function</span><br><span class="hljs-comment">// with the breaker functionality, it only checks whether a request can proceed and</span><br><span class="hljs-comment">// expects the caller to report the outcome in a separate step using a callback.</span><br><span class="hljs-keyword">type</span> TwoStepCircuitBreaker <span class="hljs-keyword">struct</span> &#123;<br>cb *CircuitBreaker<br>&#125;<br><br><span class="hljs-comment">// NewCircuitBreaker returns a new CircuitBreaker configured with the given Settings.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCircuitBreaker</span><span class="hljs-params">(st Settings)</span></span> *CircuitBreaker &#123;<br>cb := <span class="hljs-built_in">new</span>(CircuitBreaker)<br><br>cb.name = st.Name<br>cb.onStateChange = st.OnStateChange<br><br><span class="hljs-keyword">if</span> st.MaxRequests == <span class="hljs-number">0</span> &#123;<br>cb.maxRequests = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.maxRequests = st.MaxRequests<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Interval &lt;= <span class="hljs-number">0</span> &#123;<br>cb.interval = defaultInterval<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.interval = st.Interval<br>&#125;<br><br><span class="hljs-keyword">if</span> st.Timeout &lt;= <span class="hljs-number">0</span> &#123;<br>cb.timeout = defaultTimeout<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.timeout = st.Timeout<br>&#125;<br><br><span class="hljs-keyword">if</span> st.ReadyToTrip == <span class="hljs-literal">nil</span> &#123;<br>cb.readyToTrip = defaultReadyToTrip<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.readyToTrip = st.ReadyToTrip<br>&#125;<br><br><span class="hljs-keyword">if</span> st.IsSuccessful == <span class="hljs-literal">nil</span> &#123;<br>cb.isSuccessful = defaultIsSuccessful<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.isSuccessful = st.IsSuccessful<br>&#125;<br><br>cb.toNewGeneration(time.Now())<br><br><span class="hljs-keyword">return</span> cb<br>&#125;<br><br><span class="hljs-comment">// NewTwoStepCircuitBreaker returns a new TwoStepCircuitBreaker configured with the given Settings.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTwoStepCircuitBreaker</span><span class="hljs-params">(st Settings)</span></span> *TwoStepCircuitBreaker &#123;<br><span class="hljs-keyword">return</span> &amp;TwoStepCircuitBreaker&#123;<br>cb: NewCircuitBreaker(st),<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaultInterval = time.Duration(<span class="hljs-number">0</span>) * time.Second<br><span class="hljs-keyword">const</span> defaultTimeout = time.Duration(<span class="hljs-number">60</span>) * time.Second<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultReadyToTrip</span><span class="hljs-params">(counts Counts)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> counts.ConsecutiveFailures &gt; <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defaultIsSuccessful</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> err == <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Name returns the name of the CircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> cb.name<br>&#125;<br><br><span class="hljs-comment">// State returns the current state of the CircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> State() State &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, _ := cb.currentState(now)<br><span class="hljs-keyword">return</span> state<br>&#125;<br><br><span class="hljs-comment">// Counts returns internal counters</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Counts() Counts &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br><span class="hljs-keyword">return</span> cb.counts<br>&#125;<br><br><span class="hljs-comment">// Execute runs the given request if the CircuitBreaker accepts it.</span><br><span class="hljs-comment">// Execute returns an error instantly if the CircuitBreaker rejects the request.</span><br><span class="hljs-comment">// Otherwise, Execute returns the result of the request.</span><br><span class="hljs-comment">// If a panic occurs in the request, the CircuitBreaker handles it as an error</span><br><span class="hljs-comment">// and causes the same panic again.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> Execute(req <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 执行请求前</span><br>generation, err := cb.beforeRequest()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>e := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>cb.afterRequest(generation, <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;()<br><br>result, err := req()<br><span class="hljs-comment">// 执行请求后</span><br>cb.afterRequest(generation, cb.isSuccessful(err))<br><span class="hljs-keyword">return</span> result, err<br>&#125;<br><br><span class="hljs-comment">// Name returns the name of the TwoStepCircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> tscb.cb.Name()<br>&#125;<br><br><span class="hljs-comment">// State returns the current state of the TwoStepCircuitBreaker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> State() State &#123;<br><span class="hljs-keyword">return</span> tscb.cb.State()<br>&#125;<br><br><span class="hljs-comment">// Counts returns internal counters</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> Counts() Counts &#123;<br><span class="hljs-keyword">return</span> tscb.cb.Counts()<br>&#125;<br><br><span class="hljs-comment">// Allow checks if a new request can proceed. It returns a callback that should be used to</span><br><span class="hljs-comment">// register the success or failure in a separate step. If the circuit breaker doesn&#x27;t allow</span><br><span class="hljs-comment">// requests, it returns an error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tscb *TwoStepCircuitBreaker)</span></span> Allow() (done <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(success <span class="hljs-type">bool</span>)</span></span>, err <span class="hljs-type">error</span>) &#123;<br>generation, err := tscb.cb.beforeRequest()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(success <span class="hljs-type">bool</span>)</span></span> &#123;<br>tscb.cb.afterRequest(generation, success)<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> beforeRequest() (<span class="hljs-type">uint64</span>, <span class="hljs-type">error</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><br><span class="hljs-comment">// 如果熔断器处于开启状态，直接返回错误，因为该方法在 Execute 中先于用户请求执行，</span><br><span class="hljs-comment">// 且逻辑是有 err 直接 return，所以不会执行之后的代码，具体查看 Execute，下面是截取的部分：</span><br><span class="hljs-comment">// generation, err := cb.beforeRequest()</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return nil, err</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span> state == StateOpen &#123;<br><span class="hljs-keyword">return</span> generation, ErrOpenState<br><span class="hljs-comment">// 请求前如果处于半开状态，会进行限流操作</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests &#123;<br><span class="hljs-keyword">return</span> generation, ErrTooManyRequests<br>&#125;<br><br>cb.counts.onRequest() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-keyword">return</span> generation, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> afterRequest(before <span class="hljs-type">uint64</span>, success <span class="hljs-type">bool</span>) &#123;<br>cb.mutex.Lock()<br><span class="hljs-keyword">defer</span> cb.mutex.Unlock()<br><br>now := time.Now()<br>state, generation := cb.currentState(now)<br><span class="hljs-keyword">if</span> generation != before &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 更新状态和计数</span><br><span class="hljs-keyword">if</span> success &#123;<br>cb.onSuccess(state, now)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.onFailure(state, now)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 熔断器请求成功时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onSuccess(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-keyword">case</span> StateClosed: <span class="hljs-comment">// 如果此时是关闭状态，则更新计数</span><br>cb.counts.onSuccess()<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态</span><br>cb.counts.onSuccess() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 连续成功总数超过了设置的 maxRequests，变更为关闭状态</span><br><span class="hljs-keyword">if</span> cb.counts.ConsecutiveSuccesses &gt;= cb.maxRequests &#123;<br>cb.setState(StateClosed, now)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 熔断器请求失败时调用该函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> onFailure(state State, now time.Time) &#123;<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-comment">// 关闭状态下请求失败了</span><br><span class="hljs-keyword">case</span> StateClosed:<br>cb.counts.onFailure() <span class="hljs-comment">// 更新计数</span><br><span class="hljs-comment">// 如果回调函数 readyToTrip 返回 true</span><br><span class="hljs-comment">// 因为一次失败可能不足以直接判定为需要熔断，所以可能失败多次后才会返回 true</span><br><span class="hljs-comment">// 比如官方示例中设置的回调函数是：</span><br><span class="hljs-comment">// st.ReadyToTrip = func(counts gobreaker.Counts) bool &#123;</span><br><span class="hljs-comment">//failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)</span><br><span class="hljs-comment">//return counts.Requests &gt;= 3 &amp;&amp; failureRatio &gt;= 0.6</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">// 可以看到这里需要请求次数大于3，且总失败率大于等于 60% 才会返回 true</span><br><span class="hljs-keyword">if</span> cb.readyToTrip(cb.counts) &#123;<br>cb.setState(StateOpen, now) <span class="hljs-comment">// 变更熔断器为开启状态</span><br>&#125;<br><span class="hljs-keyword">case</span> StateHalfOpen: <span class="hljs-comment">// 半开状态下失败了，变更为开启状态</span><br>cb.setState(StateOpen, now)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// currentState 返回熔断器当前的状态，now 用来判断是否需要执行某些操作，这些操作包括：</span><br><span class="hljs-comment">// 1. 关闭状态下清空计数（如果设置了 interval 且达到了清空时间）</span><br><span class="hljs-comment">// 2. 开启状态转换为半开启状态（到达了转换时间）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> currentState(now time.Time) (State, <span class="hljs-type">uint64</span>) &#123;<br><span class="hljs-comment">// func toNewGeneration</span><br><span class="hljs-comment">// case StateClosed:</span><br><span class="hljs-comment">//if cb.interval == 0 &#123;</span><br><span class="hljs-comment">//cb.expiry = zero</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//cb.expiry = now.Add(cb.interval)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">switch</span> cb.state &#123;<br><span class="hljs-comment">// 如上面的注释代码所示，如果 cb.interval 为 0，那么 cb.expiry 会设置为 zero，</span><br><span class="hljs-comment">// 此时下面的 if 条件就不满足了，关闭状态下也不会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-comment">// 如果设置了 cb.interval，那么会设置 cb.expiry 的时间，如果处于关闭状态且达到了</span><br><span class="hljs-comment">// expiry 的时间，就会调用 cb.toNewGeneration 来清空计数</span><br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">if</span> !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) &#123;<br>cb.toNewGeneration(now)<br>&#125;<br><span class="hljs-keyword">case</span> StateOpen:<br><span class="hljs-comment">// 超过了 expiry 的时间，可以切换到半开状态了</span><br><span class="hljs-keyword">if</span> cb.expiry.Before(now) &#123;<br>cb.setState(StateHalfOpen, now)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> cb.state, cb.generation<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> setState(state State, now time.Time) &#123;<br><span class="hljs-keyword">if</span> cb.state == state &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>prev := cb.state<br>cb.state = state<br><br>cb.toNewGeneration(now) <span class="hljs-comment">// 设置新状态后更新计数</span><br><br><span class="hljs-keyword">if</span> cb.onStateChange != <span class="hljs-literal">nil</span> &#123;<br>cb.onStateChange(cb.name, prev, state)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 进入一个新周期，会清空计数，并对 cb.expiry 进行更新</span><br><span class="hljs-comment">// 该函数会在 setState、currentState、NewCircuitBreaker 调用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cb *CircuitBreaker)</span></span> toNewGeneration(now time.Time) &#123;<br>cb.generation++<br>cb.counts.clear()<br><br><span class="hljs-keyword">var</span> zero time.Time<br><span class="hljs-keyword">switch</span> cb.state &#123;<br><span class="hljs-keyword">case</span> StateClosed:<br><span class="hljs-keyword">if</span> cb.interval == <span class="hljs-number">0</span> &#123;<br>cb.expiry = zero<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cb.expiry = now.Add(cb.interval)<br>&#125;<br><span class="hljs-keyword">case</span> StateOpen:<br>cb.expiry = now.Add(cb.timeout) <span class="hljs-comment">// 设置 open -&gt; halfOpen 的绝对时间</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// StateHalfOpen</span><br>cb.expiry = zero<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 文件操作的&quot;坑&quot;之 Seek()</title>
    <link href="/2022/06/08/go_seek/"/>
    <url>/2022/06/08/go_seek/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近买了块机械硬盘作为仓库盘，用硬盘盒连接到 mac，但是这块硬盘貌似有休眠机制（不确定），如果一段时间没有读写操作就会停转，等到需要操作时才会唤醒，唤醒会有比较明显的磁盘启动声音，并且需要等待 5s 左右才能使用。</p><p>但蛋疼的是不知道是系统原因还是什么，每次硬盘休眠后即便我没有对其进行操作仍然会自行唤醒，导致我总是能频繁听到硬盘的启停声，我还专门观察了一下，就算我躺在床上玩手机，完全不碰电脑，这块硬盘仍然会频繁的启停，先不说这烦人的声音，网上查了下，貌似这样频繁启停还会损害硬盘健康，还不如一直通电运行，为了解决这个问题，我打算写个小程序，期间遇到了一些问题，特此记录一下。</p><h1 id="问题1-读不出文件内容"><a href="#问题1-读不出文件内容" class="headerlink" title="问题1 读不出文件内容"></a>问题1 读不出文件内容</h1><p>具体流程是先在这块硬盘上创建一个文件，并获取 fd，然后用这个 fd 写入一段文字，再在一个死循环里不断读取这个 fd，我想的是这样不断读取硬盘，来达到禁止休眠的效果，结果发现写入成功，但是读直接报 EOF，后来研究发现，貌似是写入后导致 fd 偏移量改变移到末尾，此时再读取就会直接报 EOF，所以在读取前需要调用 Seek 来重置偏移量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := <span class="hljs-string">&quot;/Volumes/4t/DO_NOT_SLEEP&quot;</span><br>f, err := os.OpenFile(p, os.O_CREATE|os.O_RDWR, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br>_, err = f.WriteString(<span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Println(<span class="hljs-string">&quot;DO_NOT_SLEEP is ready&quot;</span>)<br><span class="hljs-comment">// 注意：上面的写入操作会改变偏移量，导致后续的读取操作为 EOF</span><br><span class="hljs-comment">// 需要调用 Seek 来重置偏移量，这里设置为 SEEK_SET + 0 也就是从头开始读</span><br>f.Seek(<span class="hljs-number">0</span>, os.SEEK_SET)<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> &#123;<br>n, err := f.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Println(n, <span class="hljs-type">string</span>(b[:n]))<br>f.Seek(<span class="hljs-number">0</span>, os.SEEK_SET)<br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="问题2-虽然在不断读取，但硬盘依然会休眠"><a href="#问题2-虽然在不断读取，但硬盘依然会休眠" class="headerlink" title="问题2 虽然在不断读取，但硬盘依然会休眠"></a>问题2 虽然在不断读取，但硬盘依然会休眠</h1><p>还是上面的程序，我跑起来以后发现终端在不断打印读取到的内容，本以为 ok 了，结果过了几分钟硬盘又给休眠了，最离谱的是此时终端还在不断打印日志。。。这是为什么？难不成 fd 打开后，会把文件内容缓存，之后直接从缓存中读？我又尝试了在一个死循环里不断调用 os.OpenFile，但是然并卵，磁盘依然会休眠，这个问题还有待研究，不知道是 go runtime 的设计问题，还是 linux fd 的机制问题</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>既然读解决不了问题，那我只能试试写了，感觉写问题应该不大，其实我一开始就是想用写操作来解决问题的，但是了解到读操作对硬盘是无损害的，而写操作会损害硬盘寿命，所以才尝试用读操作解决，</p><p>大致思路也很简单，就是不断向这个文件中写入文本即可，这里我把 open 也放到了死循环中，因为我不知道在死循环中操作同一个 fd 会不会出现上面的硬盘依然休眠的问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p := <span class="hljs-string">&quot;/Volumes/4t/DO_NOT_SLEEP&quot;</span><br><span class="hljs-keyword">for</span> &#123;<br>f, err := os.OpenFile(p, os.O_CREATE|os.O_RDWR, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>f.WriteString(<span class="hljs-string">&quot;123&quot;</span>)<br>log.Println(<span class="hljs-string">&quot;write ok&quot;</span>)<br>f.Close()<br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h1><p>无意间看到一盘 <strong>页缓存</strong> 的文章，里面说系统会把磁盘里的内容放到缓存中，下次如果访问同样的内容，则不需要读取硬盘，而是直接从缓存中读取即可，这样就避免了 IO 的开销，提高了性能。如果是这样的话，那么问题2 就解释的通了</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s ConfigMap</title>
    <link href="/2022/06/07/k8s-configmap/"/>
    <url>/2022/06/07/k8s-configmap/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说明：文章的部分地方会用 <code>cm</code> 来指代 <code>ConfigMap</code></p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>做过开发的同学都遇到过给程序进行配置的场景，比如非常常见的配置文件，将 Mysql 的地址、端口、用户名、密码等信息写到一个配置文件里，然后程序内部通过读取这个配置文件来获取信息，防止了硬编码信息到程序内部，这样如果发生变动只需要修改配置文件即可，无需重新编译整个程序；另一种常见的方式是运行程序时指定参数来进行配置，比如 Go 标准库里的 flag 包就可以方便的进行参数指定，然后运行时只要使用诸如 <code>go run main.go -a 123 -b 456</code> 这样的方式，便可读取到配置信息，比如在这个例子里传递了两个参数：a&#x3D;123，b&#x3D;456</p><p>那么在 k8s 中如何对容器进行配置呢？</p><h2 id="在-docker-中定义命令与参数"><a href="#在-docker-中定义命令与参数" class="headerlink" title="在 docker 中定义命令与参数"></a>在 docker 中定义命令与参数</h2><p>容器中运行的完整指令由两部分组成：命令和参数，比如 <code>./main -a 123</code>，main 就是命令，-a 就是参数，在 Dockerfile 中分别对应的是 ENTRYPOINT（命令）和 CMD（参数）。</p><p>实战：</p><p>这个 image 会调用 fortuneloop.sh：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update ; apt-get -y install fortune <span class="hljs-comment"># 安装 fortune</span></span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> fortuneloop.sh /bin/fortuneloop.sh</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/fortuneloop.sh&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;10&quot;</span>] <span class="hljs-comment"># 每隔 10s 输出一次</span></span><br></code></pre></td></tr></table></figure><p>这里指定了 ENTRYPOINT 和 CMD，等同于命令 <code>/bin/fortuneloop.sh 10</code></p><p>附：fortuneloop.sh 文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>trap &quot;exit&quot; SIGINT<br><br>INTERVAL=$1 # 读取第一个参数，比如执行 fortuneloop.sh 10，那么 $1=10<br>echo Configured to generate new fortune every $INTERVAL seconds<br><br>mkdir -p /var/htdocs<br><br>while :<br>do<br>  echo $(date) Writing fortune to /var/htdocs/index.html<br>  /usr/games/fortune &gt; /var/htdocs/index.html # 执行 fortune 命令，将输出的内容写入到 index.html<br>  sleep $INTERVAL # 睡眠指定的时间<br>done<br></code></pre></td></tr></table></figure><p>接下来构建并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">构建镜像</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker build -t stdoutt/fortune-args-arm64 .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it stdoutt/fortune-args-arm6</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">观察效果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每隔 10s 就会打印一次</span><br>Configured to generate new fortune every 10 seconds<br>Sun Sep 25 02:23:01 UTC 2022 Writing fortune to /var/htdocs/index.html<br>Sun Sep 25 02:23:11 UTC 2022 Writing fortune to /var/htdocs/index.html<br></code></pre></td></tr></table></figure><p>因为在 Dockerfile 的 CMD 中指定值为 10，所以默认会每隔 10 秒打印一次，也可以自己指定值将默认值覆盖掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker run -it stdoutt/fortune-args-arm6 1</span><br>Configured to generate new fortune every 1 seconds<br>Sun Sep 25 02:24:55 UTC 2022 Writing fortune to /var/htdocs/index.html<br>Sun Sep 25 02:24:56 UTC 2022 Writing fortune to /var/htdocs/index.html<br>Sun Sep 25 02:24:57 UTC 2022 Writing fortune to /var/htdocs/index.html<br></code></pre></td></tr></table></figure><p>现在每间隔 1s 就会打印一次</p><h2 id="在-k8s-中定义命令与参数"><a href="#在-k8s-中定义命令与参数" class="headerlink" title="在 k8s 中定义命令与参数"></a>在 k8s 中定义命令与参数</h2><p>在 k8s 中定义容器时，可以覆盖掉镜像的 ENTRYPOINT 和 CMD，通过 command 和 args 来指定，类似一下这种形式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span> <br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">some/image</span><br><span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/command&quot;</span>]  <span class="hljs-comment"># 等同于 Dockerfile 中的 ENTRYPOINT</span><br><span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;argl&quot;</span>, <span class="hljs-string">&quot;arg2&quot;</span>, <span class="hljs-string">&quot;arg3&quot;</span>] <span class="hljs-comment"># 等同于 Dockerfile 中的 CMD</span><br></code></pre></td></tr></table></figure><p>其中 command 等同于 Dockerfile 中的 ENTRYPOINT，args 等同于 Dockerfile 中的 CMD</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune2s</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-args-arm64</span> <span class="hljs-comment"># 注意此 image 仅适用于 arm64</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;2&quot;</span>] <span class="hljs-comment"># 等同于 Dockerfile 中的 CMD</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 pod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-args.yaml</span><br>pod/fortune2s created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启端口转发</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune2s 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每隔 2s （和 args 中定义的一样）curl 一次，因为 args 也定义为 2s，代表每 2s 写入一次谚语，所以</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">每次 curl 都应该输出不同的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 2s;<span class="hljs-keyword">done</span></span><br>Wagner&#x27;s music is better than it sounds.<br>-- Mark Twain<br>You plan things that you do not even attempt because of your extreme caution.<br>You never hesitate to tackle the most difficult problems.<br>The lovely woman-child Kaa was mercilessly chained to the cruel post of<br>the warrior-chief Beast, with his barbarian tribe now stacking wood at<br>her nubile feet, when the strong clear voice of the poetic and heroic<br>Handsomas roared, &#x27;Flick your Bic, crisp that chick, and you&#x27;ll feel my<br>steel through your last meal!&#x27;<br>-- Winning sentence, 1984 Bulwer-Lytton bad fiction contest.<br></code></pre></td></tr></table></figure><h2 id="在容器定义中指定环境变量"><a href="#在容器定义中指定环境变量" class="headerlink" title="在容器定义中指定环境变量"></a>在容器定义中指定环境变量</h2><p><strong>Dockerfile</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update ; apt-get -y install fortune</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> fortuneloop.sh /bin/fortuneloop.sh</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/bin/fortuneloop.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>fortuneloop.sh</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>trap &quot;exit&quot; SIGINT<br><br>echo Configured to generate new fortune every $INTERVAL seconds<br><br>mkdir -p /var/htdocs<br><br>while :<br>do<br>  echo $(date) Writing fortune to /var/htdocs/index.html<br>  /usr/games/fortune &gt; /var/htdocs/index.html<br>  sleep $INTERVAL # 读取 INTERVAL 这个环境变量<br>done<br></code></pre></td></tr></table></figure><p><strong>fortune-pod-env.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-env</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span> <span class="hljs-comment"># 注意此 image 仅适用于 arm64</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-comment"># 在这里设置环境变量，用于 fortuneloop.sh 的读取</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;5&quot;</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-env.yaml</span><br>pod/fortune-env created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>fortune2s     2/2     Running   0          84m<br>fortune-env   2/2     Running   0          18s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-env 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 5s;<span class="hljs-keyword">done</span> <span class="hljs-comment"># sleep 同样的时间</span></span><br>It may or may not be worthwhile, but it still has to be done.<br>When I reflect upon the number of disagreeable people who I know who have gone<br>to a better world, I am moved to lead a different life.<br>-- Mark Twain, &quot;Pudd&#x27;nhead Wilson&#x27;s Calendar&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里额外测试一下，环境变量里设置的值是 5，也就是每 5s 生成一句新谚语并写入 index.html，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">但是这里每隔 1s 就 curl 一次，会发现前 5 此输出的内容都相同</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 1s;<span class="hljs-keyword">done</span></span><br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>You will be surrounded by luxury.<br>Q:What happens when four WASPs find themselves in the same room?<br>A:A dinner party.<br></code></pre></td></tr></table></figure><h1 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h1><p>上面的方式都是直接在 pod 中硬编码的，就像 <code>- name: INTERVAL  value: &quot;5&quot;</code> 这样，如果之后需要更改 value 的值，那么需要修改 pod 的 yaml，然后删除旧的重新创建新的（这里还待验证），比较麻烦。</p><p>ConfigMap 将配置相关的内容抽取出来做成了一个单独的部分，然后 pod 再引用 ConfigMap 即可（又是万能的解决方法：加一层中间层），相比较直接在 pod spec 中的硬编码而言更加灵活。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>使用 <code>create</code> 命令而不是 yaml 来创建一个 configmap（之后简称为 cm），通过 <code>--from-literal</code> 来指定键值对（kv），形式为：–from-literal&#x3D;[key]&#x3D;[value]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-literal=sleep-interval=25</span><br>configmap/fortune-config created<br></code></pre></td></tr></table></figure><p>通过指定多个 <code>--from-literal</code> 来添加多个 kv：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap myconfigmap --from-literal=foo=bar --from-literal=bar=baz --from-literal=one=two</span><br>configmap/myconfigmap created<br></code></pre></td></tr></table></figure><p>查看 cm 的 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm myconfigmap -o yaml</span><br>apiVersion: v1<br>data:<br>  bar: baz<br>  foo: bar<br>  one: two<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-06-07T11:39:32Z&quot;<br>  name: myconfigmap<br>  namespace: default<br>  resourceVersion: &quot;73938&quot;<br>  uid: c9814e7e-f3f9-4149-8530-74ea963420d9<br></code></pre></td></tr></table></figure><p>发现其实定义的 kv 都在 <code>data</code> 里，<code>metadata</code> 里唯一需要明确指定的是 <code>name</code>，所以通过 yaml 的形式来创建 cm 也比较简单</p><p>如果添加两个同样的 key 会怎样？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config1 --from-literal=sleep-interval=25 --from-literal=sleep-interval=30</span><br>error: cannot add key &quot;sleep-interval&quot;, another key by that name already exists in Data for ConfigMap &quot;fortune-config1&quot;<br></code></pre></td></tr></table></figure><p>可以看到直接创建失败了</p><p>cm 还可以将某个文件的内容作为 value 值，使用 <code>--from-file</code> 来引用文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create cm my-config --from-file=conf.conf</span><br>configmap/my-config created<br></code></pre></td></tr></table></figure><p><code>conf.conf</code> 内容如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>:<span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">a</span>:<span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span>:<span class="hljs-selector-tag">b</span><br>c:c<br>d:d<br></code></pre></td></tr></table></figure><p>查看该 cm 的 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm my-config -o yaml</span><br>apiVersion: v1<br>data:<br>  conf.conf: |<br>    a:a<br>    b:b<br>    c:c<br>    d:d<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-06-07T12:58:09Z&quot;<br>  name: my-config<br>  namespace: default<br>  resourceVersion: &quot;77327&quot;<br>  uid: 2937d396-8692-4c16-8798-236fc4015299<br></code></pre></td></tr></table></figure><p>发现这里是用文件名来做 key 的，value 就是文件的内容，只不过不是常规的 key:value 形式，而是在 key: 后多加了一个 |，之后才是 value</p><p>同样也可以通过指定多个 <code>--from-file</code> 来引用多个文件作为 cm 的条目，比如（这里我还专门测试了一下该 flag 是否对文件后缀有要求，我传入了一个 txt，这不是常见的配置文件后缀）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create cm my-config1 --from-file=conf.conf --from-file conf.txt</span><br>configmap/my-config1 created<br></code></pre></td></tr></table></figure><p>查看 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm my-config1 -o yaml</span><br>apiVersion: v1<br>data:<br>  conf.conf: |<br>    a:a<br>    b:b<br>    c:c<br>    d:d<br>  conf.txt: |<br>    大数据断开了撒娇漏打卡所经历的卡所经历的<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-06-07T13:13:16Z&quot;<br>  name: my-config1<br>  namespace: default<br>  resourceVersion: &quot;77980&quot;<br>  uid: 3332d608-4184-48bc-8481-bd78ccf8b312<br></code></pre></td></tr></table></figure><p>貌似这里是直接简单粗暴的把文件内容作为 value 了，至于文件后缀是什么，cm 不会去考虑，不过想想确实也只能这么做，毕竟配置文件后缀非常多，conf、yaml、toml 等等，可能还有一些冷门的格式，如果要专门维护一个允许的后缀列表显然太麻烦了，也没啥太大必要。</p><p>上面的 key 都是直接使用文件名，如果想自行指定，可以使用类似下面的语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create cm my-config1 --from-file=myconf=conf.conf</span><br></code></pre></td></tr></table></figure><p>这里设置 key 为 myconf，也就是说格式是：–from-file&#x3D;[自定义 key 名]&#x3D;[value]</p><h2 id="给容器传递-ConfigMap-作为环境变量"><a href="#给容器传递-ConfigMap-作为环境变量" class="headerlink" title="给容器传递 ConfigMap 作为环境变量"></a>给容器传递 ConfigMap 作为环境变量</h2><p><strong>fortune-pod-env-configmap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-env-from-configmap</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span> <span class="hljs-comment"># 注意该 image 仅适用于 arm64</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">configMapKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">sleep-interval</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="如果引用的-ConfigMap-不存在会怎样"><a href="#如果引用的-ConfigMap-不存在会怎样" class="headerlink" title="如果引用的 ConfigMap 不存在会怎样"></a>如果引用的 ConfigMap 不存在会怎样</h3><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-env-configmap.yaml</span><br>pod/fortune-env-from-configmap created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                         READY   STATUS                       RESTARTS   AGE<br>fortune2s                    2/2     Running                      0          117m<br>fortune-env                  2/2     Running                      0          33m<br>fortune-env-from-configmap   1/2     CreateContainerConfigError   0          2m27s<br></code></pre></td></tr></table></figure><p>发现当前 pod 的状态是 CreateContainerConfigError，这是肯定的，env 会从名为 keyfortune-config 的 configMap 中读取，但是现在没有创建这个 configMap，所以当然无法正常启动</p><p>查看 describe 也会发现有相应的警告：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Warning</span>  <span class="hljs-string">Failed</span>     <span class="hljs-string">80s</span> <span class="hljs-string">(x7</span> <span class="hljs-string">over</span> <span class="hljs-string">2m28s)</span>  <span class="hljs-attr">kubelet            Error:</span> <span class="hljs-string">configmap</span> <span class="hljs-string">&quot;fortune-config&quot;</span> <span class="hljs-string">not</span> <span class="hljs-string">found</span><br></code></pre></td></tr></table></figure><p>需要创建一个 configMap 来解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个 configMap，同时向其中写入 sleep-interval=5</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-literal=sleep-interval=5</span><br>configmap/fortune-config created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在创建完 configMap 之后，之前的 pod 立马成功运行了</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                         READY   STATUS    RESTARTS   AGE<br>fortune2s                    2/2     Running   0          121m<br>fortune-env                  2/2     Running   0          37m<br>fortune-env-from-configmap   2/2     Running   0          7m3s<br></code></pre></td></tr></table></figure><p>也就是说如果引用的 ConfigMap 不存在，那么 pod 会创建失败，当所需要的 ConfigMap 被创建后，这个失败的 pod 会自动重启，无须重新创建 pod。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-env 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 5s;<span class="hljs-keyword">done</span></span><br>You&#x27;ll feel much better once you&#x27;ve given up hope.<br>When I reflect upon the number of disagreeable people who I know who have gone<br>to a better world, I am moved to lead a different life.<br>-- Mark Twain, &quot;Pudd&#x27;nhead Wilson&#x27;s Calendar&quot;<br></code></pre></td></tr></table></figure><h2 id="给容器传递-ConfigMap-作为参数"><a href="#给容器传递-ConfigMap-作为参数" class="headerlink" title="给容器传递 ConfigMap 作为参数"></a>给容器传递 ConfigMap 作为参数</h2><p>pod.spec.containers.args 不能直接引用 ConfigMap 中的条目，但是可以”曲线救国“，将 ConfigMap 中的条目设置为一个环境变量，然后再让 args 来引用这个环境变量，便可达到效果。</p><p><strong>fortune-pod-args-configmap.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-args-from-configmap</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-args-arm64</span> <span class="hljs-comment"># 注意该 image 仅适用于 arm64</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span> <span class="hljs-comment"># 这个环境变量引用了 fortune-config 中的 sleep-interval 条目</span><br>      <span class="hljs-attr">valueFrom:</span> <br>        <span class="hljs-attr">configMapKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">sleep-interval</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;$(INTERVAL)&quot;</span>] <span class="hljs-comment"># 引用 INTERVAL 这个环境变量</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-args-configmap.yaml</span><br>pod/fortune-args-from-configmap created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                          READY   STATUS    RESTARTS   AGE<br>fortune2s                     2/2     Running   0          7h13m<br>fortune-env                   2/2     Running   0          5h49m<br>fortune-env-from-configmap    2/2     Running   0          5h18m<br>fortune-args-from-configmap   2/2     Running   0          5s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-env 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl localhost:8080;<span class="hljs-built_in">sleep</span> 5s;<span class="hljs-keyword">done</span></span><br>What good is an obscenity trial except to popularize literature?<br>-- Nero Wolfe, &quot;The League of Frightened Men&quot;<br>They spell it &quot;da Vinci&quot; and pronounce it &quot;da Vinchy&quot;.  Foreigners<br>always spell better than they pronounce.<br>-- Mark Twain<br>Give your very best today.  Heaven knows it&#x27;s little enough.<br></code></pre></td></tr></table></figure><h2 id="使用-ConfigMap-卷"><a href="#使用-ConfigMap-卷" class="headerlink" title="使用 ConfigMap 卷"></a>使用 ConfigMap 卷</h2><p><del>前面提到的环境变量或者是参数的方式比较适用于配置数量较少的情况，如果配置数量过多，那么就不太适合了，此外还有一些特殊的配置文件格式，比如 nginx ，也不太适合。</del>（待修改）</p><p>还可以将 ConfigMap <del>挂载（感觉挂载这个词有点不太合适）</del> 做成一个 <strong>卷</strong>，然后pod 中的容器可以将这个卷挂载到自己的某个目录下，来完成配置，比如一个 nginx 容器可以将卷挂载到自己的 &#x2F;etc&#x2F;nginx&#x2F;conf.d 目录下，就可以读取卷中的配置信息。</p><p><strong>configMap卷会将 ConfigMap 中的每个条目均暴露成一个文件</strong>。 运行在容器中的进程可通过读取文件内容获得对应的条目值 。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>创建一个文件夹 <strong>configmap-files</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> configmap-files</span><br></code></pre></td></tr></table></figure><p>然后向里面写入下面的这两个文件：</p><p><strong>my-nginx-config.conf</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>              <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>         www.kubia-example.com;<br><br>    <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">gzip_types</span> text/plain application/xml;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sleep-interval</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">25<br></code></pre></td></tr></table></figure><p>查看文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── my-nginx-config.conf<br>└── sleep-interval<br></code></pre></td></tr></table></figure><p>创建一个 cm，将这个文件夹作为 value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-file=configmap-files</span><br>error: failed to create configmap: configmaps &quot;fortune-config&quot; already exists<br></code></pre></td></tr></table></figure><p>发现之前以及存在同名的 cm 了，看来重复创建 cm 不能覆盖更新，必须要删除旧的才能创建新的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm</span><br>NAME               DATA   AGE<br>kube-root-ca.crt   1      21h<br>fortune-config     1      6h4m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete cm fortune-config</span><br>configmap &quot;fortune-config&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create configmap fortune-config --from-file=configmap-files</span><br>configmap/fortune-config created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 cm</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get cm fortune-config -o yaml</span><br>apiVersion: v1<br>data:<br>  my-nginx-config.conf: |<br>    server &#123;<br>        listen              80;<br>        server_name         www.kubia-example.com;<br><br>        gzip on;<br>        gzip_types text/plain application/xml;<br><br>        location / &#123;<br>            root   /usr/share/nginx/html;<br>            index  index.html index.htm;<br>        &#125;<br><br>    &#125;<br>  sleep-interval: |<br>    25<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-09-25T11:05:49Z&quot;<br>  name: fortune-config<br>  namespace: default<br>  resourceVersion: &quot;12886&quot;<br>  uid: c9f5ee8a-9078-46cc-955a-3ec72c6ceb62<br></code></pre></td></tr></table></figure><p>发现该 cm 有两个条目，条目名就是目标文件夹下的每个文件的文件名，value 就是文件内容</p><p>接下来定义一个 pod，这个 pod 里的 nginx 容器会将 configMap 卷挂载到自己的 &#x2F;etc&#x2F;nginx&#x2F;conf.d 目录下，而 nginx 会自动将该路径下的所有以 conf 为后缀的文件嵌入到默认配置文件中，而 configMap 卷里面刚好有我们定义的开启了 gzip 的配置文件 my-nginx-config.conf，nginx 读取这个文件来开启 gzip，而卷中的另一个文件 sleep-interval 因为不是以 conf 为后缀的，所以 nginx 不会将其内容嵌入到配置文件。</p><p><strong>fortune-configmap-volume</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-configmap-volume</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">INTERVAL</span> <span class="hljs-comment"># 从 fortune-config 这个 configmap 中读取 sleep-interval，用其值填充环境变量 INTERVAL</span><br>      <span class="hljs-attr">valueFrom:</span><br>        <span class="hljs-attr">configMapKeyRef:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">sleep-interval</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/conf.d</span> <span class="hljs-comment"># 将 config 卷挂载到该路径下</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp/whole-fortune-config-volume</span> <span class="hljs-comment"># 将 config 卷挂载到该路径下</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>        <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span> <span class="hljs-comment"># 定义一个名为 config 的卷，卷引用了 fortune-config 这个 cm 里的内容，会将每个条目做成一个文件</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-configmap-volume.yaml</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                          READY   STATUS    RESTARTS   AGE<br>fortune-configmap-volume      2/2     Running   0          13s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-configmap-volume 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -H <span class="hljs-string">&quot;Accept-Encoding: gzip&quot;</span> -I localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.1<br>Date: Sun, 25 Sep 2022 11:38:16 GMT<br>Content-Type: text/html<br>Last-Modified: Sun, 25 Sep 2022 11:38:06 GMT<br>Connection: keep-alive<br>ETag: W/&quot;63303d9e-135&quot;<br>Content-Encoding: gzip # 这里说明已经开启了 gzip 压缩，配置文件已经生效<br></code></pre></td></tr></table></figure><p>验证挂载：</p><p>前面提到过 ConfigMap 卷会将 config 中的每个条目单独做成一个文件，我们实际验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入 web-server 这个容器</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume -c web-server -- /bin/sh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">看一下挂载路径</span><br>/ # ls /tmp/whole-fortune-config-volume/<br>my-nginx-config.conf  sleep-interval<br><br>/ # ls /etc/nginx/conf.d<br>my-nginx-config.conf  sleep-interval<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发现 configMap 卷全部都被挂载了，且里面有两个文件，每个文件对应 cm 中的一个条目</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出一下文件内容</span><br>/ # cat /etc/nginx/conf.d/sleep-interval<br>25<br><br>/ # cat /tmp/whole-fortune-config-volume/my-nginx-config.conf<br>server &#123;<br>    listen              80;<br>    server_name         www.kubia-example.com;<br><br>    gzip on;<br>    gzip_types text/plain application/xml;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只挂载-ConfigMap-中的部分条目"><a href="#只挂载-ConfigMap-中的部分条目" class="headerlink" title="只挂载 ConfigMap 中的部分条目"></a>只挂载 ConfigMap 中的部分条目</h3><p>上面的例子存在一个问题：sleep-interval 这个配置文件也被挂载到了 nginx 的目录下，但是该配置文件与 nginx 是没任何关系的，为了解决这个问题，可以用指定 items 的方式，如下：</p><p><strong>fortune-pod-configmap-volume-with-items</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-configmap-volume-with-items</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-env-arm64</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/nginx/conf.d/</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">fortune-config</span><br>      <span class="hljs-attr">items:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">my-nginx-config.conf</span> <span class="hljs-comment"># 引用 cm 中的 my-nginx-config.conf 这条条目</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">gzip.conf</span> <span class="hljs-comment"># 将这条条目的内容放到一个名为 gzip.conf 的文件中</span><br></code></pre></td></tr></table></figure><p>测试效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f fortune-pod-configmap-volume-with-items</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                                  READY   STATUS    RESTARTS   AGE<br>fortune2s                             2/2     Running   0          10h<br>fortune-env                           2/2     Running   0          8h<br>fortune-env-from-configmap            2/2     Running   0          8h<br>fortune-args-from-configmap           2/2     Running   0          171m<br>fortune-configmap-volume              2/2     Running   0          92m<br>fortune-configmap-volume-with-items   2/2     Running   0          14s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume-with-items -c web-server -- /bin/sh</span><br>/ # ls /etc/nginx/<br>conf.d/         fastcgi_params  modules/        scgi_params<br>fastcgi.conf    mime.types      nginx.conf      uwsgi_params<br>/ # ls /etc/nginx/conf.d<br>gzip.conf<br>/ # cat /etc/nginx/conf.d/gzip.conf<br>server &#123;<br>    listen              80;<br>    server_name         www.kubia-example.com;<br><br>    gzip on;<br>    gzip_types text/plain application/xml;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到挂载的目录 &#x2F;etc&#x2F;nginx&#x2F;conf.d 下只有 gzip.conf 这一个文件了，之前的 sleep-interval 文件已经没有了，并且 gzip.conf 文件的内容就是 configMap 中 my-nginx-config.conf 这个条目的内容。</p><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>使用环境变量或者命令行参数作为配置源的弊端在于无法在进程运行时更新配置，也就是说如果配置信息发生了变化，需要重启应用来重新读取，达到更新的效果。 而将 ConfigMap 暴露为卷可以达到配置热更新的效果，也就是无须重新创建 pod 或者重启容器。</p><p>使用 kubectl edit 修改 ConfigMap：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl edit cm fortune-config</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Please edit the object below. Lines beginning with a <span class="hljs-string">&#x27;#&#x27;</span> will be ignored,</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">and an empty file will abort the edit. If an error occurs <span class="hljs-keyword">while</span> saving this f</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">reopened with the relevant failures.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">apiVersion: v1</span><br>data:<br>  my-nginx-config.conf: |<br>    server &#123;<br>        listen              80;<br>        server_name         www.kubia-example.com;<br><br>        gzip on;<br>        gzip_types text/plain application/xml;<br><br>        location / &#123;<br>            root   /usr/share/nginx/html;<br>            index  index.html index.htm;<br>        &#125;<br><br>    &#125;<br>  sleep-interval: |<br>    25<br>kind: ConfigMap<br>metadata:<br>  creationTimestamp: &quot;2022-09-25T11:05:49Z&quot;<br>  name: fortune-config<br>  namespace: default<br>  resourceVersion: &quot;12886&quot;<br>  uid: c9f5ee8a-9078-46cc-955a-3ec72c6ceb62<br>~<br>~<br>~<br>- /tmp/kubectl-edit-4270724913.yaml 12/29 41%<br></code></pre></td></tr></table></figure><p>和 vim 一样，按下 i，将 <code>gzip on</code> 修改为 <code>gzip off</code>，然后 esc，输入 :wq，退出并保存，输出 <code>configmap/fortune-config edited</code></p><p>查看修改是否生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume-with-items -c web-server -- <span class="hljs-built_in">cat</span> /etc/nginx/conf.d/gzip.conf</span><br>server &#123;<br>    listen              80;<br>    server_name         www.kubia-example.com;<br><br>    gzip off;<br>    gzip_types text/plain application/xml;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>发现修改已经生效</p><p>配置文件已经修改，继续测试一下 nginx 这边是否生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune-configmap-volume 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -H <span class="hljs-string">&quot;Accept-Encoding: gzip&quot;</span> -I localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.1<br>Date: Sun, 25 Sep 2022 13:27:14 GMT<br>Content-Type: text/html<br>Last-Modified: Sun, 25 Sep 2022 13:26:55 GMT<br>Connection: keep-alive<br>ETag: W/&quot;6330571f-c6&quot;<br>Content-Encoding: gzip<br></code></pre></td></tr></table></figure><p>发现依然输出了 <code>Content-Encoding: gzip</code> ，这是因为虽然修改了配置文件，但是 nginx 并不会监听配置文件并作出响应，所以不会更新 gzip 的状态将其 off，需要手动通知 nginx ，告诉它配置文件发生了变化，需要你重新读取一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it fortune-configmap-volume-with-items -c web-server -- nginx -s reload</span><br>2022/09/25 13:30:40 [notice] 39#39: signal process started<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -H <span class="hljs-string">&quot;Accept-Encoding: gzip&quot;</span> -I localhost:8080</span><br>HTTP/1.1 200 OK<br>Server: nginx/1.23.1<br>Date: Sun, 25 Sep 2022 13:32:37 GMT<br>Content-Type: text/html<br>Content-Length: 27<br>Last-Modified: Sun, 25 Sep 2022 13:32:37 GMT<br>Connection: keep-alive<br>ETag: &quot;63305875-1b&quot;<br>Accept-Ranges: bytes<br></code></pre></td></tr></table></figure><p>此时发现 <code>Content-Encoding: gzip</code> 已经没有了，表示 nginx 这边也已经生效了</p><p>整个过程都没有重启或者重建过 pod，但是最终也达到了更新配置的效果，所以可以做到热更新。</p><p>但是对 k8s 而言，它只是保证在更新 ConfigMap 后同步修改其对应的 ConfigMap 卷，但是对于引用这个 ConfigMap 的应用，k8s 就管不到了，如果应用不会对配置文件的修改作出响应，或者类似 nginx 提供一个重新载入的命令，那么可能最终还是需要重启或者重建 pod（个人猜测）</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go gc 白话版</title>
    <link href="/2022/06/01/go-gc/"/>
    <url>/2022/06/01/go-gc/</url>
    
    <content type="html"><![CDATA[<h1 id="主流的垃圾回收算法"><a href="#主流的垃圾回收算法" class="headerlink" title="主流的垃圾回收算法"></a>主流的垃圾回收算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。</p><ul><li>优点：简单直接，回收速度快</li><li>缺点：需要额外的空间存放计数，无法处理循环引用的情况；</li></ul><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。</p><ul><li>优点：简单直接，速度快，适合可回收对象不多的场景</li><li>缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配，此外还需要 <strong>STW</strong> 来确保标记清除过程不被外部影响（比如 gc 前脚刚把一个对象标记为可达，用户程序后脚就释放了它）；<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446334006.jpg"><br>（内存碎片)</li></ul><blockquote><p>STW（Stop The World，Start The World）</p><p>通常意义上指的是从Stop The World到Start The World这一段时间间隔。垃圾回收过程中为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。STW时间越长，对用户代码造成的影响越大。</p></blockquote><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><p>这种算法用于解决 <strong>标记清除法</strong> 的内存碎片问题，它的标记阶段与标记清除法相同，但是会在完成标记工作后，移动非垃圾数据，使它们尽可能紧凑的放在内存中。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446315708.jpg"></p><ul><li>优点：解决了内存碎片的问题</li><li>缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成</li></ul><h2 id="复制回收法"><a href="#复制回收法" class="headerlink" title="复制回收法"></a>复制回收法</h2><p>和 <strong>标记整理法</strong> 一样，这种算法也是为了解决内存碎片问题，也会移动数据，它把堆内存划分为两个相等的空间 From 和 To，程序执行时使用 From 空间，垃圾回收执行时，会扫描 From 空间，把能追踪到的数据复制到 To 空间，当所有有用的数据都复制到 To 空间后，把 From 和 To 空间的角色交换一下，原来的 From 空间可以全部回收作为新的 To 空间；原来的 To 空间因为保存的都是有用的数据，所以可以作为新的 From 空间。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446282139.jpg"></p><ul><li>优点：解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；</li><li>缺点：只有一半的堆内存可以使用，导致堆内存使用效率低。为了提高内存的使用率，通常会和其他垃圾回收算法搭配使用，只在一部分堆内存中使用复制回收，</li></ul><h2 id="分代式"><a href="#分代式" class="headerlink" title="分代式"></a>分代式</h2><p>将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>到这里才是真正的重头戏，因为 Go 采用的正是这种 GC 算法。</p><p>三色标记法将对象的颜色分为了黑、灰、白，三种颜色。</p><ul><li>黑色：该对象已经被标记过了，且该对象下的属性也全部都被标记过了（程序所需要的对象）；</li><li>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完（GC需要从此对象中去寻找垃圾）；</li><li>白色：该对象没有被标记过（垃圾对象）；</li></ul><p>在垃圾收集器开始工作时，从 GC Roots 开始进行遍历访问，访问步骤可以分为下面几步：</p><ol><li>GC Roots 根对象会被标记成灰色；</li><li>然后从灰色集合中获取对象，将其标记为黑色，将该对象引用到的对象标记为灰色；</li><li>重复步骤2，直到没有灰色集合可以标记为止；</li><li>结束后，剩下的没有被标记的白色对象即为 GC Roots 不可达，可以进行回收。<br><img src="https://autsu.github.io/post-images/1654446199885.png"></li></ol><blockquote><h3 id="❓gc-root-节点具体指哪些？"><a href="#❓gc-root-节点具体指哪些？" class="headerlink" title="❓gc root 节点具体指哪些？"></a>❓gc root 节点具体指哪些？</h3><p>说法1，来源： <a href="https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0%EF%BC%8C2:30">https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0，2:30</a> 秒</p><p>可以把栈、数据段（.data，全局变量）上的数据对象作为 root</p><p>说法 2，来源：<a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p><p>GC 执行根节点的标记，这包括扫描所有的栈、全局对象以及不在堆中的运行时数据结构。</p><p>说法 3，来源：<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.2.GC-GC.md">https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.2.GC-GC.md</a></p><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><ol><li>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li><li>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li><li>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li></ol></blockquote><p>前面提到过，这类标记清理算法都需要 STW 来保证垃圾回收过程不受影响，那么如果没有 STW 会发生什么问题呢？</p><p><strong>问题1：多标</strong></p><p>通俗的说，就是一个本该被回收的对象（白色），却被错误的标记成了非白色，导致本轮 gc 没有正确回收，导致产生浮动垃圾。</p><p>比如下面这张图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654445991637.png"></p><p>在步骤2中，gc 将 D 标记为了黑色，将 D 的可达对象 E 标记为了灰色，但在执行步骤3前，用户程序断开了 D 到 E 的引用（比如从 D &#x3D; E 变成 D &#x3D; null），此时 E 及其引用的 F，G 都会变为垃圾，因为它们都不再可达了，但是因为 D 已经标记成黑色，不会再次对其进行扫描了，这会导致 gc 继续标记，将 E 从灰色变为黑色，E 的引用对象 F 和 G 标记为灰色，最后将 F 和 G 标记为黑色。至此，该轮 gc 结束，E，F，G 都被错误的标记为了黑色而没有被及时回收。</p><blockquote><p>❓写屏障可以解决上面这种情况吗？</p></blockquote><p><strong>问题2：漏标</strong></p><p>通俗的说，就是把一个有用的对象给错误的回收掉了，也就是悬挂指针问题。</p><p>比如下面这张图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446000456.png"></p><p>在步骤2中，E 已经变为灰色，但在 gc 进一步标记之前，用户程序断开了 E 到 G 的引用，同时已经标记为黑色的 D 新增了对 G 的引用，之后 gc 标记时发现 E 到 G 已经不可达，便不会将 G 标记为灰色，而因为 D 已经是黑色不会再次扫描，所以也不会对 G 进行标记，最终，G 依然保持着白色，导致最后被 gc 清理。</p><p>现在问题来了，用 STW 会导致 gc 过程中整个程序不可用，不用 STW 又会出现内存错误，有没有什么办法可以尽可能的让用户程序和 gc 交替（并发）执行，减少 STW  造成的影响，同时又不会出现内存错误呢？比如 <strong>增量式回收</strong>，就是<strong>将 gc 过程分多次完成，也就是用户程序与垃圾回收交替执行</strong>，如下图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446167140.jpg"></p><p>只要满足以下条件，就可以避免之前的内存问题了：</p><h3 id="强三色不变式"><a href="#强三色不变式" class="headerlink" title="强三色不变式"></a>强三色不变式</h3><p><strong>黑色对象不会引用白色对象</strong>，称为 <strong>强三色不变式</strong>，比如在 <strong>问题2：漏标</strong> 中，如果避免黑色对象 D 到白色对象 G 的引用，就不会出现错误回收的问题了。</p><h3 id="弱三色不变式"><a href="#弱三色不变式" class="headerlink" title="弱三色不变式"></a>弱三色不变式</h3><p><strong>黑色对象可以引用白色对象，前提是可以通过一个灰色对象抵达该白色对象</strong>，比如 A（黑）引用了 B（白色），而 C（灰色） 引用了 D（白色），D （白色）又引用了 B（白色），这种情况可以通过 C -&gt; D -&gt; B 抵达 B，这样 B 虽然被一个黑色对象引用，但是最终还是可达，不会被遗漏，这种情况称为 <strong>弱三色不变性</strong> 。</p><p>实现强弱三色不变式的通常做法是建立 <strong>读&#x2F;写屏障</strong>。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p><strong>写屏障</strong> 会在写操作中插入指令，目的是把对象的修改通知到垃圾回收器，比如当一个黑色对象尝试引用一个白色对象时，就会触发写屏障，此时为了保证 <strong>强三色不变式</strong>，就会将被引用的白色对象变为灰色，或者将引用白色对象的黑色对象变为灰色，这种写屏障属于 <strong>插入写屏障</strong> ；又或者是一个灰色对象尝试去除对一个白色对象的引用，为了保证 <strong>弱三色不变式</strong>，会将这个白色对象变为灰色，这种写屏障属于 <strong>删除写屏障</strong>。</p><h4 id="插入写屏障的缺点"><a href="#插入写屏障的缺点" class="headerlink" title="插入写屏障的缺点"></a>插入写屏障的缺点</h4><p>**插入写屏障 **虽然实现非常简单并且也能保证强三色不变性，但是它也有明显的缺点。因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，必须：</p><ul><li><strong>为栈上的对象增加写屏障</strong></li></ul><p> 或者</p><ul><li><strong>在标记阶段完成重新对栈上的对象进行扫描</strong></li></ul><p>这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。</p><h4 id="删除写屏障的缺点"><a href="#删除写屏障的缺点" class="headerlink" title="删除写屏障的缺点"></a>删除写屏障的缺点</h4><p>而 <strong>删除写屏障</strong> 会存在 <strong>回收效率低</strong> 的问题，因为当删除灰色对象到白色对象的引用时，会直接将白色对象赋为灰色，但是这个白色对象可能本身是垃圾，可以在本轮被清除了，但是却逃过了本轮的清理。比如：</p><p>黑 —–&gt; 灰 —–&gt; 白</p><p>如果在扫描到白之前，断开灰到白的连接，此时因为白是整个调用链的最后一个对象，所以将会成为垃圾，但是因为删除写屏障的存在，会将该白色对象变为灰色，导致本轮 GC 未被清理。</p><h3 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h3><p><strong>读屏障</strong> 适用于移动式垃圾回收，非移动式垃圾回收天然的不需要读屏障。像复制式回收这样会移动数据来避免碎片化，那么 gc 和用户程序交替执行时，读数据便也不那么安全了，比如下图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654446082893.jpg"></p><p>回收器已经将 A 从 From 复制到 To 空间了，之后交替执行的用户程序却读取了 From 空间中的老对象，并且在对象 B 中引用了这个老对象 A，而后续回收器复制 B 到 To 空间后，B 的新副本持有的依然是 A 的老对象指针，当 From 空间整体被回收时，因为 B 指向的依然是 From 空间的 A，所以访问便会出错。这种情况下，就需要建立读屏障，确保用户程序不会访问到老对象，例如在检测到引用对象已经存在新副本时，转而读取 To 空间的新副本。</p><h1 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h1><p>Go 的 GC 结合了插入写屏障和删除写屏障的优点，称之为 <strong>混合写屏障</strong>，它的规则如下：</p><ul><li>GC 开始将栈上的对象全部扫描并标记为黑色；</li><li>GC 期间，任何在栈上创建的新对象，均为黑色；</li><li>被删除的堆对象标记为灰色；</li><li>被添加的堆对象标记为灰色；</li></ul><p><del>Go 团队在最终实现时，<strong>没有为所有栈上的指针写操作启用写屏障</strong>，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了 <strong>灰色赋值器</strong>，将会需要标记终止阶段 STW 时对这些栈进行 <strong>重新扫描</strong>（v1.7 版本之前）。</del></p><p>一些例子：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C1-1.webp"></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C1-2.webp"></p><p>看到这里我有一个疑问，这里就算不把对象 7 变成灰色，貌似也不会影响什么，因为它的上游对象对象 4 依然是灰色而不是黑色，所以会继续扫描到对象 7，然后再继续扫描到对象 6，为什么会说对象 6 被保护呢？</p><p>然后我想了一下，这样做是为了防止这种情况的发生：在对象 4 准备扫描对象 7之前，用户程序断开了对象 4 到对象 7 的引用，导致此时的对象 7 依然是白色，如果这时黑色对象 10 再引用白色对象 7，为了保证强三色不变性，就需要将对象 7 变为灰色。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C1-3.webp"></p><h1 id="参考（抄袭）"><a href="#参考（抄袭）" class="headerlink" title="参考（抄袭）"></a>参考（抄袭）</h1><p>Go语言GC实现原理及源码分析 <a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a> </p><p>Golang垃圾回收(GC)介绍 <a href="https://liangyaopei.github.io/2021/01/02/golang-gc-intro/">https://liangyaopei.github.io/2021/01/02/golang-gc-intro/</a></p><p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/">https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/</a></p><p><a href="https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1n5411H7qS?spm_id_from=333.999.0.0</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s namespace</title>
    <link href="/2022/05/31/k8s-namespace/"/>
    <url>/2022/05/31/k8s-namespace/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Namespace</strong> 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pods, services, replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是default），而 node, persistentVolumes 等则不属于任何 namespace。</p><p>Namespace 常用来隔离不同的用户，比如 Kubernetes 自带的服务一般运行在 kube-system namespace 中。</p><p>Namespace 适用于存在很多跨多个团队或项目的用户的场景。例如，如果使用命名空间来划分应用程序生命周期环境（如开发、测试、生产），则可以在每个环境中维护利用同样的名称维护相同对象的副本。</p><p>同一 namespace 内的资源名称要唯一，但跨 namespace 时没有这个要求，通俗的说，就是两个资源如果名称相同，但是所在的命名空间不同是可以的。</p><p>疑问：</p><p>label（标签）也可以对资源进行分类，它和 namespace 有什么区别？</p><p>由于每个对象都可以有多个标签，因此这些对象组可以重叠。另外，当在集群中工作(例如通过 kubectl )时，如果没有明确指定标签选择器，我们总能看到所有对象。而 namespace 可以将资源分割为完全独立不重叠的组，我个人的理解是，namespace 提供了比 label 更严格的资源分类，其主要针对的是不同用户间的划分，而 label 则倾向于诸如对同一软件不同版本这种情况进行划分。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="查看所有的-namespace"><a href="#查看所有的-namespace" class="headerlink" title="查看所有的 namespace"></a>查看所有的 namespace</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get ns</span><br>NAME              STATUS   AGE<br>default           Active   24d<br>kube-system       Active   24d<br>kube-public       Active   24d<br>kube-node-lease   Active   24d<br></code></pre></td></tr></table></figure><p>Kubernetes 会创建四个初始 namespace：</p><ul><li><code>default</code> 如果资源没有明确指定其所属的 namespace，则会默认使用该 namespace</li><li><code>kube-system</code> Kubernetes 系统创建对象所使用的 namespace</li><li><code>kube-public</code> 这个 namespace 是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。 这个 namespace 主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个 namespace 的公共方面只是一种约定，而不是要求。</li><li><code>kube-node-lease</code> 此 namespace 用于与各个节点相关的 <a href="https://kubernetes.io/docs/reference/kubernetes-api/cluster-resources/lease-v1/">租约（Lease）</a>对象。 节点租期允许 kubelet 发送<a href="https://kubernetes.io/zh/docs/concepts/architecture/nodes/#heartbeats">心跳</a>，由此控制面能够检测到节点故障。</li></ul><h2 id="指定-namespace"><a href="#指定-namespace" class="headerlink" title="指定 namespace"></a>指定 namespace</h2><p>可以将 namespace 作为筛选&#x2F;属性，比如下面的查询 pod 操作使用 namespace 作为筛选条件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -n kube-system</span><br>NAME                                      READY   STATUS      RESTARTS       AGE<br>helm-install-traefik-crd-q62cm            0/1     Completed   0              24d<br>helm-install-traefik-l2wcr                0/1     Completed   1              24d<br>svclb-traefik-f4w7g                       2/2     Running     12 (50m ago)   24d<br>traefik-df4ff85d6-2rbl2                   1/1     Running     15 (50m ago)   24d<br>coredns-d76bd69b-7bkb4                    1/1     Running     18 (50m ago)   24d<br>local-path-provisioner-6c79684f77-qjq26   1/1     Running     7 (50m ago)    24d<br>metrics-server-7cd5fcb6b7-b72lz           1/1     Running     25 (50m ago)   24d<br></code></pre></td></tr></table></figure><p>也可以使用 –namespace 命令，如果不指定则默认为 default</p><p>也可以在创建资源的时候为其指定 namespace：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create -f kubia-manual.yam1 -n custom-namespace</span> <br>pod ”kubia-manual&quot; created<br></code></pre></td></tr></table></figure><h2 id="创建-namespace"><a href="#创建-namespace" class="headerlink" title="创建 namespace"></a>创建 namespace</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create ns ns-test</span><br>namespace/ns-test created<br></code></pre></td></tr></table></figure><h2 id="删除-namespace"><a href="#删除-namespace" class="headerlink" title="删除 namespace"></a>删除 namespace</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete ns ns-test</span><br>namespace &quot;ns-test&quot; deleted<br></code></pre></td></tr></table></figure><p><strong>Warning:</strong> 这会删除名字空间下的 <em>所有内容</em> ！</p><h1 id="namespace-与-DNS"><a href="#namespace-与-DNS" class="headerlink" title="namespace 与 DNS"></a>namespace 与 DNS</h1><p>当你创建<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">服务</a>时，Kubernetes 会创建相应的 <a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/">DNS 条目</a>。 此条目的格式为 <code>&lt;服务名称&gt;.&lt;名字空间名称&gt;.svc.cluster.local</code>。 这意味着如果容器使用 <code>&lt;服务名称&gt;</code>，它将解析为名字空间本地的服务。 这对于在多个名字空间（如开发、暂存和生产）中使用相同的配置非常有用。 如果要跨名字空间访问，则需要使用完全限定的域名（FQDN）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go errgroup 使用</title>
    <link href="/2022/05/28/errgroup/"/>
    <url>/2022/05/28/errgroup/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>errgroup</strong> 是 WaitGroup 的强化版，其在 WaitGroup 的基础上添加了错误处理的功能：如果一组 goroutine 中的某一个发生了错误，那么后续的所有 gorouine 都不会被执行。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><p>一共开启 10 个 goroutine 执行任务，其中第三个 goroutine 会出错，使用 errgroup 可以保证第三个之后的所有 goroutine 都不会执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>group, ctx := errgroup.WithContext(context.Background())<br>count := <span class="hljs-number">50</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>i := i <span class="hljs-comment">// 闭包重新捕获变量 i</span><br>group.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Printf(<span class="hljs-string">&quot;[%d] group 里有一个任务失败了，所以这个任务不会执行\n&quot;</span>, i)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;[%d] error\n&quot;</span>, i)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;[%d] error&quot;</span>, i)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;[%d] success\n&quot;</span>, i)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>time.Sleep(time.Millisecond * <span class="hljs-number">10</span>)<br>&#125;<br><span class="hljs-keyword">if</span> err := group.Wait(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [0] success</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [1] success</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [2] success</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [3] error</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [4] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [5] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [6] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [7] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [8] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">// 2022/05/29 00:02:51 [9] group 里有一个任务失败了，所以这个任务不会执行</span><br><span class="hljs-comment">//2022/05/29 00:02:51 [3] error</span><br></code></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><p>来源：<a href="https://lailin.xyz/post/go-training-week3-errgroup.html">https://lailin.xyz/post/go-training-week3-errgroup.html</a></p><p>因为我是跳过文章前面的内容直接看示例的，所以一开始有点看不懂注释写的意思，后来翻了一下源码才明白，对注释针对自己的简介进行了一些修改。</p><p>这个示例的大致意思是：使用 errgroup 开启了 3 个 goroutine，第一个运行 HTTP 服务，第二个监听 shutdown 接口用来关闭 HTTP 服务，第三个监听 ctrl+c 和 kill 这两个信号。这三个中的任何一个发生错误退出，都会让另外两个 goroutine 也退出（准确的说，运行 HTTP 服务的 goroutine 是不会主动退出的，只有第二个能将其结束，另外两个都可以主动结束，第二个执行 curl localhost:8080&#x2F;shutdown 可以触发，第三个使用 ctrl+c 或者 kill 都可以触发）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// WithContext() 里面用 context.Cancel 包装了传入的 context，并返回包装后</span><br><span class="hljs-comment">// 的 ctx，而另一个返回值 cancel 则是放到了 errgroup.Group 里面</span><br><span class="hljs-comment">// 如果 g.Go(func() error) 里面的 func 返回了错误，那么会调用 Group.cancel</span><br><span class="hljs-comment">// 将包装的 ctx 取消</span><br>g, ctx := errgroup.WithContext(context.Background())<br><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))<br>&#125;)<br><br><span class="hljs-comment">// 模拟单个服务错误退出</span><br>serverOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>mux.HandleFunc(<span class="hljs-string">&quot;/shutdown&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>serverOut &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;)<br><br>server := http.Server&#123;<br>Handler: mux,<br>Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// g1</span><br><span class="hljs-comment">// g1 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g1 退出后, context 将不再阻塞（这话第一眼没看懂，context 还会被阻塞？），g2, g3 都会随之退出</span><br><span class="hljs-comment">// 修改版注释：g1 只有在 g2 调用 Shutdown() 后才会退出，同时返回一个 error</span><br><span class="hljs-comment">// 之后 ctx 被 cancel，其他 goroutine 的 select 都会走 case &lt;-ctx.Done() 分支，</span><br><span class="hljs-comment">// 从而达到退出的目的（因为 select 没有加 default 分支，所以会被阻塞，直到有一个 case</span><br><span class="hljs-comment">// 满足条件，所以上面说的 context 将不再阻塞，实际应该是 select 不再阻塞）</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// g2 的 Shutdown 会让这里停止阻塞并返回一个 err</span><br><span class="hljs-comment">// 之后 ctx 会被 cancel 掉，g3 也会停止</span><br><span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;g1 error: &quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-comment">// g2</span><br><span class="hljs-comment">// g2 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br><span class="hljs-comment">// g2 退出后, context 将不再阻塞，g3 会随之退出</span><br><span class="hljs-comment">// 修改：g2 退出后, g1 cancel 掉了 ctx，g3 的 select 将不再阻塞，g3 会随之退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Println(<span class="hljs-string">&quot;errgroup exit...&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-serverOut: <span class="hljs-comment">// curl localhost:8080/shutdown</span><br>log.Println(<span class="hljs-string">&quot;server will out...&quot;</span>)<br>&#125;<br><br>cancelCtx, cancel := context.WithCancel(context.Background())<br><span class="hljs-comment">// 这里不是必须的，但是如果使用 _ 的话静态扫描工具会报错，加上也无伤大雅</span><br><span class="hljs-keyword">defer</span> cancel()<br><br>log.Println(<span class="hljs-string">&quot;shutting down server...&quot;</span>)<br><span class="hljs-comment">// Shutdown() 会停止 g1，同时 g1 的 ListenAndServe() 会返回一个 error</span><br><span class="hljs-keyword">if</span> err := server.Shutdown(cancelCtx); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;g2 error: &quot;</span>, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><br><span class="hljs-comment">// g3</span><br><span class="hljs-comment">// g3 捕获到 os 退出信号将会退出</span><br><span class="hljs-comment">// g3 退出了所有的协程都能退出么？</span><br><span class="hljs-comment">// g3 退出后, context 将不再阻塞，g2 会随之退出</span><br><span class="hljs-comment">// 修改：g3 收到信号返回一个 error 并退出，ctx 会被 cancel 掉，然后 g2 的 select</span><br><span class="hljs-comment">// 停止阻塞，执行下面的流程</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">0</span>)<br>signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>log.Println(<span class="hljs-string">&quot;g3: ctx is done&quot;</span>)<br><span class="hljs-keyword">return</span> ctx.Err()<br><span class="hljs-keyword">case</span> sig := &lt;-quit:<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;get os signal: %v&quot;</span>, sig)<br>&#125;<br>&#125;)<br><br>fmt.Printf(<span class="hljs-string">&quot;errgroup exiting: %+v\n&quot;</span>, g.Wait())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h2><p>errgroup 还可以限制同时开启的 goroutine 数量，其实本质也是使用 WaitGroup + channel 来实现的。</p><p>下面的代码保证最多只开启 2 个 goroutine，其他的都会阻塞等待，值得一提的是，Group 即便是零值也是可以直接使用的，只是没有了 cancel 的能力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>eg := errgroup.Group&#123;&#125;<br>count := <span class="hljs-number">20</span><br>mostRunning := <span class="hljs-number">2</span><br>eg.SetLimit(mostRunning)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>i := i<br>eg.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>log.Println(i)<br>time.Sleep(<span class="hljs-number">300</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br><br>eg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Group is a collection of goroutines working on subtasks that are part of</span><br><span class="hljs-comment">// the same overall task.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A zero Group is valid and does not cancel on error.</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// Group 是一组 goroutines，它们处理属于同一整体任务的子任务。零值是有效的，并且不会因错误而取消。</span><br><span class="hljs-comment">// 因为零值的 cancel 是 nil，所以自然不会被执行</span><br><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>cancel <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 发生错误时会调用该函数，将 WithContext 创建的 ctx 取消</span><br><br>wg sync.WaitGroup<br><br>  sem <span class="hljs-keyword">chan</span> token<span class="hljs-comment">// 带缓存的 chan，用来限制可以创建的 goroutine 数量，token 是 struct&#123;&#125; 的别名</span><br><br>errOnce sync.Once<span class="hljs-comment">// 确保只有第一次发生错误时才执行某些操作</span><br>err     <span class="hljs-type">error</span><span class="hljs-comment">// 记录第一次发生的错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WithContext"><a href="#WithContext" class="headerlink" title="WithContext"></a>WithContext</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithContext returns a new Group and an associated Context derived from ctx.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The derived Context is canceled the first time a function passed to Go</span><br><span class="hljs-comment">// returns a non-nil error or the first time Wait returns, whichever occurs</span><br><span class="hljs-comment">// first.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// WithContext 返回一个 Group 和一个从 ctx 派生的关联上下文。派生的 Context 在 Go 函数第一次返</span><br><span class="hljs-comment">// 回错误或 Wait 第一次返回时被取消，以先发生者为准。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithContext</span><span class="hljs-params">(ctx context.Context)</span></span> (*Group, context.Context) &#123;<br>  <span class="hljs-comment">// 用 WithCancel 包装了传入的 ctx</span><br>ctx, cancel := context.WithCancel(ctx)<br>  <span class="hljs-comment">// 将 cancel 保存到 Cancel 属性</span><br><span class="hljs-keyword">return</span> &amp;Group&#123;cancel: cancel&#125;, ctx<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go calls the given function in a new goroutine.</span><br><span class="hljs-comment">// It blocks until the new goroutine can be added without the number of</span><br><span class="hljs-comment">// active goroutines in the group exceeding the configured limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The first call to return a non-nil error cancels the group; its error will be</span><br><span class="hljs-comment">// returned by Wait.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Go 在一个新的 goroutine 中调用给定的函数。如果当前运行的 goroutine 数量达到了 limit 的上限，则会阻</span><br><span class="hljs-comment">// 塞，直到可以添加。如果调用 f 返回了错误，则会取消该组（也就是调用 Group.cancel，只有第一次发生错误时</span><br><span class="hljs-comment">// 会执行该操作），Wait 会返回它的错误。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Go(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> &#123;<br>g.sem &lt;- token&#123;&#125;<span class="hljs-comment">// 如果当前开启的 goroutine 数量大于 limit 则会被阻塞</span><br>&#125;<br><br>g.wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> g.done()<br><br><span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-comment">// 只执行一次，保证只有第一次发生错误时执行</span><br>g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        g.err = err<span class="hljs-comment">// 保存错误，Wait() 会返回这个错误</span><br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>          g.cancel()<span class="hljs-comment">// cancel 掉 WithContext() 创建的 ctx</span><br>&#125;<br>&#125;)<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SetLimit"><a href="#SetLimit" class="headerlink" title="SetLimit"></a>SetLimit</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetLimit limits the number of active goroutines in this group to at most n.</span><br><span class="hljs-comment">// A negative value indicates no limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Any subsequent call to the Go method will block until it can add an active</span><br><span class="hljs-comment">// goroutine without exceeding the configured limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The limit must not be modified while any goroutines in the group are active.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// SetLimit 将这个组中的活动 goroutine 的数量限制为最多 n。负值表示没有限制。</span><br><span class="hljs-comment">// 对 Go 方法的任何后续调用都将阻塞，直到它可以添加一个活动的 goroutine 而不会</span><br><span class="hljs-comment">// 超过配置的限制。当组中的任何 goroutine 处于活动状态时，不得修改限制。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> SetLimit(n <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br>g.sem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g.sem) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;errgroup: modify limit while %v goroutines in the group are still active&quot;</span>, <span class="hljs-built_in">len</span>(g.sem)))<br>&#125;<br>g.sem = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> token, n)<span class="hljs-comment">// 使用带缓存的 chan</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TryGo"><a href="#TryGo" class="headerlink" title="TryGo"></a>TryGo</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TryGo calls the given function in a new goroutine only if the number of</span><br><span class="hljs-comment">// active goroutines in the group is currently below the configured limit.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The return value reports whether the goroutine was started.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 仅当组中当前活动的 goroutine 的数量低于配置的限制时，TryGo 才会在新的 goroutine 中调用给定的函数。</span><br><span class="hljs-comment">// 返回值报告 goroutine 是否已启动。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> TryGo(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> g.sem != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> g.sem &lt;- token&#123;&#125;:<br><span class="hljs-comment">// Note: this allows barging iff channels in general allow barging.</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br>g.wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> g.done()<br><br><span class="hljs-keyword">if</span> err := f(); err != <span class="hljs-literal">nil</span> &#123;<br>g.errOnce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>g.err = err<br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>g.cancel()<br>&#125;<br>&#125;)<br>&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wait blocks until all function calls from the Go method have returned, then</span><br><span class="hljs-comment">// returns the first non-nil error (if any) from them.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 阻塞等待，直到来自 Go 方法的所有函数调用都返回，然后从它们返回第一个非零错误（如果有）。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Wait() <span class="hljs-type">error</span> &#123;<br>g.wg.Wait()<br><span class="hljs-keyword">if</span> g.cancel != <span class="hljs-literal">nil</span> &#123;<br>g.cancel()<br>&#125;<br><span class="hljs-keyword">return</span> g.err<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来看，源码还是比较简单的，也比较容易阅读。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kqueue</title>
    <link href="/2022/05/28/kqueue/"/>
    <url>/2022/05/28/kqueue/</url>
    
    <content type="html"><![CDATA[<p>一个 echo server 示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> eventNum = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.Ldate)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">//log.Printf(&quot;listen fd: %v\n&quot;, sfd)</span><br><br><span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>kfd, err := Kqueue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>change := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(sfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>_, err = Kevent(kfd, []Kevent_t&#123;change&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<span class="hljs-comment">// 添加监听事件，第三个参数传空</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>events := <span class="hljs-built_in">make</span>([]Kevent_t, eventNum)<br>        <span class="hljs-comment">// 获取就绪事件，第二个参数传空</span><br>readyEventNum, err := Kevent(kfd, <span class="hljs-literal">nil</span>, events, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 无限等待直到有事件产生</span><br><span class="hljs-comment">//fmt.Printf(&quot;readyEventNum: %v\n&quot;, readyEventNum)</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != EINTR &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; readyEventNum; i++ &#123;<br>event := events[i]<br>log.Printf(<span class="hljs-string">&quot;event fd: %v \n&quot;</span>, event.Ident)<br>efd := <span class="hljs-type">int</span>(event.Ident)<br><span class="hljs-keyword">if</span> efd == sfd &#123;<br>nfd, _, err := Accept(sfd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;accept event, fd: %v\n&quot;</span>, nfd)<br><span class="hljs-keyword">if</span> err := SetNonblock(nfd, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-comment">//panic(err)</span><br>&#125;<br>change := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(nfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>                <span class="hljs-comment">// 添加监听事件，第三个参数传空</span><br>_, err = Kevent(kfd, []Kevent_t&#123;change&#125;, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read event\n&quot;</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := Read(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>_, err = Write(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>错误版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> eventNum = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.Ldate)<br>&#125;<br><br><span class="hljs-comment">// BUG 记录：</span><br><span class="hljs-comment">// 1. 客户端断开连接后，服务端仍然会产生读事件</span><br><span class="hljs-comment">// 客户端断开连接后，服务端的 Read 会发生 connection reset by peer 错误并进入错误处理分支， Close 掉这</span><br><span class="hljs-comment">// 个连接，但是因为错误处理采用的是 continue 而不是 break（因为可能会同时产生多个事件，也就是 kevent 的返</span><br><span class="hljs-comment">// 回值，如果使用 break，会导致后面的事件全部被放弃处理，因为多个事件中的某一个事件产生错误，而直接跳过后续事</span><br><span class="hljs-comment">// 件的处理，显然是不合理的），会重新进入外层的死循环，又因为会继续产生读事件，导致 Kevent 函数成功返回，进</span><br><span class="hljs-comment">// 入到读事件分支，进行 Read 操作，此时会报错 bad file descriptor，continue 到最外层死循环，如此反复，</span><br><span class="hljs-comment">// 直到循环很多次以后会抛出一个 panic</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;listen fd: %v\n&quot;</span>, sfd)<br><br><span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>changes = <span class="hljs-built_in">make</span>([]Kevent_t, <span class="hljs-number">0</span>) <span class="hljs-comment">// 监听列表</span><br>events  = <span class="hljs-built_in">make</span>([]Kevent_t, eventNum) <span class="hljs-comment">// 发生的事件列表，len 不能为 0</span><br>)<br><br>kfd, err := Kqueue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>readEvent := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(sfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, readEvent)<br><span class="hljs-comment">// BUG1 解决步骤1 ：新增下面这个函数调用</span><br><span class="hljs-comment">// _, err = Kevent(kfd, changes, nil, nil)</span><br><span class="hljs-comment">// if err != nil &#123;</span><br><span class="hljs-comment">// panic(err)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// BUG1 解决步骤2：</span><br><span class="hljs-comment">// 这里的第二个参数必须传 nil，如果传 changes 就会出现 BUG1 的情况</span><br>readyEventNum, err := Kevent(kfd, changes, events, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 无限等待直到有事件产生</span><br>fmt.Printf(<span class="hljs-string">&quot;readyEventNum: %v\n&quot;</span>, readyEventNum)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != EINTR &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;events: %v \n&quot;</span>, events)<br>log.Printf(<span class="hljs-string">&quot;changes: %v \n&quot;</span>, changes)<br>log.Printf(<span class="hljs-string">&quot;readyEventNum: %v\n&quot;</span>, readyEventNum)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; readyEventNum; i++ &#123;<br>event := events[i]<br>log.Printf(<span class="hljs-string">&quot;event fd: %v \n&quot;</span>, event.Ident)<br>efd := <span class="hljs-type">int</span>(event.Ident)<br><span class="hljs-keyword">if</span> efd == sfd &#123;<br>nfd, _, err := Accept(sfd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;accept event, fd: %v\n&quot;</span>, nfd)<br><span class="hljs-keyword">if</span> err := SetNonblock(nfd, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-comment">//panic(err)</span><br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(nfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;)<br><span class="hljs-comment">// BUG1 解决步骤3 ：新增下面这个函数调用</span><br><span class="hljs-comment">// _, err = Kevent(kfd, changes, nil, nil)</span><br><span class="hljs-comment">// if err != nil &#123;</span><br><span class="hljs-comment">// panic(err)</span><br><span class="hljs-comment">// &#125;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">/*if event.Filter == EVFILT_READ*/</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read event\n&quot;</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := Read(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>_, err = Write(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正确版本：</p><p>按照注释上的标注进行修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>. <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> eventNum = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>log.SetFlags(log.Lshortfile | log.Ldate)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;listen fd: %v\n&quot;</span>, sfd)<br><br><span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>changes = <span class="hljs-built_in">make</span>([]Kevent_t, <span class="hljs-number">0</span>) <span class="hljs-comment">// 监听列表</span><br>events  = <span class="hljs-built_in">make</span>([]Kevent_t, eventNum) <span class="hljs-comment">// 发生的事件列表，len 不能为 0</span><br>)<br><br>kfd, err := Kqueue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>readEvent := Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(sfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, readEvent)<br><span class="hljs-comment">// BUG1 解决步骤1 ：新增下面这个函数调用</span><br>_, err = Kevent(kfd, changes, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// BUG1 解决步骤2：</span><br><span class="hljs-comment">// 这里的第二个参数必须传 nil，如果传 changes 就会出现 BUG1 的情况</span><br>readyEventNum, err := Kevent(kfd, <span class="hljs-literal">nil</span>, events, <span class="hljs-literal">nil</span>) <span class="hljs-comment">// 无限等待直到有事件产生</span><br><span class="hljs-comment">//fmt.Printf(&quot;readyEventNum: %v\n&quot;, readyEventNum)</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != EINTR &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">//log.Printf(&quot;events: %v \n&quot;, events)</span><br><span class="hljs-comment">//log.Printf(&quot;changes: %v \n&quot;, changes)</span><br><span class="hljs-comment">//log.Printf(&quot;readyEventNum: %v\n&quot;, readyEventNum)</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; readyEventNum; i++ &#123;<br>event := events[i]<br><span class="hljs-comment">//log.Printf(&quot;event fd: %v \n&quot;, event.Ident)</span><br>efd := <span class="hljs-type">int</span>(event.Ident)<br><span class="hljs-keyword">if</span> efd == sfd &#123;<br>nfd, _, err := Accept(sfd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;accept event, fd: %v\n&quot;</span>, nfd)<br><span class="hljs-keyword">if</span> err := SetNonblock(nfd, <span class="hljs-literal">true</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br><span class="hljs-comment">//panic(err)</span><br>&#125;<br>changes = <span class="hljs-built_in">append</span>(changes, Kevent_t&#123;<br>Ident:  <span class="hljs-type">uint64</span>(nfd),<br>Filter: EVFILT_READ,<br>Flags:  EV_ADD | EV_ENABLE,<br>Fflags: <span class="hljs-number">0</span>,<br>Data:   <span class="hljs-number">0</span>,<br>Udata:  <span class="hljs-literal">nil</span>,<br>&#125;)<br><span class="hljs-comment">// BUG1 解决步骤3 ：新增下面这个函数调用</span><br>_, err = Kevent(kfd, changes, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-comment">/*if event.Filter == EVFILT_READ*/</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read event\n&quot;</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := Read(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>_, err = Write(efd, b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>Close(efd)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>原因：</p><p>没研究出来</p><p>暂时见解：</p><p>貌似 kqueue 这个函数是 epoll 的 <code>epoll_ctl</code> 和 <code>epoll_wait</code> 的结合体，主要是它的第二个和第三个参数（Go 的系统调用需要的参数和原生 API 略有不同，但影响不大，只是不用提供两个数组的长度而已），第二个参数是<strong>要监听的事件集合</strong>，第三个参数用来<strong>存放已经准备就绪的事件</strong>，所以如果想要添加监听事件，就将第三个参数传 null；如果想获取已经就绪的事件，那么就给第二个参数传 null，具体看开头的 echo server 代码的那几行调用 Kqueue 的注释。看了一些正确的例子，包括官方的 FreeBSD man 文档，基本都是这么写的。</p><p>对比 epoll</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;log&quot;</span><br>   . <span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>   log.SetFlags(log.Lshortfile | log.Ltime)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   sfd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br>   log.Printf(<span class="hljs-string">&quot;listen fd: %v\n&quot;</span>, sfd)<br><br>   <span class="hljs-keyword">if</span> err := Bind(sfd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">8080</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> err := Listen(sfd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   epfd, err := EpollCreate(<span class="hljs-number">10</span>)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> err := EpollCtl(epfd, EPOLL_CTL_ADD, sfd, &amp;EpollEvent&#123;<br>      Events: EPOLLIN,<br>      Fd:     <span class="hljs-type">int32</span>(sfd),<br>      Pad:    <span class="hljs-number">0</span>,<br>   &#125;); err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-built_in">panic</span>(err)<br>   &#125;<br><br>   <span class="hljs-keyword">for</span> &#123;<br>      events := <span class="hljs-built_in">make</span>([]EpollEvent, <span class="hljs-number">20</span>)<br>      n, err := EpollWait(epfd, events, <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         log.Println(err)<br>         <span class="hljs-keyword">continue</span><br>      &#125;<br>      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>         event := events[i]<br>         <span class="hljs-keyword">if</span> event.Fd == <span class="hljs-type">int32</span>(sfd) &#123;<br>            nfd, _, err := Accept(sfd)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> err := EpollCtl(epfd, EPOLL_CTL_ADD, nfd, &amp;EpollEvent&#123;<br>               Events: EPOLLIN,<br>               Fd:     <span class="hljs-type">int32</span>(nfd),<br>               Pad:    <span class="hljs-number">0</span>,<br>            &#125;); err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>            _, err := Read(<span class="hljs-type">int</span>(event.Fd), b)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               Close(<span class="hljs-type">int</span>(event.Fd))<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>            _, err = Write(<span class="hljs-type">int</span>(event.Fd), b)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>               log.Println(err)<br>               Close(<span class="hljs-type">int</span>(event.Fd))<br>               <span class="hljs-keyword">continue</span><br>            &#125;<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>多路复用</tag>
      
      <tag>kqueue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 卷</title>
    <link href="/2022/05/20/k8s-juan/"/>
    <url>/2022/05/20/k8s-juan/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么需要卷"><a href="#为什么需要卷" class="headerlink" title="为什么需要卷"></a>为什么需要卷</h1><p>pod 类似逻辑主机，在逻辑主机中运行的进程共享诸如 CPU、RAM、网络接口等资源。有时候人们会期望进程也能共享磁盘，但是因为 pod 中运行的是一个个容器，而每个容器都有自己独立的文件系统（因为文件系统来自于容器镜像），所以不能共享磁盘。有时候可能存在这样一种需求：<del>pod 中某个容器存储的数据需要持久化，但是因为容器存在挂掉的可能，如果挂掉后会新创建一个 pod 来顶替，但是因为 pod 因为无法共享磁盘，导致无法继承先前 pod 里存储的数据，先前的那部分数据就永久丢失了。</del></p><p>k8s 通过定义 <strong>卷</strong> 这个概念来解决这个问题，<strong>它们不像 pod 这样的顶级资源，而是被定义为了 pod 的一部分</strong>，并和 pod 共享相同的生命周期，也就是说，卷在 pod 启动时创建，在 pod 删除时销毁（书上是这么说的，但是感觉不太准确，不同类型的卷有不同的生命周期，像 emptyDir 就是和 pod 共享生命周期，而 hostPath 则不共享，就算 pod 删除了，这个卷也不会被删除）。</p><h1 id="卷类型"><a href="#卷类型" class="headerlink" title="卷类型"></a>卷类型</h1><h2 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h2><p>顾名思义，这个卷最初是空的，当 Pod 因为某些原因被从节点上删除时，<code>emptyDir</code> 卷中的数据也会被永久删除。运行在 pod 内的应用程序可以写入它需要的任何文件。</p><p>实践：</p><p>yaml 如下：（ ⚠️ 该 yaml 的镜像基于 arm64 架构，如果你的机器是 x86，需要将第一个 -image 更换为 luksa&#x2F;fortune）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-arm64</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span> <span class="hljs-comment"># 使用 name 为 html 的卷（该卷在 yaml 最后定义）</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个 pod 的大致意思是：创建了 2 个容器，一个负责生成随机内容（使用 fortune 随机生成一句谚语）并写入到 &#x2F;var&#x2F;htdocs&#x2F;index.html 文件里，另一个是 nginx 服务，负责将 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html 里的内容显示出来（将第一个容器写入的谚语读取出来），所以这两个容器需要结合使用，一个负责写，另一个负责读，所以需要共用同一个卷来实现。</p><p>为了实现上面的流程，需要创建一个卷，将这个卷分别挂载到两个容器的某个目录下，这样就可以达到共享一个卷的目的，在上面的 yaml 中，将卷挂载到了 fortune 容器的 &#x2F;var&#x2F;htdocs&#x2F; 目录下，然后这个容器会在这个目录下创建一个 index.html 并写入谚语（因为挂载的原因，所以相当在卷中创建了一个 index.html 文件）；同样还会将这个卷挂载到 nginx 容器下的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 目录下，nginx 默认会读取这个目录下的 index.html 作为显示内容，前面提到过，fortune 容器会创建一个 index.html 文件到卷中，所以这个文件刚好就可以作为 nginx 的默认显示内容，值得注意的是，yaml 里还对 nginx 容器设置了 readOnly: true 属性，表示该容器只能从卷中读取，不能写入。</p><p>以上涉及到 linux 挂载（mount）的知识，这个概念感觉有点绕，（我总是把挂载、被挂载搞混），我也是初学掌握的不是很好，所以上面的内容说的比较绕，也可能不正确，用我个人的理解，简单的用几句话概括就是，将卷挂载到了一个容器的 &#x2F;var&#x2F;htdocs 下和另一个容器的 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 容器下，然后这两个路径就相当于共享了，第一个容器在 &#x2F;var&#x2F;htdocs 中创建一个文件，另一个容器可以同样在 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 目录下读取到。</p><p>因为容器的文件系统是隔离的，正常来说两个容器是不能共享目录的，就相当于两台电脑，如果不通过一些特殊手段肯定是不能共享目录的，所以为了解决这个问题，就需要使用上面的 <strong>卷</strong> 来实现。</p><p>接下来就可以使用 <code>kubectl apply -f </code> 进行创建了，为了测试效果，可以使用端口转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br></code></pre></td></tr></table></figure><p>然后使用 curl 就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span><br>Q:How many psychiatrists does it take to change a light bulb?<br>A:Only one, but it takes a long time, and the light bulb has<br>to really want to change.<br></code></pre></td></tr></table></figure><blockquote><p>❓这个 emptyDir 实际路径在哪里？</p></blockquote><p>emptyDir 不仅可以使用常规的硬盘作为存储介质，也可以使用内存作为存储介质（linux 中的 tmpfs 也是类似的东西），只需要在 yaml 中指定 mediun 即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br><span class="hljs-attr">emptyDir:</span><br><span class="hljs-attr">medium:</span> <span class="hljs-string">Memory</span> <span class="hljs-comment"># 存储在内存中</span><br></code></pre></td></tr></table></figure><h2 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h2><p>这里复用 emptyDir 部分的 yaml，只是将 volume 的类型更换为了 hostPath：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fortune</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/fortune-arm64</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">html-generator</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span> <br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/htdocs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">web-server</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">html</span><br>    <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/data</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">Directory</span><br></code></pre></td></tr></table></figure><p>执行上面的 yaml，创建 pod，然后看看 hostPath 卷里的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/index.html</span><br>Stay away from hurricanes for a while.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/index.html</span><br>A vivid and creative mind characterizes you.<br></code></pre></td></tr></table></figure><p>也可以像 emptyDir 中演示的那样，开启端口转发，使用 curl 看看效果，这里就不记录了。</p><p>测试一下 hostPath 类型的卷是否和 pod 共享生命周期：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po fortune</span><br>pod &quot;fortune&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /data/index.html</span><br>Today&#x27;s weirdness is tomorrow&#x27;s reason why.<br>-- Hunter S. Thompson<br></code></pre></td></tr></table></figure><p>pod 被删除了，但是 &#x2F;data 下的内容依然存在，所以 hostPath 卷不与 pod 共享生命周期，属于持久卷。</p><h1 id="持久卷"><a href="#持久卷" class="headerlink" title="持久卷"></a>持久卷</h1><h2 id="持久卷（pv）和持久卷声明（pvc）"><a href="#持久卷（pv）和持久卷声明（pvc）" class="headerlink" title="持久卷（pv）和持久卷声明（pvc）"></a>持久卷（pv）和持久卷声明（pvc）</h2><p>一般来说，开发者不需要知道持久卷存储的类型和地址，如果开发者定义 pod 时需要手动指定存储地址，那么会导致高耦合，解决方法就是计算机的通用解决方法：套一层中间层，pvc 就是这个中间层，开发者只需要将自己的需求（容量需求、访问模式）定义为 pvc 提交给 k8s，k8s 将找到可匹配的持久卷并将其绑定到 pvc。</p><p><strong>PVC 与 PV 是一一对应关系，不能一个 PVC 挂载多个 PV，也不能一个 PV 挂载多个 PVC</strong>。为应用配置存储时，需要声明一个存储需求声明（PVC），而Kubernetes会通过最佳匹配的方式选择一个满足PVC需求的PV，并与之绑定。所以从职责上PVC是应用所需要的存储对象，属于应用作用域。PV是存储平面的存储对象，属于整个存储域。</p><p>PVC只有绑定了PV之后才能被Pod使用，而PVC绑定PV的过程即是消费PV的过程，这个过程是有一定规则的，以下规则都满足的PV才能被PVC绑定：</p><ul><li>VolumeMode：被消费PV的VolumeMode需要和PVC一致。</li><li>AccessMode：被消费PV的AccessMode需要和PVC一致。</li><li>StorageClassName：如果PVC定义了此参数，PV必须有相关的参数定义才能进行绑定。</li><li>LabelSelector：通过标签（<strong>labels</strong>）匹配的方式从PV列表中选择合适的PV绑定。</li><li>Size：被消费PV的<strong>capacity</strong>必须大于或者等于PVC的存储容量需求才能被绑定。</li></ul><h2 id="在-k3s-上实践-pv-和-pvc"><a href="#在-k3s-上实践-pv-和-pvc" class="headerlink" title="在 k3s 上实践 pv 和 pvc"></a>在 k3s 上实践 pv 和 pvc</h2><p>pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">local-path-pvc</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">local-path</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">50Mi</span><br></code></pre></td></tr></table></figure><p>创建并查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f pvc.yaml</span><br>persistentvolumeclaim/local-path-pvc created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME             STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>local-path-pvc   Pending                                      local-path     102s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pv</span><br>No resources found<br></code></pre></td></tr></table></figure><p>发现 pvc 的状态是 pending，查看 describe：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Events:<br>  Type    Reason                Age                 From                         Message<br>  ----    ------                ----                ----                         -------<br>  Normal  WaitForFirstConsumer  11s (x9 over 2m3s)  persistentvolume-controller  waiting for first consumer to be created before binding<br></code></pre></td></tr></table></figure><p>意思是 pvc 创建好了，等待某个消费者来绑定它，所以处于 pending 状态，接下来创建一个 pod 作为消费者，来绑定这个 pvc：</p><p>pvc_consumer_pod.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:stable-alpine</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">local-path-pvc</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f pvc_consumer_pod.yaml</span><br>pod/volume-test created<br></code></pre></td></tr></table></figure><p>此时再查看 pvc 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pvc</span><br>NAME             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>local-path-pvc   Bound    pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4   50Mi       RWO            local-path     5m41s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pv</span><br>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                    STORAGECLASS   REASON   AGE<br>pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4   50Mi       RWO            Delete           Bound    default/local-path-pvc   local-path              41m<br></code></pre></td></tr></table></figure><p>发现 pvc 已经处于 Bound 状态了，此外 pv 也已经创建好了</p><p>接下来就可以测试一下效果了，首先需要先进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">k3s kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>redis         1/1     Running   0          9h<br>volume-test   1/1     Running   0          5m49s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it volume-test -- /bin/sh</span><br>/ # ls<br>bin                   docker-entrypoint.sh  media                 root                  sys<br>data                  etc                   mnt                   run                   tmp<br>dev                   home                  opt                   sbin                  usr<br>docker-entrypoint.d   lib                   proc                  srv                   var<br></code></pre></td></tr></table></figure><p>因为 pvc_consumer_pod.yaml 中，我们定义的挂载目录的 &#x2F;data，所以我们要 cd 到容器的 &#x2F;data 目录，然后向这个目录中写入一些内容，再看看其 pvc 绑定的 pv 是否会同步拥有该内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此时接着上面的 exec，也就是在容器内部执行这些命令</span><br>/ <span class="hljs-comment"># cd data</span><br>/data <span class="hljs-comment"># echo &quot;hello, local PV&quot; &gt; pvc-test</span><br>/data <span class="hljs-comment"># cat pvc-test</span><br>hello, <span class="hljs-built_in">local</span> PV<br></code></pre></td></tr></table></figure><p>在 local PV 查看是否同样有此文件，在 k3s 中，pv 存储在 &#x2F;var&#x2F;lib&#x2F;rancher&#x2F;k3s&#x2F;storage 目录下，k3s 的 pv 相关内容可以 <a href="https://www.jianshu.com/p/dd186961e398">参考这篇</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">退出容器内部，回到主机</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> /var/lib/rancher/k3s/storage/</span><br>pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4_default_local-path-pvc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /var/lib/rancher/k3s/storage/pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4_default_local-path-pvc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span></span><br>pvc-test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在容器内部写入的内容，同步到了这里</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> pvc-test</span><br>hello, local PV<br></code></pre></td></tr></table></figure><p>结果说明测试成功</p><h2 id="如果两个-pod-绑定到同一个-pvc-上会怎样？"><a href="#如果两个-pod-绑定到同一个-pvc-上会怎样？" class="headerlink" title="如果两个 pod 绑定到同一个 pvc 上会怎样？"></a>如果两个 pod 绑定到同一个 pvc 上会怎样？</h2><p>继续沿用之前的 pvc_consumer_pod.yaml，做一些修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> pvc_consumer_pod.yaml pvc_consumer_pod1.yaml</span><br></code></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test1</span> <span class="hljs-comment"># 此处修改</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volume-test1</span> <span class="hljs-comment"># 此处修改</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:stable-alpine</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">volv</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">local-path-pvc</span><br></code></pre></td></tr></table></figure><p>创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f pvc_consumer_pod1.yaml</span><br>pod/volume-test1 created<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME           READY   STATUS    RESTARTS   AGE<br>redis          1/1     Running   0          10h<br>volume-test    1/1     Running   0          25m<br>volume-test1   1/1     Running   0          32s<br></code></pre></td></tr></table></figure><p>发现创建成功了</p><p>还是按照之前的流程，先 exec 进容器看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it volume-test1 -- /bin/sh</span><br>/ # ls<br>bin                   docker-entrypoint.sh  media                 root                  sys<br>data                  etc                   mnt                   run                   tmp<br>dev                   home                  opt                   sbin                  usr<br>docker-entrypoint.d   lib                   proc                  srv                   var<br>/ # cd data/<br>/data # ls<br>pvc-test<br>/data # cat pvc-test<br>hello, local PV<br></code></pre></td></tr></table></figure><p>发现 &#x2F;data 下已经有内容了，而且就是之前 volume-test 这个 pod 写入的内容，尝试向这个文件里新写入一部分内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/data # echo &quot;hello again&quot; &gt;&gt; pvc-test<br>/data # cat pvc-test<br>hello, local PV<br>hello again<br></code></pre></td></tr></table></figure><p>查看 local PV：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /var/lib/rancher/k3s/storage/pvc-0e7db0b6-fa32-4c2e-ac0c-53a354ead8a4_default_local-path-pvc/pvc-test</span><br>hello, local PV<br>hello again<br></code></pre></td></tr></table></figure><p>查看第一个容器 volume-test :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it volume-test -- /bin/sh</span><br>/ # cat /data/pvc-test<br>hello, local PV<br>hello again<br></code></pre></td></tr></table></figure><p>发现二者的内容都同步了</p><p>如此看来，多个 pod 可以绑定同一个 pvc 来达到共享文件的效果，pv 和 pvc 是一对一绑定的，但是 pod 和 pvc 是可以多对一绑定的。</p><h1 id="删除-pvc"><a href="#删除-pvc" class="headerlink" title="删除 pvc"></a>删除 pvc</h1>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 mac 上制作 windows10 启动盘，亲测可用</title>
    <link href="/2022/05/17/mac-shang-zhi-zuo-windows/"/>
    <url>/2022/05/17/mac-shang-zhi-zuo-windows/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://chinese.freecodecamp.org/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/">https://chinese.freecodecamp.org/news/how-make-a-windows-10-usb-using-your-mac-build-a-bootable-iso-from-your-macs-terminal/</a></p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li>windows iso 文件</li><li>一个大小至少 8G 的 U 盘</li><li>mac 上安装好 homebrew</li></ol><h1 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h1><p>查看 U 盘的名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">diskutil list</span><br></code></pre></td></tr></table></figure><p>该命令会列出电脑上所有的磁盘设备，可以通过大小来确认哪个是你插入的 U 盘，比如我的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/dev/disk8 (external, physical):<br><span class="hljs-meta prompt_">   #</span><span class="language-bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span><br>   0:     FDisk_partition_scheme                        *31.0 GB    disk8<br>   1:               Windows_NTFS WINDOWS10               31.0 GB    disk8s1<br></code></pre></td></tr></table></figure><p>那么 disk8 就是我的 U 盘的名称了。</p><h1 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h1><p>格式化 U 盘：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">diskutil eraseDisk FAT32 <span class="hljs-string">&quot;WINDOWS10&quot;</span> MBR disk8</span><br></code></pre></td></tr></table></figure><p>这里的 disk8 要替换成你的 u 盘名称，”WINDOWS10” 是格式化后对硬盘的重命名，可以指定为任意值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Started erase on disk8<br>Unmounting disk<br>Creating the partition map<br>Waiting for partitions to activate<br>Formatting disk8s1 as MS-DOS (FAT32) with name WINDOWS10<br>512 bytes per physical sector<br>/dev/rdisk8s1: 60507232 sectors in 1890851 FAT32 clusters (16384 bytes/cluster)<br>bps=512 spc=32 res=32 nft=2 mid=0xf8 spt=32 hds=255 hid=2048 drv=0x80 bsec=60536832 bspf=14773 rdcl=2 infs=1 bkbs=6<br>Mounting disk<br>Finished erase on disk8<br></code></pre></td></tr></table></figure><p>提示以上信息说明格式化成功。</p><h1 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h1><p>挂载 windows iso 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hdiutil mount /Volumes/c/Win10_2004_Chinese\(Simplified\)_x64.iso</span><br>hdiutil: mount failed - 资源暂时不可用<br></code></pre></td></tr></table></figure><p>mout 后面是你的 iso 所在路径</p><p>也可以双击 iso 文件来进行挂载，因为我之前已经双击挂载过了，所以这里提示“资源暂时不可用”</p><p>挂载完成后，finder 的位置会显示一个名为 <code>CCCOMA_X64FRE_ZH-CN_DV9</code> 的文件（也可能是 <code>CCCOMA_X64FRE_EN-US_DV9</code> ，取决于 iso 文件），也可以在 &#x2F;Volumes 目录下找到，比如我的是 &#x2F;Volumes&#x2F;CCCOMA_X64FRE_ZH-CN_DV9（可以通过 <code>ls /Volumes </code> 查看），这个路径后面会用到</p><h1 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h1><p>复制文件到 u 盘，Windows 10 ISO 中的一个文件 <code>install.wim</code> 现在太大而无法复制到 FAT-32 格式的 USB 驱动器，需要单独复制它。</p><p>首先运行此命令以复制除该文件之外的所有内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rsync -vha --exclude=sources/install.wim /Volumes/CCCOMA_X64FRE_ZH-CN_DV9/* /Volumes/WINDOWS10</span><br></code></pre></td></tr></table></figure><p>（这里将  &#x2F;Volumes&#x2F;CCCOMA_X64FRE_ZH-CN_DV9&#x2F; 替换为你的目录，参考步骤 3，&#x2F;Volumes&#x2F;WINDOWS10 替换为你的 u 盘名，参考步骤 2）</p><p>然后继续创建你要将文件写入的目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /Volumes/WINDOWS10/sources</span><br></code></pre></td></tr></table></figure><p>如果提示 <code>File exists</code>  说明该文件夹已存在，可以继续执行下面的步骤。</p><p>使用 Homebrew 使用此终端命令安装名为 wimlib 的工具，该工具用于分割 install.wim 为 2 个小于 4G 的文件，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install wimlib</span><br></code></pre></td></tr></table></figure><p>然后运行这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wimlib-imagex <span class="hljs-built_in">split</span> /Volumes/CCCOMA_X64FRE_EN-US_DV9/sources/install.wim /Volumes/WIN10/sources/install.swm 3800</span><br></code></pre></td></tr></table></figure><p>同样的，需要将 <code>/Volumes/CCCOMA_X64FRE_EN-US_DV9/</code> 这部分替换为你的路径，以及 <code>/Volumes/WIN10/</code> 这部分。之后需要等待一会，直到提示以下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Splitting WIM: 4193 MiB of 4193 MiB (100%) written, part 2 of 2<br>Finished splitting &quot;/Volumes/CCCOMA_X64FRE_ZH-CN_DV9/sources/install.wim&quot; # 制作完成<br></code></pre></td></tr></table></figure><h1 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h1><p>至此启动盘已经制作完成，弹出 u 盘，插入到要安装 windows 的电脑，并使用 u 盘启动便可以看到 windows 的安装界面了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 mac 上制作 windows 启动盘还是有点小麻烦的，不像 windows 上直接使用软碟通那么简单方便，网上也有不少教程是过时错误的，比如使用 balenaEtcher ，这个软件自己都会弹出警告，无法刻录 windows，还有使用命令行的，要将 u 盘格式化为 MS-DOS 格式，因为 MS-DOS 格式无法一次写入 4G 以上的文件，会提示 <code>File too large</code> 错误，如果格式化为 ExFAT，虽然可以成功写入，但是 bios 无法识别出 U 盘。其实本文使用的方法也是命令行，只是对 4G 文件进行了特殊处理，总的来看这个方法简单有效，感谢这位大佬的教程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>实用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux iptables</title>
    <link href="/2022/05/16/iptables/"/>
    <url>/2022/05/16/iptables/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文档状态：Draft</p></blockquote><hr><h1 id="链，表和规则"><a href="#链，表和规则" class="headerlink" title="链，表和规则"></a>链，表和规则</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>顾名思义，规则就是针对网络包的不同 <strong>行为</strong>，做出对应的 <strong>处理操作</strong>，比如如果我收到的网络包的 IP 是 xx.xx.xx.xx，那么我就将其丢弃；如果我收到的包的端口是 8080，我就将其转发给 XXX 之类的，也可以说，<strong>规则就是匹配条件 + 处理操作</strong>。</p><p><strong>匹配条件</strong></p><p><strong>示例</strong></p><ul><li><p>阻止特定的 ip 地址</p><p>在我们继续进行其他示例之前，如果您想阻止特定的 ip 地址，您应该首先执行如下所示的操作。将下面示例中的“xxxx”更改为您要阻止的特定IP地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">BLOCK_THIS_IP=&quot;xxxx&quot;<br>iptables -A INPUT -s &quot;$BLOCK_THIS_IP&quot; -j DROP<br></code></pre></td></tr></table></figure></li></ul><p>相互之间的关系如下：</p><p>一条链上可以有多条规则。</p><p>一张表里可以存多条相同种类的规则</p><h1 id="规则相关命令"><a href="#规则相关命令" class="headerlink" title="规则相关命令"></a>规则相关命令</h1><h2 id="查看规则"><a href="#查看规则" class="headerlink" title="查看规则"></a>查看规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 filter 表的所有规则，-t 后面跟表名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -L</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 raw 表的所有规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t raw -L</span>    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 filter 表（-t 缺省时，默认为 filter 表）的 INPUT 链上的所有规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -L INPUT</span>     <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加 -v 可以输出更详细的信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -vL INPUT</span>    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加 -n 会直接输出 IP 地址，不加的话会继续转换，比如 0.0.0.0 会转换为 anywhere</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -nL INPUT</span>    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为输出的规则列表添加序号</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables --line -L INPUT</span> <br></code></pre></td></tr></table></figure><h2 id="操作规则"><a href="#操作规则" class="headerlink" title="操作规则"></a>操作规则</h2><h3 id="清空规则"><a href="#清空规则" class="headerlink" title="清空规则"></a>清空规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清空 filter 表 INPUT 链中的规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F INPUT</span><br></code></pre></td></tr></table></figure><h3 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -I INPUT -s 192.168.64.1 -j DROP</span><br></code></pre></td></tr></table></figure><p>上面的命令表示：在 filter 表的 INPUT 链中添加一条规则：丢弃（DROP）源地址为 192.168.64.1 的报文</p><p>每个参数的意思：</p><p>-t：指定要操作的表，此处指定了操作 filter 表，不使用 -t 选项指定表时，默认为操作 filter 表</p><p>-I：指明将 ”规则” 插入至哪个链中，即添加规则</p><p>-s：指明“匹配条件”中的”源地址”，如果报文的源地址属于-s对应的地址，那么报文则满足匹配条件</p><p>-j：指明当”匹配条件”被满足时，所对应的动作</p><p>测试：</p><p>上面添加的 192.168.64.1是我的宿主机 ip，现在用宿主机来访问一下这台设置了规则的虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ping 192.168.64.5 <span class="hljs-comment"># ping 虚拟机</span></span><br>PING 192.168.64.5 (192.168.64.5): 56 data bytes<br>Request timeout for icmp_seq 0<br>Request timeout for icmp_seq 1<br>Request timeout for icmp_seq 2<br></code></pre></td></tr></table></figure><p>发现已经无法访问了。（之后发现 ssh 给断了，虚拟机也进不去了，用的是 multipass😅）</p><p>添加规则的同时可以指定其插入的位置，不同的位置会影响规则的执行。具体的例子可以参考 <a href="https://www.zsythink.net/archives/1517%EF%BC%8C%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%E6%98%AF%EF%BC%9A%E5%B7%B2%E7%BB%8F%E8%AE%BE%E7%BD%AE%E4%BA%86%E4%B8%80%E6%9D%A1">https://www.zsythink.net/archives/1517，大致流程是：已经设置了一条</a> drop 规则，如果追加一条相同 ip，但是 accept 的规则，发现依然无法 ping 通，因为 drop 在前 accept 在后；但是如果将 accept 插入到头部，那么 INPUT 链会先执行 accept 规则，数据包就会被放行，因为报文已经被放行了，所以，即使第二条 drop 规则能够匹配到刚才”放行”的报文，也没有机会再对刚才的报文进行丢弃操作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-A 追加一条规则（append），也就是添加到末尾</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -A INPUT -s 192.168.64.1 -j ACCEPT</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-I 添加到头部</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -I INPUT -s 192.168.64.1 -j ACCEPT</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">插入到规则的下标 2 处</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -I INPUT 2 -s 192.168.64.1 -j ACCEPT</span><br></code></pre></td></tr></table></figure><h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p><strong>根据规则编号删除</strong>（指定 –line ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -D INPUT 3</span><br></code></pre></td></tr></table></figure><p>上面的命令会删除 filter 表的 INPUT 链的第 3 条规则</p><p><strong>根据匹配条件删除</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -D INPUT -s 192.168.64.1 -j ACCEPT</span><br></code></pre></td></tr></table></figure><p>上述命令表示删除 INPUT 链中源地址为 192.168.64.1，动作为 ACCEPT 的规则</p><p><strong>清空链上的规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清空 filter 表 INPUT 链中的规则</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F INPUT</span><br></code></pre></td></tr></table></figure><p><strong>清空表的所有规则</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不指定链名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F</span><br></code></pre></td></tr></table></figure><h1 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h1><p>自定义链用于对规则的管理，这里我有一个疑问，iptables 的 <strong>表</strong> 已经是对规则的一种分类管理了，为什么还需要自定义链呢？我暂时的理解是，虽然表已经进行了分类，但是粒度还是比较粗，比如 filter 表只是负责过滤功能，但是过滤功能可能还需要进行进一步分类，比如有针对 HTTP 的过滤规则，有针对 SSH 的过滤规则，</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>实验的两台机器 IP 为：192.168.1.110 和 192.168.1.103，在 110 上设置一条自定义链，规则是阻止 103 这台机器来访问 8080 端口，8080 运行了一个 web 程序，访问会返回 “Hello”</p><p>首先创建一条名为 IN_WEB 的自定义链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -N IN_WEB</span><br></code></pre></td></tr></table></figure><p>为该链设置规则，对 <strong>源地址</strong> 为  192.168.1.103 的连接进行 <strong>REJECT</strong> （拒绝）处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter -I IN_WEB -s 192.168.1.103 -j REJECT</span><br></code></pre></td></tr></table></figure><p>查看 filter 中的规则，使用 IN_WEB 进行过滤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter --line -nvL IN_WEB</span><br>Chain IN_WEB (0 references)<br>num   pkts bytes target     prot opt in     out     source               destination<br>1        0     0 REJECT     all  --  *      *       192.168.1.103        0.0.0.0/0            reject-with icmp-port-unreachable<br></code></pre></td></tr></table></figure><p>自定义链不能直接使用，需要将其添加到一条 <strong>默认链</strong> 中， 将该链添加到 INPUT 链中，这代表该条链用于接收到数据时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -I INPUT -p tcp --dport 8080 -j IN_WEB</span><br></code></pre></td></tr></table></figure><p>查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter --line -nvL IN_WEB</span><br>Chain IN_WEB (1 references)<br> pkts bytes target     prot opt in     out     source               destination<br>    0     0 REJECT     all  --  *      *       192.168.1.103        0.0.0.0/0            reject-with icmp-port-unreachable<br></code></pre></td></tr></table></figure><p>此时使用 103 的机器访问 110 的 8080 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.1.110:8080</span><br>curl: (7) Failed to connect to 192.168.1.110 port 8080 after 37 ms: Connection refused<br></code></pre></td></tr></table></figure><p>报错 “Connection refused”（连接被拒绝），这个错误见得也比较多了，当访问的端口没有被程序监听时，也会报这个错误。此时说明拦截规则已经成功。</p><p>110 的 9090 端口上也运行了一个 web 程序，访问一下看看是不是只拦截了 8080 端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.1.110:9090</span><br><span class="hljs-meta prompt_">Hello%</span><br></code></pre></td></tr></table></figure><p>9090 可以正常访问，说明拦截规则成功。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除自定义链需要满足两个条件</p><p>1、自定义链没有被引用</p><p>2、自定义链中没有任何规则</p><p>自定义链被放置在 INPUT 上，首先查看 INPUT 的所有规则，并删除属于自定义链的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -nvL INPUT <span class="hljs-comment"># 查看 INPUT 链上的所有规则</span></span><br>Chain INPUT (policy ACCEPT 4397 packets, 972K bytes)<br> pkts bytes target     prot opt in     out     source               destination<br>    0     0 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80<br> 7753 1508K KUBE-ROUTER-INPUT  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kube-router netpol - 4IA2OSFRMVNDXBVV */<br>    0     0 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80<br>    1    64 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:5555<br>    <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -D INPUT 7 <span class="hljs-comment"># 删除规则，数字是上面列表的序号，根据自己的实际情况来指定</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables --line-number -vL INPUT <span class="hljs-comment"># 使用 --line-numbers 可以显示规则的编号，这样删除起来更方便</span></span><br>Chain INPUT (policy ACCEPT 2702 packets, 895K bytes)<br>num   pkts bytes target     prot opt in     out     source               destination<br>1     5865 1470K KUBE-ROUTER-INPUT  all  --  any    any     anywhere             anywhere             /* kube-router netpol - 4IA2OSFRMVNDXBVV */<br>2     2702  895K KUBE-FIREWALL  all  --  any    any     anywhere             anywhere<br>3     2702  895K KUBE-NODEPORTS  all  --  any    any     anywhere             anywhere             /* kubernetes health check service ports */<br>4        0     0 KUBE-EXTERNAL-SERVICES  all  --  any    any     anywhere             anywhere             ctstate NEW /* kubernetes externally-visible service portals */<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -F IN_WEB <span class="hljs-comment"># 清空 filter 表上的 IN_WEB 链上的所有规则（不指定 -t 时默认为 filter 表）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -X IN_WEB <span class="hljs-comment"># 删除链</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t filter --line -nvL IN_WEB <span class="hljs-comment"># 再次查看该链，发现已经无法输出信息了，说明删除成功</span></span><br>iptables v1.8.7 (nf_tables): chain `IN_WEB&#x27; in table `filter&#x27; is incompatible, use &#x27;nft&#x27; tool.<br></code></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><a href="https://vflong.github.io/sre/network/2020/02/23/turning-iptables-into-a-tcp-load-balancer.html">https://vflong.github.io/sre/network/2020/02/23/turning-iptables-into-a-tcp-load-balancer.html</a></p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="DNT-转发"><a href="#DNT-转发" class="headerlink" title="DNT 转发"></a>DNT 转发</h2><p>流程：有两台机器 192.168.64.4 （简称 4）和 192.168.64.1（简称 1），4 上的 8080 和 9090 端口运行了两个 tcp 程序，连接到 8080 时会返回消息： ”8080“，连接到 9090 时会返回消息 ”9090“，这里通过 iptables 设置 nat 转发，将访问 8080 的连接转发到 9090，也就是 DNAT（D 代表 dst，目标），修改报文的目标地址。</p><p>添加规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t nat -A PREROUTING -p tcp -d 192.168.64.4 --dport 8080 -j DNAT --to 192.168.64.4:9090</span><br></code></pre></td></tr></table></figure><p>在 nat 表的 PREROUTING 链中添加一条规则，将目标地址为 192.168.64.4，协议为 tcp 的请求转发（DNAT）到 192.168.64.4 （本机）的 9090 端口</p><p>查看规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">iptables -t nat -nL PREROUTING</span><br>DNAT       tcp  --  0.0.0.0/0            192.168.64.4         tcp dpt:8080 to:192.168.64.4:9090<br></code></pre></td></tr></table></figure><p>在 1 上执行 nc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nc 192.168.64.4 8080</span><br>9090<br></code></pre></td></tr></table></figure><p>访问的是 8080 端口，返回的消息是 9090，说明转发成功。</p><p>这两个程序还会记录访问的 IP 地址，查看日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> 8080</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> 9090</span><br>2022/05/19 15:41:44 192.168.64.1:63310<br></code></pre></td></tr></table></figure><p>8080 的日志为空，说明该请求被 iptables <strong>拦截</strong> 后转发给了 9090</p><p>附代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net&quot;</span><br>        <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br>        assert(err)<br><br>        <span class="hljs-keyword">for</span> &#123;<br>                conn, err := l.Accept()<br>                assert(err)<br>                log.Println(conn.RemoteAddr())<br>                conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;8080&quot;</span>))<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;net&quot;</span><br>        <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:9090&quot;</span>)<br>        assert(err)<br><br>        <span class="hljs-keyword">for</span> &#123;<br>                conn, err := l.Accept()<br>                assert(err)<br>                log.Println(conn.RemoteAddr())<br>                conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;9090&quot;</span>))<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(err)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 nohup 部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build tcp_8080.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build tcp_9090.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> ./tcp_8080 &gt; 8080 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">nohup</span> ./tcp_9090 &gt; 9090 &amp;</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables/page/2">https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables/page/2</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一段莫名阻塞的 reflect 代码</title>
    <link href="/2022/05/13/block-code/"/>
    <url>/2022/05/13/block-code/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;<br>Do()<br>&#125;<br><br><span class="hljs-keyword">type</span> S <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *S)</span></span> Do() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EnforcePtr</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.TypeOf(obj)<br>  fmt.Println(v)<br><span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(v.Kind())<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i I<br>EnforcePtr(i)<br><br><span class="hljs-keyword">var</span> ii I = <span class="hljs-built_in">new</span>(S)<br>EnforcePtr(ii)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码运行后会阻塞，阻塞在 <code>fmt.Println(v.Kind()) </code> 这一行，不太清楚原因，暂时作为记录</p><p>ps：阻塞后 shell 窗口无法通过 ctrl+c 强制结束，需要通过下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep &lt;go file name&gt; | grep -v grep | grep run | awk &#123;&#x27;print $2&#x27;&#125; | xargs kill<br></code></pre></td></tr></table></figure><p>只需要将 <code>EnforcePtr</code> 改为如下形式即可正常工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EnforcePtr</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    v := reflect.TypeOf(obj)<br>    fmt.Println(v)<br>    <span class="hljs-keyword">if</span> v == <span class="hljs-literal">nil</span> &#123;<br>        typ := reflect.TypeOf(&amp;v).Elem()<br>        fmt.Println(typ.Kind())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>issue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s Deployment</title>
    <link href="/2022/05/13/k8s-deployment/"/>
    <url>/2022/05/13/k8s-deployment/</url>
    
    <content type="html"><![CDATA[<p><strong>deplopyment</strong> 用于 pod 的更新相关操作。</p><h1 id="如何更新-pod"><a href="#如何更新-pod" class="headerlink" title="如何更新 pod"></a>如何更新 pod</h1><p>更新是一个非常常见的场景，比如：当前 pod 运行的是某个 v1 版本的镜像，一个月后该镜像发布了 v2 版本，此时想将所有的 pod 更新到 v2 版本，该怎么做呢？</p><p>比较容易想到的以下几种方式：</p><h2 id="先删除所有旧版本的-pod，再创建新版本的-pod"><a href="#先删除所有旧版本的-pod，再创建新版本的-pod" class="headerlink" title="先删除所有旧版本的 pod，再创建新版本的 pod"></a><strong>先删除所有旧版本的 pod，再创建新版本的 pod</strong></h2><p>实践如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-v1</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v1</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>创建一个基于 luksa&#x2F;kubia:v1 的镜像的 pod，同时创建一个 service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>kubia-v1-td826   1/1     Running   0          4m16s<br>kubia-v1-k8hz4   1/1     Running   0          4m16s<br>kubia-v1-7kpmg   1/1     Running   0          4m16s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME       DESIRED   CURRENT   READY   AGE<br>kubia-v1   3         3         3       5m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP   37h<br>kubia        ClusterIP   10.43.191.168   &lt;none&gt;        80/TCP    5m3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl kubia</span><br>This is v1 running in pod kubia-v1-7kpmg<br></code></pre></td></tr></table></figure><p>测试访问，输出表示当前运行的是 v1 版本</p><p>现在来进行升级操作，将 <code>luksa/kubia:v1</code> 升级为 <code>luksa/kubia:v2</code>。</p><p>修改 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v2</span><br>      <br></code></pre></td></tr></table></figure><p>执行 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-rc-and-service-v1.yaml</span><br>replicationcontroller/kubia-v1 configured<br>service/kubia unchanged<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v1 running in pod kubia-v1-7kpmg<br></code></pre></td></tr></table></figure><p>发现输出的还是 v1，可能是因为 rc 已经有 3 个 pod 了，修改 image 不会令其删除旧的并创建新的，那就只好手动删除旧 pod 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete po -l app=kubia</span><br>pod &quot;kubia-v1-td826&quot; deleted<br>pod &quot;kubia-v1-k8hz4&quot; deleted<br>pod &quot;kubia-v1-7kpmg&quot; deleted<br></code></pre></td></tr></table></figure><p>此时删除了所有 app&#x3D;kubia 的 pod（在我的机器上测试时，这个删除操作阻塞了将近 10s），rc 检测到其管理的 pod 数量不足所需的数量 3，那么就会新创建 3 个 pod，因为之前改掉了创建 template 中的镜像为 v2，所以现在 rc 创建出来的都是新版本的 pod 了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>kubia-v1-b5lkr   1/1     Running   0          37s<br>kubia-v1-tq7nh   1/1     Running   0          37s<br>kubia-v1-w6r6t   1/1     Running   0          37s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v2 running in pod kubia-v1-w6r6t<br></code></pre></td></tr></table></figure><p>经过上面的一系列操作，终于完成了 pod 的升级，这种方式有一个问题：删除 pod 后到 rc 创建完成这段时间，是没有 pod 能够提供服务的，这就会导致程序在一段时间内不可用，这对于一些应用是无法接收的。</p><h2 id="先创建新版本的-pod，再删除所有旧版本的-pod"><a href="#先创建新版本的-pod，再删除所有旧版本的-pod" class="headerlink" title="先创建新版本的 pod，再删除所有旧版本的 pod"></a><strong>先创建新版本的 pod，再删除所有旧版本的 pod</strong></h2><p>先将镜像退回至 v1 版本，采用和上面相同的方式，这里就不贴具体操作了。</p><p>复制一份之前的 yaml，在该基础上进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> kubia-rc-and-service-v1.yaml kubia-rc-and-service-v2.yaml</span><br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-v2</span> <span class="hljs-comment"># 修改</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia-v2</span> <span class="hljs-comment"># 修改</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v2</span> <span class="hljs-comment"># 修改</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia-v2</span> <span class="hljs-comment"># 修改</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>修改之处已经标出，注意这里还更新了 service 的选择器，让其为 app&#x3D;kubia-v2 的 pod 提供对外服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-rc-and-service-v2.yaml</span><br>replicationcontroller/kubia-v2 created<br>service/kubia configured<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>No resources found in default namespace.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME       DESIRED   CURRENT   READY   AGE<br>kubia-v1   3         3         3       68m<br>kubia-v2   3         3         3       18s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>kubia-v1-7pxtm   1/1     Running   0          11m<br>kubia-v1-zt5pg   1/1     Running   0          11m<br>kubia-v1-gnssp   1/1     Running   0          11m<br>kubia-v2-46w9g   1/1     Running   0          20s<br>kubia-v2-66wqr   1/1     Running   0          20s<br>kubia-v2-bvjqc   1/1     Running   0          20s<br></code></pre></td></tr></table></figure><p>此时访问 service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v2 running in pod kubia-v2-dj8cf<br></code></pre></td></tr></table></figure><p>发现已经切换到了 v2</p><p>后续再删除 v1 的 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME       DESIRED   CURRENT   READY   AGE<br>kubia-v1   3         3         3       76m<br>kubia-v2   3         3         3       98s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rc kubia-v1</span><br>replicationcontroller &quot;kubia-v1&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS        RESTARTS   AGE<br>kubia-v2-dj8cf   1/1     Running       0          2m9s<br>kubia-v2-4q5tv   1/1     Running       0          2m9s<br>kubia-v2-rbbfd   1/1     Running       0          2m9s<br>kubia-v1-gnssp   1/1     Terminating   0          19m<br>kubia-v1-7pxtm   1/1     Terminating   0          19m<br>kubia-v1-zt5pg   1/1     Terminating   0          19m<br></code></pre></td></tr></table></figure><p>等待一会，这些 Terminating 状态的 pod 就会消失了。</p><p>使用这种方式可以做到不停机更新，但是需要更多的硬件资源，因为在短时间内会同时运行 2 倍的 pod。</p><h2 id="交替执行，删一个旧的，创建一个新的（滚动更新）"><a href="#交替执行，删一个旧的，创建一个新的（滚动更新）" class="headerlink" title="交替执行，删一个旧的，创建一个新的（滚动更新）"></a>交替执行，删一个旧的，创建一个新的（滚动更新）</h2><p>这种方式比较繁琐，就不演示了，大致的思路是：和 <strong>先创建新版本的 pod，再删除所有旧版本的 pod</strong> 中的做法一样，再创建一个用于管理 v2 的 rc（这里称为 rc-v2，之前的称为 rc-v1），但是 replicas 置为 0，此时有两个 rc：rc-v1，replicas 为 3，rc-v2，replicas 为 0，然后开始交替执行，rc-v1 缩容为 2，rc-v2 扩容到 1，v1 缩容到 1，v2 扩容到 2，以此类推，来完成升级。</p><p>这种方式避免了前面两种同时创建、同时删除的缺点， 但是其也有自己的缺点：较为繁琐，且容易出错，一套流程下来要敲非常多的命令。</p><p>好在强大的 k8s 提供了指令来完成 pod 的更新操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2</span><br></code></pre></td></tr></table></figure><blockquote><p>⚠️ 该命令已经被删除 ：error: unknown command “rolling-update” for “kubectl”</p><p><a href="https://stackoverflow.com/questions/65303683/why-kubectl-removed-command-rolling-update">https://stackoverflow.com/questions/65303683/why-kubectl-removed-command-rolling-update</a></p><p><a href="https://github.com/kubernetes/kubectl/commit/d3af7e08624bfa7c2f52714b47cfe96a52d15fc0">https://github.com/kubernetes/kubectl/commit/d3af7e08624bfa7c2f52714b47cfe96a52d15fc0</a></p><p>大致原因是：该命令是在客户端执行的，而不是在 k8s 内部执行，相比之下客户端更容易遇到一些网络中断、终端异常退出等错误，这会导致 pod 和 rc 处于中间状态</p></blockquote><h1 id="使用-deployment-进行更新"><a href="#使用-deployment-进行更新" class="headerlink" title="使用 deployment 进行更新"></a>使用 deployment 进行更新</h1><p>使用如下 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v1</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br><br></code></pre></td></tr></table></figure><p>创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f deployment.yaml --record</span><br>Flag --record has been deprecated, --record will be removed in the future<br>deployment.apps/kubia created<br></code></pre></td></tr></table></figure><p>书上着重强调了：<code>确保在创建时使用了 --record 选项。 这个选项会记录历史版本号， 在之后的操作中非常有用</code>。然而这里直接提示该选项已被废弃，难道已经默认记录版本号了吗？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                     READY   STATUS    RESTARTS   AGE<br>kubia-5f6cdb7bf7-4pn9b   1/1     Running   0          7m26s<br>kubia-5f6cdb7bf7-kt8gp   1/1     Running   0          7m26s<br>kubia-5f6cdb7bf7-f6w5g   1/1     Running   0          7m26s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP   2d<br>kubia        ClusterIP   10.43.191.168   &lt;none&gt;        80/TCP    11h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.191.168</span><br>This is v1 running in pod kubia-5f6cdb7bf7-f6w5g<br></code></pre></td></tr></table></figure><p>开始执行滚动升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl patch deployment kubia -p <span class="hljs-string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;minReadySeconds&quot;: 10&#125;&#125;&#x27;</span></span><br>deployment.apps/kubia patched<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment kubia nodejs=luksa/kubia:v2 <span class="hljs-comment"># 更新镜像</span></span><br></code></pre></td></tr></table></figure><p>这里通过 patch 为 这个 deployment 添加了一条 minReadySeconds: 10 的属性，这个属性的作用是：指定新创建的 pod 至少要成功运行多久之后，才能将其视为可用，在后面会详细说明这个属性。</p><p>使用 set image 命令来进行更新，其中 nodejs 是 template.sepc.containers.name 指定的。之后更新就开始了，可以开一个新的 shell 观察升级过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v1 running in pod kubia-5f6cdb7bf7-f6w5g<br>This is v2 running in pod kubia-88894bbd4-pbr5n<br>This is v2 running in pod kubia-88894bbd4-h8mck<br>This is v1 running in pod kubia-5f6cdb7bf7-f6w5g<br>This is v1 running in pod kubia-5f6cdb7bf7-f6w5g<br>This is v2 running in pod kubia-88894bbd4-w74nb<br>This is v2 running in pod kubia-88894bbd4-pbr5n<br>This is v1 running in pod kubia-5f6cdb7bf7-f6w5g<br>This is v2 running in pod kubia-88894bbd4-h8mck<br>This is v2 running in pod kubia-88894bbd4-h8mck<br>This is v2 running in pod kubia-88894bbd4-w74nb<br>This is v2 running in pod kubia-88894bbd4-h8mck<br>This is v2 running in pod kubia-88894bbd4-h8mck<br>This is v2 running in pod kubia-88894bbd4-w74nb<br>This is v2 running in pod kubia-88894bbd4-pbr5n<br></code></pre></td></tr></table></figure><p>可以看到，刚开始请求会打到 v1 或者 v2，到后面就全部是 v2 了，说明升级已经完成，同时也说明该命令使用的是 <strong>滚动更新</strong> 的方式，其实具体使用哪种方式是可以配置的，字段是 .spec.strategy.type，默认为 RollingUpdate，也就是滚动更新，还有一种 Recreate，采用的是先删除所有旧的，再创建新 pod 的方式。</p><h1 id="使用-deployment-进行回滚"><a href="#使用-deployment-进行回滚" class="headerlink" title="使用 deployment 进行回滚"></a>使用 deployment 进行回滚</h1><h2 id="为什么需要回滚"><a href="#为什么需要回滚" class="headerlink" title="为什么需要回滚"></a>为什么需要回滚</h2><p>可能发布的新版本存在一些 bug，但是在更新之前没有发现，等发现以后整个系统已经更新成新版本了，此时就需要进行回滚操作了。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>接着上面的操作，此时查看 rs，会发现之前的老 rs 没有被删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME               DESIRED   CURRENT   READY   AGE<br>kubia-88894bbd4    3         3         3       29m<br>kubia-5f6cdb7bf7   0         0         0       87m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe kubia-5f6</span><br>...<br>Pod Template:<br>  Labels:  app=kubia<br>           pod-template-hash=5f6cdb7bf7<br>  Containers:<br>   nodejs:<br>    Image:        luksa/kubia:v1<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe rs kubia-888</span><br>...<br>Pod Template:<br>  Labels:  app=kubia<br>           pod-template-hash=88894bbd4<br>  Containers:<br>   nodejs:<br>    Image:        luksa/kubia:v2<br>...<br></code></pre></td></tr></table></figure><p>为什么要保留旧的 rs 呢？<del>这里先卖个关子</del> 为的是能够完成回滚操作</p><p>开始升级，这里会更新到 v3 ，这是一个带有错误的版本，访问从 5 次开始就会返回一个 500 错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment kubia nodejs=luksa/kubia:v3 <span class="hljs-comment"># 更新到 v3</span></span><br>deployment.apps/kubia image updated<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment kubia <span class="hljs-comment"># 查看更新状态</span></span><br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 2 out of 3 new replicas have been updated...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 old replicas are pending termination...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 old replicas are pending termination...<br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 old replicas are pending termination...<br>deployment &quot;kubia&quot; successfully rolled out<br></code></pre></td></tr></table></figure><p>在另一个终端查看访问 service 的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v3 running in pod kubia-56ff78687-kc77b<br>Some internal error has occurred! This is pod kubia-56ff78687-2b7tz<br>This is v3 running in pod kubia-56ff78687-kc77b<br>Some internal error has occurred! This is pod kubia-56ff78687-2b7tz<br>This is v2 running in pod kubia-88894bbd4-h8mck<br>Some internal error has occurred! This is pod kubia-56ff78687-2b7tz<br>This is v3 running in pod kubia-56ff78687-mbqdw<br>This is v3 running in pod kubia-56ff78687-mbqdw<br>Some internal error has occurred! This is pod kubia-56ff78687-mbqdw<br>This is v3 running in pod kubia-56ff78687-kc77b<br>This is v2 running in pod kubia-88894bbd4-h8mck<br></code></pre></td></tr></table></figure><p>可以看到有一些报错了：Some internal error has occurred! This is pod kubia-56ff78687-mbqdw</p><p>对外提供一个有 bug 的 pod 显然是不行的，此时就需要执行回滚操作了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment kubia</span><br>deployment.apps/kubia rolled back<br></code></pre></td></tr></table></figure><p>在另一个终端查看访问 service 的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v2 running in pod kubia-88894bbd4-rvzvb<br>This is v2 running in pod kubia-88894bbd4-rvzvb<br>This is v2 running in pod kubia-88894bbd4-pxxwt<br>This is v2 running in pod kubia-88894bbd4-pxxwt<br>This is v2 running in pod kubia-88894bbd4-4wknk<br>This is v2 running in pod kubia-88894bbd4-4wknk<br></code></pre></td></tr></table></figure><p>发现已经回滚到 v2 版本了。</p><p>查看更新记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment kubia</span><br>deployment.apps/kubia<br>REVISION  CHANGE-CAUSE<br>1         kubectl apply --filename=deployment.yaml --record=true<br>3         kubectl apply --filename=deployment.yaml --record=true<br>4         kubectl apply --filename=deployment.yaml --record=true<br></code></pre></td></tr></table></figure><p>这里显示的和书中的有所不同，书中显示的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment kubia</span><br>deployments &quot;kubia&quot;:<br>REVISION CHANGE-CAUSE<br>2 kubectl set image deployment kubia nodejs=luksa/kubia:v2 <br>3 kubectl set image deployment kubia nodejs=luksa/kubia:v3<br></code></pre></td></tr></table></figure><p>感觉书上这种显示的友好一些，而且我执行的明明是 kubectl set image deployment kubia nodejs&#x3D;xxx ，为什么这里记录的是 kubectl apply –filename&#x3D;deployment.yaml –record&#x3D;true ？</p><p>前面提到过，–record 已经被废弃，难道新版本对 CHANGE-CAUSE 进行了一些变更吗？暂时还不知道啥情况</p><p>可以通过指定版本来查看详细信息，这样就可以解决上面的问题了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout <span class="hljs-built_in">history</span> deployment/kubia --revision=1</span><br>deployment.apps/kubia with revision #1<br>Pod Template:<br>  Labels:app=kubia<br>pod-template-hash=5f6cdb7bf7<br>  Annotations:kubernetes.io/change-cause: kubectl apply --filename=deployment.yaml --record=true<br>  Containers:<br>   nodejs:<br>    Image:luksa/kubia:v1<br>    Port:&lt;none&gt;<br>    Host Port:&lt;none&gt;<br>    Environment:&lt;none&gt;<br>    Mounts:&lt;none&gt;<br>  Volumes:&lt;none&gt;<br></code></pre></td></tr></table></figure><p>此时就可以看到该版本对应的镜像了。</p><p>至此已经经历了 v1 - v3 一共 3 个版本的迭代，有更新操作也有回滚操作，此时查看 rs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span><br>NAME               DESIRED   CURRENT   READY   AGE<br>kubia-5f6cdb7bf7   0         0         0       17h<br>kubia-88894bbd4    3         3         3       16h<br>kubia-56ff78687    0         0         0       15h<br></code></pre></td></tr></table></figure><p>会发现每个版本的 rs 依然存在，为的就是能执行回滚操作，顺带一提，回滚不仅仅是上个版本，还可以是任意一个版本，使用 <code>kubectl rollout undo deployment kubia --to-revision=l</code> 即可。在使用了 deployment 后，系统中的 rs 就不用我们去管理了，所以我们也不需要自己去手动修改、删除 rs 了。</p><h1 id="控制滚动升级速率"><a href="#控制滚动升级速率" class="headerlink" title="控制滚动升级速率"></a>控制滚动升级速率</h1><p>有两个属性可以用来控制升级速率：</p><ul><li>maxSurge：升级过程中最多允许超出 replicas 的 pod 数量，值可以是一个百分比或者一个数字</li><li>maxUnavailable：升级过程中最多允许的不可用 pod 数量，值可以是一个百分比或者一个数字</li></ul><p>这两个值定义在 .spec.strategy.rollingUpdate 中，下面对这两个属性进行展开说明。</p><p>前面提到过滚动升级的流程，大致是使用两个 rs，一个管理旧版本 pod，一个管理新版本 pod，管理旧版本的 rs 不断缩容，管理新版本的 rs 不断扩容，最终完成更新。通过上面的两个属性就可以对整个流程的速率进行控制，举个例子：现在一共有 3 个 pod 需要升级，此时将 maxUnavailable 设置为 2，代表最多允许有 2 个 pod 不可用，那么此时缩容 rs 就可以缩到 1。引用官方的说明：</p><blockquote><p><strong>最大不可用</strong></p><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> 是一个可选字段，用来指定 更新过程中不可用的 Pod 的个数上限。该值可以是绝对数字（例如，5），也可以是所需 Pods 的百分比（例如，10%）。百分比值会转换成绝对数并去除小数部分。 如果 <code>.spec.strategy.rollingUpdate.maxSurge</code> 为 0，则此值不能为 0。 默认值为 25%。</p><p>例如，当此值设置为 30% 时，滚动更新开始时会立即将旧 ReplicaSet 缩容到期望 Pod 个数的70%。 新 Pod 准备就绪后，可以继续缩容旧有的 ReplicaSet，然后对新的 ReplicaSet 扩容， 确保在更新期间可用的 Pods 总数在任何时候都至少为所需的 Pod 个数的 70%。</p><p><strong>最大峰值</strong></p><p><code>.spec.strategy.rollingUpdate.maxSurge</code> 是一个可选字段，用来指定可以创建的超出期望 Pod 个数的 Pod 数量。此值可以是绝对数（例如，5）或所需 Pods 的百分比（例如，10%）。 如果 <code>MaxUnavailable</code> 为 0，则此值不能为 0。百分比值会通过向上取整转换为绝对数。 此字段的默认值为 25%。</p><p>例如，当此值为 30% 时，启动滚动更新后，会立即对新的 ReplicaSet 扩容，同时保证新旧 Pod 的总数不超过所需 Pod 总数的 130%。一旦旧 Pods 被杀死，新的 ReplicaSet 可以进一步扩容， 同时确保更新期间的任何时候运行中的 Pods 总数最多为所需 Pods 总数的 130%。</p></blockquote><p>对于书上的表 9.2 我有点疑问，对这两个属性的描述都是：<code>当把百分数转换成绝对值时，会将数字四舍五入</code>，但是后面又举了个例子：</p><blockquote><p>由于在之前场景中，设置的期望副本数为 3，上述的两个属性都设置为 25%, maxSurge 允许最多 pod数量达到 4， 同时 maxUnavailable 不允许出现任何不可用的pod (也就是说三个pod&amp;、须一直处于可运行状态)</p></blockquote><p>副本数为 3，maxUnavailable 设置为 25%，3*25% &#x3D; 0.75，四舍五入等于 1，那么应该允许有 1 个 pod 不可用，为什么书上说的是不允许任何 pod 不可用？</p><p>在看官方的文档：maxUnavailable 说的是：百分比值会转换成绝对数并去除小数部分</p><p>maxSurge 说的是：百分比值会通过向上取整转换为绝对数</p><p>这显然和书上说的四舍五入有出入，那么到底实际情况如何呢？只有源码能揭晓答案了。</p><p>对应的函数在 kubernetes&#x2F;pkg&#x2F;controller&#x2F;deployment&#x2F;util&#x2F;deployment_util.go 下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// desired 代表副本数量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ResolveFenceposts</span><span class="hljs-params">(maxSurge, maxUnavailable *intstrutil.IntOrString, desired <span class="hljs-type">int32</span>)</span></span> (<span class="hljs-type">int32</span>, <span class="hljs-type">int32</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// maxSurge 没有设置，则使用默认值 0</span><br><span class="hljs-comment">// roundUp 设置为 true，代表向上取整</span><br>surge, err := intstrutil.GetScaledValueFromIntOrPercent(intstrutil.ValueOrDefault(maxSurge, intstrutil.FromInt(<span class="hljs-number">0</span>)), <span class="hljs-type">int</span>(desired), <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-comment">// maxUnavailable 没有设置，则使用默认值 0</span><br><span class="hljs-comment">// roundUp 设置为 false，代表向下取整</span><br>unavailable, err := intstrutil.GetScaledValueFromIntOrPercent(intstrutil.ValueOrDefault(maxUnavailable, intstrutil.FromInt(<span class="hljs-number">0</span>)), <span class="hljs-type">int</span>(desired), <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-comment">// 所以 surge 和 unavailable 采用的策略是不同的</span><br><span class="hljs-comment">// 比如 replicas 为 3，maxSurge 和 maxUnavailable 都设置为 25%，</span><br><span class="hljs-comment">// 3 * 25 / 100 = 0.75，surge 采用向上取整，所以为 1，而 unavailable</span><br><span class="hljs-comment">// 采用向下取整, 所以为 0</span><br><br><span class="hljs-keyword">if</span> surge == <span class="hljs-number">0</span> &amp;&amp; unavailable == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Validation should never allow the user to explicitly use zero values for both maxSurge</span><br><span class="hljs-comment">// maxUnavailable. Due to rounding down maxUnavailable though, it may resolve to zero.</span><br><span class="hljs-comment">// If both fenceposts resolve to zero, then we should set maxUnavailable to 1 on the</span><br><span class="hljs-comment">// theory that surge might not work due to quota.</span><br>unavailable = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-type">int32</span>(surge), <span class="hljs-type">int32</span>(unavailable), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用的 GetScaledValueFromIntOrPercent 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// intOrPercent 代表一个整数或者百分比字符串，total 代表总数量，roundUp 代表向上取整还是向下取整，</span><br><span class="hljs-comment">// 如果 intOrPercent 是 int，那么直接返回，如果是百分比，则返回 total*百分比后的值（还需要进行取整处理）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetScaledValueFromIntOrPercent</span><span class="hljs-params">(intOrPercent *IntOrString, total <span class="hljs-type">int</span>, roundUp <span class="hljs-type">bool</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> intOrPercent == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;nil value for IntOrString&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 获取 intOrPercent 的值，该值可能是一个数字或者百分比</span><br>value, isPercent, err := getIntOrPercentValueSafely(intOrPercent)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;invalid value for IntOrString: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 如果该值是百分比</span><br><span class="hljs-keyword">if</span> isPercent &#123;<br><span class="hljs-comment">// 如果设置了 roundUp（不知道咋翻译），则向上取整，比如 1.2 =&gt; 2（不是四舍五入）</span><br><span class="hljs-keyword">if</span> roundUp &#123;<br>value = <span class="hljs-type">int</span>(math.Ceil(<span class="hljs-type">float64</span>(value) * (<span class="hljs-type">float64</span>(total)) / <span class="hljs-number">100</span>))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 否则向下取整，比如 1.5 =&gt; 1</span><br>value = <span class="hljs-type">int</span>(math.Floor(<span class="hljs-type">float64</span>(value) * (<span class="hljs-type">float64</span>(total)) / <span class="hljs-number">100</span>))<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestResolveFenceposts1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>maxSurge := intstr.FromString(<span class="hljs-string">&quot;25%&quot;</span>)<br>maxUnavailable := intstr.FromString(<span class="hljs-string">&quot;25%&quot;</span>)<br><span class="hljs-keyword">var</span> replicas <span class="hljs-type">int32</span> = <span class="hljs-number">3</span><br>s, u, err := ResolveFenceposts(&amp;maxSurge, &amp;maxUnavailable, replicas)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Error(err)<br>&#125;<br>t.Log(s, u)<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 1 0 </span><br><span class="hljs-comment">// 代表两个值都设置为 25% 的情况下，允许多出 1 个 pod，允许有 0 个 pod 不可用</span><br></code></pre></td></tr></table></figure><p>所以书上说的四舍五入并不准确，官方文档才是正确的，不过最靠谱的还是看源码 （狗头）。</p><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h2><p>该 yaml 用来创建一个 replicas 为 3 的 deployment：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f nginx-deployment.yaml --record</span><br>deployment.apps/nginx-deployment created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span>                                    <br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-7848d4b86f   3         3         3       6m57s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新 deployment 的镜像版本，1.91 是一个不存在的版本</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">set</span> image deployment/nginx-deployment nginx=nginx:1.91</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看该 deployment 管理的 rs，发现多出来了一个 rs，其期望的 pod 数量为 1，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">但是因为 1.91 版本不存在，所以 READY 为 0，这个多出来的 rs 就是用来做滚动更新的</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rs</span>                                                <br>NAME                          DESIRED   CURRENT   READY   AGE<br>nginx-deployment-7848d4b86f   3         3         3       6h54m<br>nginx-deployment-b475d749b    1         1         0       7m8s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看更新后的 deployment</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get deploy</span>                                            <br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>nginx-deployment   3/3     1            3           6h59m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 deployment 的详细信息，发现滚动策略为 25% max unavailable, 25% max surge，也就是允许多出 1 个 pod，允许</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">有 0 个 pod 不可用，所以会创建一个新的 pod，所以那个新创建出来的 rs 的 replicas 为 1</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe deploy nginx-deployment</span>        <br>Name:                   nginx-deployment<br>Namespace:              default<br>CreationTimestamp:      Tue, 11 Oct 2022 17:21:35 +0800<br>Labels:                 app=nginx<br>Annotations:            deployment.kubernetes.io/revision: 4<br>                        kubernetes.io/change-cause: kubectl apply --filename=nginx-deployment.yaml --record=true<br>Selector:               app=nginx<br>Replicas:               3 desired | 1 updated | 4 total | 3 available | 1 unavailable<br>StrategyType:           RollingUpdate<br>MinReadySeconds:        0<br>RollingUpdateStrategy:  25% max unavailable, 25% max surge<br>Pod Template:<br>  Labels:  app=nginx<br>  Containers:<br>   nginx:<br>    Image:        nginx:1.91<br>    Port:         80/TCP<br>    Host Port:    0/TCP<br>    Environment:  &lt;none&gt;<br>    Mounts:       &lt;none&gt;<br>  Volumes:        &lt;none&gt;<br>Conditions:<br>  Type           Status  Reason<br>  ----           ------  ------<br>  Available      True    MinimumReplicasAvailable<br>  Progressing    True    ReplicaSetUpdated<br>OldReplicaSets:  nginx-deployment-7848d4b86f (3/3 replicas created)<br>NewReplicaSet:   nginx-deployment-b475d749b (1/1 replicas created)<br>Events:<br>  Type    Reason             Age                 From                   Message<br>  ----    ------             ----                ----                   -------<br>  Normal  ScalingReplicaSet  9m9s                deployment-controller  Scaled down replica set nginx-deployment-b475d749b to 0<br>  Normal  ScalingReplicaSet  6m9s (x2 over 13m)  deployment-controller  Scaled up replica set nginx-deployment-b475d749b to 1<br></code></pre></td></tr></table></figure><h1 id="升级过程中检测新版本是否可用"><a href="#升级过程中检测新版本是否可用" class="headerlink" title="升级过程中检测新版本是否可用"></a>升级过程中检测新版本是否可用</h1><p>在回滚一节中说过，更新的新版本可能是一个无法工作的版本，此时需要回滚操作，那么有没有一种方法可以边更新边检测，发现不可用就停止更新呢？当然可以，使用一个额外的 minReadySeconds 属性 + 就绪探针就可以实现。</p><p>minReadySeconds 属性指定新创建的 pod 至少要成功运行多久之后，才能将其视为可用。在 pod 可用之前，滚动升级的过程不会继续。当所有容器的就绪探针返回成功时，pod 就被标记为就绪状态。</p><p>如果一个新的 pod 运行出错，就绪探针返回失败，或者在 minReadySeconds 时间内它的就绪探针出现了失败， 那么新版本的滚动升级将被阻止。</p><p>之前的笔记有写过存活探针，这里的是就绪探针，二者有所区别，但区别不是特别大，这里简单摘要一下官方的文档：</p><blockquote><p>livenessProbe（存活探针）</p><p>指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其<a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">重启策略</a>决定未来。如果容器不提供存活探针， 则默认状态为 <code>Success</code>。</p><p>readinessProbe（就绪探针）</p><p>指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 <code>Failure</code>。 如果容器不提供就绪态探针，则默认状态为 <code>Success</code>。</p><p>startupProbe（启动探针）</p><p>指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，<code>kubelet</code> 将杀死容器，而容器依其 <a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">重启策略</a>进行重启。 如果容器没有提供启动探测，则默认状态为 <code>Success</code>。</p></blockquote><h2 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h2><p>yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># pod 就绪后继续等待 10 秒</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 确保升级过程中 pod 被挨个替换</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia:v3</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nodejs</span><br>          <span class="hljs-attr">readinessProbe:</span> <span class="hljs-comment"># 就绪探针</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 探针每隔 1 秒执行一次</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br><br></code></pre></td></tr></table></figure><p>这是一个“坏掉”的镜像：就绪探针检测不会成功，下面来执行 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-deployment-v3-with-readinesscheck.yaml</span><br>deployment.apps/kubia configured<br></code></pre></td></tr></table></figure><p>apply 命令可以用 YAML 文件中声明的字段来更新 Deployment。不仅更新镜像，而且还添加了就绪探针，以及在 YAML 中添加或修改的其他声明。 如果新的 YAML 也包含 replicas 字段，当它与现有 Deployment 中的数量不一 致时，那么 apply 操作也会对 Dpeloymnet 进行扩容。</p><p>此时查看升级过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment kubia</span><br>Waiting for deployment &quot;kubia&quot; rollout to finish: 1 out of 3 new replicas have been updated...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">很久以后...</span><br>error: deployment &quot;kubia&quot; exceeded its progress deadline<br></code></pre></td></tr></table></figure><p>整个流程卡在了更新第一个 pod，说明更新失败了，使用 curl 请求 service 看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">do</span> curl 10.43.191.168; <span class="hljs-built_in">sleep</span> 0.5s;<span class="hljs-keyword">done</span></span><br>This is v2 running in pod kubia-88894bbd4-4wknk<br>This is v2 running in pod kubia-88894bbd4-pxxwt<br>This is v2 running in pod kubia-88894bbd4-rvzvb<br>This is v2 running in pod kubia-88894bbd4-4wknk<br>This is v2 running in pod kubia-88894bbd4-pxxwt<br>This is v2 running in pod kubia-88894bbd4-pxxwt<br>This is v2 running in pod kubia-88894bbd4-pxxwt<br></code></pre></td></tr></table></figure><p>发现请求全部打在了 v2 pod 上，没有 v3 版本，这是符合需求的，请求不应该落到一个有问题的 pod 上</p><p>查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                     READY   STATUS    RESTARTS   AGE<br>kubia-88894bbd4-rvzvb    1/1     Running   0          23h<br>kubia-88894bbd4-4wknk    1/1     Running   0          23h<br>kubia-88894bbd4-pxxwt    1/1     Running   0          23h<br>kubia-74c44776ff-rm4xw   0/1     Running   0          98s<br></code></pre></td></tr></table></figure><p>发现有一个 pod 没有处于 READY 状态，因为我们设置了 maxSurge 为 1，所以一共有 replicas + 1 个 pod，多出来就是这个没有 READY 的 v3 pod，因为它的探针检测失败了。通过 <code>kubectl describe po kubia-74c44776ff-rm4xw</code> 也可以看到，最后一行的事件显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Warning  Unhealthy  2m25s (x22 over 2m45s)  kubelet            Readiness probe failed: HTTP probe failed with statuscode: 500<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh 输入卡顿</title>
    <link href="/2022/05/11/ssh-shu-ru-qia-dun/"/>
    <url>/2022/05/11/ssh-shu-ru-qia-dun/</url>
    
    <content type="html"><![CDATA[<p>ssh 到家里的另外一台电脑，发现输入延迟比较严重，体验不是很好，ping 发现延迟普遍在 100 -200 之间，有几次甚至超过了 400，在网上找到了一个解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /etc/ssh/sshd_config</span><br></code></pre></td></tr></table></figure><p>输入 &#x2F;UseDNS 查找这一行，找到后发现这行 UseDNS no 是被注释的，去掉注释，然后 <code>service sshd restart</code> 即可，修改之后卡顿问题缓解了不少，基本可以正常使用了。</p><p>更新：其实有时候还是卡的一 b，看来该方法用处不是特别大</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux clone() 的坑</title>
    <link href="/2022/05/11/linux-clone-de-keng/"/>
    <url>/2022/05/11/linux-clone-de-keng/</url>
    
    <content type="html"><![CDATA[<p>环境：</p><p>MacBook m1</p><p>Ubuntu 20.04.4 LTS（使用 cat &#x2F;etc&#x2F;issue 查看），基于 multipass 创建</p><p>在阅读<strong>《深入剖析Kubernetes》-张磊——白话容器基础（三）：深入理解容器镜像</strong>，文中提供了一个 namespace 的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> container_stack[STACK_SIZE];<br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> container_args[] = &#123;<br>  <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>  <span class="hljs-literal">NULL</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">container_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Container - inside the container!\n&quot;</span>);<br>  execv(container_args[<span class="hljs-number">0</span>], container_args);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something&#x27;s wrong!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - start a container!\n&quot;</span>);<br>  <span class="hljs-type">int</span> container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , <span class="hljs-literal">NULL</span>);<br>  waitpid(container_pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - container stopped!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是在我的机器上无法运行，输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Parent - start a container!<br>Parent - container stopped!<br></code></pre></td></tr></table></figure><p>可以看到，传入 clone 的回调函数没有被执行， 因为 Container - inside the container! 没有被输出。</p><p>在main 函数的 waitpid调用后面添加一下错误信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (WIFEXITED(status) != <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 子进程非正常退出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, WTERMSIG(status)); <span class="hljs-comment">// 输出信号类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>WTERMSIG 会输出信号类型，输出为 7，查了一下，意思是 SIGBUS，这是个什么玩意呢？查了一下资料，大概是内存错误、对齐错误什么的，完全看不懂，也不知道如何解决。。。</p><p>注：使用 gdb 进行调试也可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb ns_err</span><br>GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2<br>(gdb) set follow-fork-mode child<br>(gdb) r<br>Starting program: /home/ubuntu/codetest/ns_err<br>Parent - start a container!<br>[Attaching after process 192301 fork to child process 192304]<br>[New inferior 2 (process 192304)]<br>[Detaching after fork from parent process 192301]<br>containerPid: 192304<br>[Inferior 1 (process 192301) detached]<br><br>Thread 2.1 &quot;ns_err&quot; received signal SIGBUS, Bus error.<br>[Switching to process 192304]<br>0x0000000000400738 in container_main ()<br></code></pre></td></tr></table></figure><p>也可以看到 <code>&quot;ns_err&quot; received signal SIGBUS, Bus error.</code> 这句话</p><p>最后还是从官方文档查到了答案，不得不说还是官方文档最为靠谱</p><p><a href="https://man7.org/linux/man-pages/man2/clone.2.html">https://man7.org/linux/man-pages/man2/clone.2.html</a></p><p>最下面有一个 example，把这段代码 copy 到本地，发现居然可以成功运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/utsname.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br>       <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br>       <span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                               &#125; while (0)</span><br><br>       <span class="hljs-type">static</span> <span class="hljs-type">int</span>              <span class="hljs-comment">/* Start function for cloned child */</span><br>       childFunc(<span class="hljs-type">void</span> *arg)<br>       &#123;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">utsname</span> <span class="hljs-title">uts</span>;</span><br><br>           <span class="hljs-comment">/* Change hostname in UTS namespace of child. */</span><br><br>           <span class="hljs-keyword">if</span> (sethostname(arg, <span class="hljs-built_in">strlen</span>(arg)) == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;sethostname&quot;</span>);<br><br>           <span class="hljs-comment">/* Retrieve and display hostname. */</span><br><br>           <span class="hljs-keyword">if</span> (uname(&amp;uts) == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;uname&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;uts.nodename in child:  %s\n&quot;</span>, uts.nodename);<br><br>           <span class="hljs-comment">/* Keep the namespace open for a while, by sleeping.</span><br><span class="hljs-comment">              This allows some experimentation--for example, another</span><br><span class="hljs-comment">              process might join the namespace. */</span><br><br>           sleep(<span class="hljs-number">200</span>);<br><br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;           <span class="hljs-comment">/* Child terminates now */</span><br>       &#125;<br><br>       <span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)    <span class="hljs-comment">/* Stack size for cloned child */</span></span><br><br>       <span class="hljs-type">int</span><br>       <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>       &#123;<br>           <span class="hljs-type">char</span> *<span class="hljs-built_in">stack</span>;                    <span class="hljs-comment">/* Start of stack buffer */</span><br>           <span class="hljs-type">char</span> *stackTop;                 <span class="hljs-comment">/* End of stack buffer */</span><br>           <span class="hljs-type">pid_t</span> pid;<br>           <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">utsname</span> <span class="hljs-title">uts</span>;</span><br><br>           <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>               <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &lt;child-hostname&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>               <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>           &#125;<br><br>           <span class="hljs-comment">/* Allocate memory to be used for the stack of the child. */</span><br><br>           <span class="hljs-built_in">stack</span> = mmap(<span class="hljs-literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,<br>                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span> == MAP_FAILED)<br>               errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>           stackTop = <span class="hljs-built_in">stack</span> + STACK_SIZE;  <span class="hljs-comment">/* Assume stack grows downward */</span><br><br>           <span class="hljs-comment">/* Create child that has its own UTS namespace;</span><br><span class="hljs-comment">              child commences execution in childFunc(). */</span><br><br>           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[<span class="hljs-number">1</span>]);<br>           <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;clone&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;clone() returned %jd\n&quot;</span>, (<span class="hljs-type">intmax_t</span>) pid);<br><br>           <span class="hljs-comment">/* Parent falls through to here */</span><br><br>           sleep(<span class="hljs-number">1</span>);           <span class="hljs-comment">/* Give child time to change its hostname */</span><br><br>           <span class="hljs-comment">/* Display hostname in parent&#x27;s UTS namespace. This will be</span><br><span class="hljs-comment">              different from hostname in child&#x27;s UTS namespace. */</span><br><br>           <span class="hljs-keyword">if</span> (uname(&amp;uts) == <span class="hljs-number">-1</span>)<br>               errExit(<span class="hljs-string">&quot;uname&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;uts.nodename in parent: %s\n&quot;</span>, uts.nodename);<br><br>           <span class="hljs-keyword">if</span> (waitpid(pid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)    <span class="hljs-comment">/* Wait for child */</span><br>               errExit(<span class="hljs-string">&quot;waitpid&quot;</span>);<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child has terminated\n&quot;</span>);<br><br>           <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>       &#125;<br></code></pre></td></tr></table></figure><p>不同之处在于这几句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">stack</span> = mmap(<span class="hljs-literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,<br>                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span> == MAP_FAILED)<br>               errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>           stackTop = <span class="hljs-built_in">stack</span> + STACK_SIZE;  <span class="hljs-comment">/* Assume stack grows downward */</span><br><br>           <span class="hljs-comment">/* Create child that has its own UTS namespace;</span><br><span class="hljs-comment">              child commences execution in childFunc(). */</span><br><br>           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>它是通过 mmap 申请的内存</p><p>现在使用相同的方式，修改一下之前的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mount.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE (1024 * 1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); \</span><br><span class="hljs-meta">                               &#125; while (0)</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> container_stack[STACK_SIZE];<br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> container_args[] = &#123;<br>  <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>  <span class="hljs-literal">NULL</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">container_main</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Container - inside the container!\n&quot;</span>);<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">//mount(&quot;&quot;, &quot;/&quot;, NULL, MS_PRIVATE, &quot;&quot;);</span><br>  <span class="hljs-comment">//mount(&quot;none&quot;, &quot;/tmp&quot;, &quot;tmpfs&quot;, 0, &quot;&quot;);</span><br>  execv(container_args[<span class="hljs-number">0</span>], container_args);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something&#x27;s wrong!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> *<span class="hljs-built_in">stack</span>;                    <span class="hljs-comment">/* Start of stack buffer */</span><br>  <span class="hljs-type">char</span> *stackTop;                 <span class="hljs-comment">/* End of stack buffer */</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - start a container!\n&quot;</span>);<br>  <span class="hljs-built_in">stack</span> = mmap(<span class="hljs-literal">NULL</span>, STACK_SIZE, PROT_READ | PROT_WRITE,<br>                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span> == MAP_FAILED)<br>               errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br><br>  stackTop = <span class="hljs-built_in">stack</span> + STACK_SIZE;<br>  <span class="hljs-type">int</span> container_pid = clone(container_main, stackTop, CLONE_NEWNS|SIGCHLD , <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;containerPid: %d\n&quot;</span>, container_pid);<br>  <span class="hljs-type">int</span> status;<br>  waitpid(container_pid, &amp;status, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (WIFEXITED(status) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error!&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, WTERMSIG(status));<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent - container stopped!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是见证奇迹的时刻了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./a.out</span><br>Parent - start a container!<br>containerPid: 192918<br>Container - inside the container!<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br>Parent - container stopped!<br></code></pre></td></tr></table></figure><p>没有报错了，成功进入容器，问题终于解决了。</p><p>至于为什么需要使用 mmap，作为一个菜鸡目前还没有头绪，后续再进行研究</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP MIME 嗅探 [待完善]</title>
    <link href="/2022/05/08/http_mime_sniff/"/>
    <url>/2022/05/08/http_mime_sniff/</url>
    
    <content type="html"><![CDATA[<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>定义一个未知后缀名的文件（这个后缀名起的得随意一点，像 xyz 这种是不行的，会被 chrome 识别为 chemical&#x2F;x-xyz 类型），但是文件里的内容是 HTML：</p><p><strong>demo.lubenwei</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后写一个 http file server，将文件内容作为 response 返回：</p><p><strong>mime_sniffing.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>http.ServeFile(w, r, <span class="hljs-string">&quot;./demo.lubenwei&quot;</span>)<br>&#125;)<br><br>log.Println(<span class="hljs-string">&quot;listen in 8080&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里没有指定 Content-Type</p><p>接下来运行这个 http server：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run mime_sniffing.go</span><br></code></pre></td></tr></table></figure><p>然后在浏览器中访问 <a href="http://localhost:8080，会发现显示的内容是">http://localhost:8080，会发现显示的内容是</a> h2 标题的 HelloWorld</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/79d6e00a6af31a6e75ee69a2bbb98db04077808d/img/http_sniff.jpg"></p><p>这里就比较疑惑了，我既没有指定 Content-Type 响应头，也没有将文件后缀名定义为 html，那浏览器是如何知道其内容是 html，同时解析出来的呢？查了一下，这就是所谓的 <strong>MIME 嗅探</strong>，大致意思就是如果没有定义 Content-Type，那么浏览器会读取文件内容，推断这是个什么类型的文件，进而采取不同的处理方式，比如这里就会读取我这个后缀名为 lubenwei 的文件，发现里面有 html 标签，然后将其作为 html 解析</p><p>可以通过设置响应头 <strong>X-Content-Type-Options: nosniff</strong>  来禁止客户端嗅探文件内容，修改后代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Header().Set(<span class="hljs-string">&quot;X-Content-Type-Options&quot;</span>, <span class="hljs-string">&quot;nosniff&quot;</span>)<br>http.ServeFile(w, r, <span class="hljs-string">&quot;./demo.lubenwei&quot;</span>)<br>&#125;)<br><br>log.Println(<span class="hljs-string">&quot;listen in 8080&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我这边访问 <a href="http://localhost:8080/">http://localhost:8080</a> 依然会显示 h2 格式的 HelloWorld（使用 chrome、edge、safari 分别测试，结果相同）</p><p>貌似是因为 <strong>X-Content-Type-Options: nosniff</strong> 需要和 <strong>Content-Type</strong> 搭配使用才行，这里我给指定一个错误的 Content-Type：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;json&quot;</span>)<br>w.Header().Set(<span class="hljs-string">&quot;X-Content-Type-Options&quot;</span>, <span class="hljs-string">&quot;nosniff&quot;</span>)<br>http.ServeFile(w, r, <span class="hljs-string">&quot;./demo.lubenwei&quot;</span>)<br>&#125;)<br><br>log.Println(<span class="hljs-string">&quot;listen in 8080&quot;</span>)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用浏览器（safari）访问，会发现此时不会显示 HelloWorld 了，而是会下载这个文件，不同的浏览器会有不同的策略，chrome 和 edge 的话是会直接显示出文件的内容，这里需要注意的是浏览器可能会走缓存，导致还是显示 h2 格式的 HelloWorld，可以开一个隐身窗口访问：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/450b24efcb799fb18039ebb6ed302a441bfb1bc2/img/http_nosniff.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s service</title>
    <link href="/2022/05/08/k8s-service/"/>
    <url>/2022/05/08/k8s-service/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-service"><a href="#什么是-service" class="headerlink" title="什么是 service"></a>什么是 service</h1><p>pod 往往需要与集群内的其他 pod 进行通信，同时可能也需要对外提供服务，让集群外部的 pod 也可以访问，如果需要管理员手动将 pod 的地址提供给访问者，显然太麻烦了，不适合作为解决方案，而且在 k8s 中 pod 的地址是不确定的，它是由 k8s 自动分配的；此外，pod 的地址也是随时可能变动的，这是因为 Pod 可能会在节点之间移动或者被重新创建。例如，当一个 Pod 从一个节点迁移到另一个节点时，它的 IP 地址也会随之改变。此外，当一个 Pod 被删除后，其 IP 地址也会随之消失。所以 k8s 需要提供一种稳定的资源类型来解决 pod 间通信的问题，避免直接使用 Pod IP 地址来访问 Pod。这个资源就是就是 service。</p><p>service 为 <strong>一组功能相同</strong>（逻辑意义上的，例如使用相同的标签）的 pod 提供单一不变的接入点，service 的 IP 和端口不会改变，所以访问者可以统一连接到 service，service 再将请求转发给其代理的某一个 pod（会负载均衡的访问），这样，无论 Pod IP 是否变化，都能保证对 Service 的访问不会受到影响，就可以解决上面的 pod 地址变动问题。</p><h1 id="创建-service"><a href="#创建-service" class="headerlink" title="创建 service"></a>创建 service</h1><p>下面的 yaml 可以创建一个 service：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 pod 的 80 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span> <span class="hljs-comment"># 具有 app=kubia 标签的 pod 都属于该 service</span><br></code></pre></td></tr></table></figure><blockquote><p> ⚠️ targetPort 必须指向一个有效的、被监听的 port，否则之后访问该 service 会报错 Connection refused</p></blockquote><p>创建完成后，可以使用下面的命令进行查看，获取 service 的 IP 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   23h<br>kubia        ClusterIP   10.43.87.107   &lt;none&gt;        80/TCP    23h<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>知道 service 的 IP 地址后就可以进行测试了，有以下几种方式</p><ol><li><p>在 node 执行 curl serviceIP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.87.107</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略 ...</span><br></code></pre></td></tr></table></figure><p>因为我转发的容器是 nginx，所以会输出 nginx 的 index.html，这里 curl 的地址没有写端口号，是因为不写端口号会默认走 80 端口，然后这个 svc 的 port 刚好也是 80，所以可以省略。</p></li><li><p>进入一个容器内部执行 curl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-2qkls   1/1     Running   0          24h<br>kubia-qgtjw   1/1     Running   0          24h<br>kubia-mbghg   1/1     Running   0          24h<br>nginx         1/1     Running   0          20h<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it kubia-2qkls -- curl 10.43.87.107</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略 ...</span><br></code></pre></td></tr></table></figure><p>如果用过 docker，那么 exec 命令应该已经非常熟悉了</p></li></ol><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>虽然 service 提供了一个统一访问的 pod 的途径，但是还存在一个问题：访问者又如何知道 service 的 IP 地址？难道还是需要管理员手动执行命令查看 service 的 IP 然后告诉访问者吗？那这不是搞了个寂寞吗，不过不用着急，你想到的 k8s 都想到了，并且给出了解决方案： service 服务发现。</p><p>k8s 提供的服务发现有以下几种类型：</p><h2 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h2><p>k8s 可以为每个容器设置环境变量，其中包括其他 Pod、Service 和 Kubernetes API Server 的地址信息，通过环境变量服务发现，服务消费者可以通过访问容器的环境变量来发现和访问其他 Pod 和 Service。</p><blockquote><p> ⚠️ 这种方式需要 <strong>service 先于 pod 创建</strong>，这样在 pod 创建过程中，k8s 会将其<br> 所属的 service 地址写入到其环境变量中，pod 通过环境变量就可以知道 service 的地<br> 址了。</p></blockquote><p>service 的环境变量名格式是 <code>&lt;SERVICE_NAME&gt;_SERVICE_HOST</code> 和 <code>&lt;SERVICE_NAME&gt;_SERVICE_PORT</code>，其中 <code>&lt;SERVICE_NAME&gt;</code> 是 Service 的名称，<code>SERVICE_HOST</code> 和 <code>SERVICE_PORT</code> 是固定的后缀。Service name 会转换为全大写，并且其中的 - 会转换为下划线。</p><p>例如，如果有一个名为 <code>my-service</code> 的 Service，它的 Cluster IP 为 <code>10.0.0.1</code>，端口为 <code>8080</code>，则 k8s 会在 Pod 中为其创建两个环境变量：</p><ul><li><code>MY_SERVICE_SERVICE_HOST</code>：值为 <code>10.0.0.1</code>。</li><li><code>MY_SERVICE_SERVICE_PORT</code>：值为 <code>8080</code>。</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>service.yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 pod 的 80 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 具有 app=nginx 标签的 pod 都属于该 service</span><br></code></pre></td></tr></table></figure><p>deploy.yaml，用于创建 nginx pod：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>访问者的 pod yaml，使用的镜像是一个 go 程序，需要传递两个参数，分别是 <code>service host</code> 的环境变量名和 <code>port</code> 的环境变量名，前面提到过这两个环境变量的命名规则，因为我创建的 service name 是 kubia，所以两个环境变量名分别是：KUBIA_SERVICE_HOST 和 KUBIA_SERVICE_PORT。然后这个程序会拿到这两个环境变量的 value，再通过这两个 value 拼接成 URL，最后通过 http 来访问 nginx，期望结果会输出 nginx 的 index.html，也就是欢迎页面。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/service-env-test</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-hostEnv&quot;</span>, <span class="hljs-string">&quot;KUBIA_SERVICE_HOST&quot;</span>, <span class="hljs-string">&quot;-portEnv&quot;</span>, <span class="hljs-string">&quot;KUBIA_SERVICE_PORT&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>注意这里需要先创建 service，再创建 deploy，最后再创建 http-get pod。</strong></p><p>创建客户端 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f http-get.yaml</span><br>pod/http-get created<br></code></pre></td></tr></table></figure><p>查看 pod 日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs http-get</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">程序会打印出两个环境变量</span><br>KUBIA_SERVICE_HOST:10.43.65.224<br>KUBIA_SERVICE_PORT:80<br>url: http://10.43.65.224:80<br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx index.html 成功输出了</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>通过日志内容，说明 pod 成功通过环境变量获取到了 service 的地址，并通过 service 访问到了 pod。</p><blockquote><p>附：</p><p> <code>http-get</code> 对应镜像 <code>stdoutt/service-env-test</code> 的源码和 Dockerfile：</p><p>go 源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> hostServiceEnvName = flag.String(<span class="hljs-string">&quot;hostEnv&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;k8s service host env name&quot;</span>)<br><span class="hljs-keyword">var</span> portServiceEnvName = flag.String(<span class="hljs-string">&quot;portEnv&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;k8s service port env name&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>host := os.Getenv(*hostServiceEnvName)<br>port := os.Getenv(*portServiceEnvName)<br>url_ := fmt.Sprintf(<span class="hljs-string">&quot;http://%v:%v&quot;</span>, host, port)<br>fmt.Printf(<span class="hljs-string">&quot;%v:%v\n&quot;</span>, *hostServiceEnvName, host)<br>fmt.Printf(<span class="hljs-string">&quot;%v:%v\n&quot;</span>, *portServiceEnvName, port)<br>fmt.Printf(<span class="hljs-string">&quot;url: %v\n&quot;</span>, url_)<br>resp, err := http.Get(url_)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br></code></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> golang:alpine AS builder<br><br><span class="hljs-comment"># 移动到工作目录：/build</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /build</span><br><br><span class="hljs-comment"># 将代码复制到容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 将我们的代码编译成二进制可执行文件 app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o app .</span><br><br><span class="hljs-comment">###################</span><br><span class="hljs-comment"># 接下来创建一个小镜像</span><br><span class="hljs-comment">###################</span><br><span class="hljs-keyword">FROM</span> scratch<br><br><span class="hljs-comment"># 从builder镜像中把/dist/app 拷贝到当前目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /build/app /</span><br><br><span class="hljs-comment"># 需要运行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/app&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>如果你想构建多架构镜像，可以使用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker buildx create --name mybuilder --use<br>docker buildx build -t &lt;repo/imagename&gt; --platform=linux/arm64,linux/amd64 . --push<br></code></pre></td></tr></table></figure></blockquote><h2 id="使用-DNS"><a href="#使用-DNS" class="headerlink" title="使用 DNS"></a>使用 DNS</h2><p>除了环境变量外，还有一种更简单的方式：通过 DNS 发现服务，之后便可以通过 FQDN 进行访问，格式类似于：<code>backend-database.default.svc.cluster.local</code>，其中 <code>backend-database</code> 是 <strong>service 的名字</strong>，<strong>default 是 service 所在的命名空间</strong>，<strong>svc.cluster.local 是在所有集群本地服务名称中使用的可配置集群域后缀（这里不懂）</strong>。</p><blockquote><p>⚠️ 客户端仍然需要知道服务的端口号。如果服务使用标准端口号(例如，HTTP 的 80 端口或 Postgres 的 5432 端口)，这样是没问题的。 如果并不是标准端口， 客户端可以从环境变量中获取端口号 。</p><p>（摘抄自书上）</p><p><del>这里没看懂，都直接通过域名访问了，为什么客户端还需要知道端口号？</del></p><p>初学时的一个比较 2 的问题，说明基础不牢，域名只负责解析出 IP ，而只有 IP 没有端口号显然是不能访问服务的。</p></blockquote><p>如果访问 pod 和被访问 pod 在同一个命名空间，那么可以直接用 service.name 进行访问，后面的可以全部省略，比如下面的例子，直接使用 service 的名字 kubia 进行访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 service，获取 service 的名字</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes   ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   33h<br>kubia        ClusterIP   10.43.65.224   &lt;none&gt;        80/TCP    8h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有的 pod</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS      RESTARTS         AGE<br>kubia-msv7g   1/1     Running     0                8h<br>kubia-8d2gm   1/1     Running     0                8h<br>kubia-r4fcs   1/1     Running     0                8h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择 1 个容器，在内部执行 curl 域名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> kubia-msv79 -- curl kubia</span><br><span class="hljs-meta prompt_">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br>                                 Dload  Upload   Total   Spent    Left  Speed<br>  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">curl 完整域名</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it kubia-msv79 -- curl kubia.default.svc.cluster.local</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>需要先准备 service 和 deploy，可以直接沿用 <strong>使用环境变量</strong> 这一节实践里的 yaml，另外准备一个 yaml 用来通过 dns 和 port 访问 k8s service：</p><p><strong>httpget_dns.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/service-dns-test</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-dns&quot;</span>, <span class="hljs-string">&quot;kubia.default.svc.cluster.local&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;80&quot;</span>]<br></code></pre></td></tr></table></figure><p>这个镜像需要提供两个参数 <code>-dns</code> 和 <code>-p</code>，顾名思义，分别对应 dns 和 port，然后程序会根据 dns 解析出对应的 IP，并将 IP 和 port 拼接成一个 HTTP URL，并通过 HTTP 访问。</p><p>运行并查看效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f httpget_dns.yaml</span><br>pod/http-get created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                               READY   STATUS              RESTARTS      AGE<br>http-get                           0/1     ContainerCreating   0             11s<br>nginx-deployment-ff6774dc6-4nz9z   1/1     Running             2 (51m ago)   23h<br>nginx-deployment-ff6774dc6-cwn7p   1/1     Running             2 (51m ago)   23h<br>nginx-deployment-ff6774dc6-pjxhk   1/1     Running             2 (51m ago)   23h<br>http-get                           0/1     Completed           0             21s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 <span class="hljs-built_in">log</span> 查看效果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs http-get</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里会输出通过 dns 解析到的 ip</span><br>http://10.110.49.109:80<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出了 nginx 的欢迎页面</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><blockquote><p>附：</p><p> <code>http-get</code> 对应镜像 <code>stdoutt/service-dns-test</code> 的源码和 Dockerfile：</p><p>go 源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>dns  <span class="hljs-type">string</span><br>port <span class="hljs-type">string</span><br>)<br><br>flag.StringVar(&amp;dns, <span class="hljs-string">&quot;dns&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;dns&quot;</span>)<br>flag.StringVar(&amp;port, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br>flag.Parse()<br><br><span class="hljs-keyword">if</span> dns == <span class="hljs-string">&quot;&quot;</span> || port == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;dns must not null&quot;</span>)<br>&#125;<br><br>addrs, err := net.LookupIP(dns)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> httpGet = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br><br><span class="hljs-keyword">for</span> _, addr := <span class="hljs-keyword">range</span> addrs &#123;<br>url := fmt.Sprintf(<span class="hljs-string">&quot;http://%v:%v&quot;</span>, addr, port)<br>fmt.Println(url)<br>httpGet(url)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> golang:alpine AS builder<br><br><span class="hljs-comment"># 移动到工作目录：/build</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /build</span><br><br><span class="hljs-comment"># 将代码复制到容器中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 将我们的代码编译成二进制可执行文件 app</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o app .</span><br><br><span class="hljs-comment"># 接下来创建一个小镜像</span><br><span class="hljs-keyword">FROM</span> scratch<br><br><span class="hljs-comment"># 从 builder 镜像中把 /dist/app 拷贝到当前目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /build/app /</span><br><br><span class="hljs-comment"># 需要运行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/app&quot;</span>]</span><br><br></code></pre></td></tr></table></figure><p>build</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker buildx create --name mybuilder --use</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker buildx build -t &lt;repo/imagename&gt; --platform=linux/arm64,linux/amd64 . --push</span><br><br><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">集群内访问</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># ClusterIP</span></span><br><br>通过集群内部 IP 地址暴露服务，但该地址 **仅在集群内部** 可见、可达，它无法被集群外部的客户端访问，是 service 的默认访问类型。如果不明确指定 clusterIP，则由 K8S 动态指定一个，也支持用户手动明确指定。<br><br>下面这个 yaml 创建了一个没有明确指定 clusterIP 的 service，以及一个创建 nginx 的 rs：<br><br>```yaml<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br> name: nginx-service<br>spec:<br> ports:<br> - port: 80 # 该 service 的端口<br> selector:<br>   app: nginx<br>---<br>apiVersion: apps/v1<br>kind: ReplicaSet<br>metadata:<br> name: nginx-rs<br>spec:<br> replicas: 3<br> selector:<br>   matchLabels:<br>     app: nginx<br> template:<br>   metadata:<br>     labels:<br>       app: nginx<br>   spec:<br>     containers:<br>     - name: nginx<br>       image: nginx:alpine<br>       ports:<br>       - containerPort: 80<br>---<br></code></pre></td></tr></table></figure></blockquote><p>运行后查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   31h<br>nginx-service            ClusterIP   10.43.27.242   &lt;none&gt;        80/TCP    7h9m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe svc nginx-service</span><br>Name:              nginx-service<br>Namespace:         default<br>Labels:            &lt;none&gt;<br>Annotations:       &lt;none&gt;<br>Selector:          app=nginx<br>Type:              ClusterIP<br>IP Family Policy:  SingleStack<br>IP Families:       IPv4<br>IP:                10.43.27.242<br>IPs:               10.43.27.242<br>Port:              &lt;unset&gt;  80/TCP<br>TargetPort:        80/TCP<br>Endpoints:         10.42.0.30:80,10.42.0.32:80,10.42.0.36:80<br>Session Affinity:  None<br>Events:            &lt;none&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.27.242</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>发现这个 service 是 ClusterIP 类型的，且 k8s 自动指定了一个地址，并且可以成功访问。</p><p>也可以手动指定一个 clusterIP，在上面的 yaml 的 service 部分中修改一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service1</span> <span class="hljs-comment"># 起个新名字</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.43</span><span class="hljs-number">.27</span><span class="hljs-number">.66</span> <span class="hljs-comment"># 手动指定 ip</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f svc_clusterip.yaml</span><br>service/nginx-service1 created<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   32h<br>nginx-service            ClusterIP   10.43.27.242   &lt;none&gt;        80/TCP    7h16m<br>nginx-service1           ClusterIP   10.43.27.66    &lt;none&gt;        80/TCP    10s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.27.66 <span class="hljs-comment"># 可以成功访问</span></span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>但是不推荐手动指定 clusterIP，可能会造成 IP 冲突。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_clusterip.webp"></p><h3 id="使用-kube-proxy-让外部访问-ClusterIP-Service"><a href="#使用-kube-proxy-让外部访问-ClusterIP-Service" class="headerlink" title="使用 kube-proxy 让外部访问 ClusterIP Service"></a>使用 kube-proxy 让外部访问 ClusterIP Service</h3><p>正常来说 ClusterIP 类型的 Service 是无法从外部访问的，但是有种特殊的方法可以——使用 kube-proxy，也就是上图中的 proxy 部分。</p><p>具体的流程：</p><p>首先在集群内节点执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy --address=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>  --accept-hosts=<span class="hljs-string">&#x27;^*$&#x27;</span> --port=8081</span><br></code></pre></td></tr></table></figure><p>注意要加上 <code>--address</code> 和 <code>--accept-hosts</code>，否则访问会返回 <code>Forbidden</code>。</p><p>然后在外部机器执行以下格式语句进行访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://[nodeIP]:[port]/api/v1/namespaces/[namespace-name]/services/[service-name]/proxy</span><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -X GET -L http://192.168.31.50:8081/api/v1/namespaces/default/services/nginx/proxy</span><br></code></pre></td></tr></table></figure><p>PS: “curl -L” 中的 “-L” 是 curl 命令中的选项，它的含义是 “Follow any redirections”. 也就是说，如果服务器返回了一个重定向响应，那么 curl 命令就会自动跟随重定向并请求重定向的地址。</p><p>在我的机器上测试，-X GET 可以不指定，但是 -L 一定要指定，否则返回结果为空</p><p>感觉有点类似 NodePort，也是使用节点 IP + proxy 开启的端口进行访问，不过前提是你的外部机器可以通过 IP 访问到这个节点</p><h1 id="对外访问"><a href="#对外访问" class="headerlink" title="对外访问"></a>对外访问</h1><blockquote><p>参考：</p><p><a href="https://www.do1618.com/archives/1235/kubernetes-nodeport-vs-loadbalancer-vs-ingress%EF%BC%9F-%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F/">Kubernetes NodePort vs LoadBalancer vs Ingress？ 我们应该什么时候使用？</a></p><p><a href="https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0">Kubernetes NodePort vs LoadBalancer vs Ingress？ 我们应该什么时候使用？（原文）</a></p></blockquote><p>前面提到的这些都仅限于集群的内部访问，集群外是无法访问的，比如上面的 service IP 是 10.43.65.224，这只在集群内可以 curl ，集群外是不行的，而且这个 IP 即便是在集群内也是无法 ping 通的，因为这是一个<strong>虚拟 IP 地址</strong>。</p><p>有以下几种方式可以将 service 暴露给集群外部：</p><h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_nodeport.webp"></p><p>NodePort 会在 <strong>每个 node 上开启一个端口</strong> 用来访问 service，这个端口定义在 spec.ports[0].nodePort，用户可以使用 <strong>节点IP:nodePort</strong> 进行访问，也可以使用 <strong>serviceIP:port</strong> 访问（这种方式其实就是前面介绍的常规 service 访问方式，只能在集群内部使用），nodePort 也可以不指定，会随机从 30000-32767 中选择一个。</p><p>实践：</p><p>需要准备以下 yaml：</p><ul><li>用来创建 nginx deployment 的 yaml：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-comment"># manage pods with the label app: nginx</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><ul><li>创建 NodePort 类型的 service，用来访问 nginx pod：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-node-port</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 pod 的 80 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30123</span> <span class="hljs-comment"># 30000-32767 之间</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>之后使用 apply -f 执行上面的两个 yaml（这里就不展示了）</p><p>查看 service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE<br>kubernetes        ClusterIP   10.43.0.1     &lt;none&gt;        443/TCP        13d<br>kubia-node-port   NodePort    10.43.21.78   &lt;none&gt;        80:30123/TCP   6m12s<br></code></pre></td></tr></table></figure><p>此时就可以使用集群中的任意一个节点的 IP 加 30123 端口进行访问了，比如我的是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ifconfig | grep 192</span><br>inet 192.168.64.4  netmask 255.255.255.0  broadcast 192.168.64.255<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.64.4:30123</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><h2 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_lb.webp"></p><p>LoadBalance（负载均衡），大致流程是：对外提供一个统一的 IP，这个 IP 就是负载均衡器，它会将用户请求负载均衡的分发给 pod，我个人的理解是，它在 NodePort 的基础上又添加了一层类似代理层的东西，让客户端访问更加方便。</p><p>举个例子：假设此时有 2 个工作节点 1.1.1.1 和 2.2.2.2，每个节点上运行 3 个 nginx pod，nodePort 为 30000，那么在 NodePort 下，客户端访问需要指定某个 node 的具体 IP，比如 1.1.1.1:30000 或者 2.2.2.2:30000；如果使用 loadBalance 的话，则会提供一个统一的公网 IP（比如 180.1.1.1）作为负载均衡器，用户只要访问这个 IP 就可以（当然还要添加端口号），负载均衡器会负载均衡的把请求分发到 1.1.1.1:30000 或者 2.2.2.2:30000，比如如下的 loadBalance yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">vl</span> <br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span> <br><span class="hljs-attr">metadata:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">kubia-loadbalancer</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span> <br><span class="hljs-attr">ports:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># loadBalance 的端口</span><br><span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 转发到 pod 的 8080 端口</span><br><span class="hljs-attr">nodePort:</span> <span class="hljs-number">30000</span><br><span class="hljs-attr">selector:</span><br><span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br></code></pre></td></tr></table></figure><p>LoadBalance 通常由云服务商提供，所以实践起来可能麻烦一些，需要在腾讯云这种平台上实践，好像也有一些组件可以提供本地的使用，这部分我还没有去了解。</p><h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/k8s_service_ingress.webp"></p><blockquote><p><del>个人吐槽（请忽视）：</del></p><p><del>这个玩意是我目前为止用的最蛋疼的一个功能，不是不好用，而是连用都用不上，我在 minikube 上使用的 ingress-nginx 因为拉取的镜像地址被墙，导致根本无法开启 ingress 服务，又因为我的 minikube 是跑在 multipass 虚拟机上的，不知道如何共享宿主机的 vpn，导致这个问题一直无法解决，不得不吐槽一下，m1 的生态还是有点问题，就虚拟机这块，我找了半天，基本能用的只有这个简陋的 multipass （收费的 parallels 没有尝试），vmware 直接无法运行（提示什么该软件基于 Intel 但却尝试使用 rosetta2 运行），还有一个 virtualBox ，这个我直接懒得下了，据说都不支持 m1，而且这种网络问题搞得我真的很头大，不得不吐槽一下天朝的网络，花费大把时间去解决网络问题，还有看见某个流程一直卡在 pull 上，让人有一种想砸掉电脑的冲动，最蛋疼的是这个问题还没有什么靠谱的解决方式，在 minikube 和 ingress-nginx 的 github 上找到了关于国内拉取的 issue，但是基本也没什么有用的答案，还有一些网上的教程，给的修改版 yaml 直接跑都跑不起来。</del></p><p><del>在 mac 上跑 minikube 可以成功开启 ingress 插件，但是又会报 <code>Because you are using a Docker driver on darwin, the terminal needs to be open to run it</code> 错误，网上找了半天也没看见一个能用的解决方法</del></p><p><del>折腾了一天都没把 ingress 给跑起来，感觉是在纯纯的浪费时间</del></p></blockquote><p>LoadBalance 的方式存在一个缺点：只能为一种类型的 service 提供服务，比如上面的介绍的 loadbalance 只是用来访问 nginx 的，如果现在集群添加了一些 redis pod，那么又要新创建一个 LoadBalance 来提供对外服务（比如 spec.ports[0].port&#x3D;6379, target&#x3D;6379, nodePort&#x3D;30001），客户端通过 <strong>LoadBalanceIP:30000</strong> 这个地址来完成对 nginx pod 的访问，通过 <strong>LoadBalanceIP:30001</strong> 来完成对 redis pod 的访问，因为 LoadBalanceIP 是公网 IP，所以这么搞无疑有点浪费。</p><p>为了解决上面的问题，ingress 这个玩意就应运而生了，这个东西其实说白了就是 service 的 service（无限套娃？），类似于 web 路由的功能，通过访问不同的域名来完成对不同 service 的访问，就比如这张图：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1654445796590.jpg"><br>而且 ingress 工作在应用层，所以可以提供一些 service 不能实现的功能，比如基于 cookie 的会话亲和性 (session affinity) 等</p><h3 id="基于-minikube-nginx-ingress-的实践"><a href="#基于-minikube-nginx-ingress-的实践" class="headerlink" title="基于 minikube nginx ingress 的实践"></a>基于 minikube nginx ingress 的实践</h3><blockquote><p>该实践基于 minikube</p></blockquote><p>all.yaml</p><p>包含了三个 pod 和三个对应的 service</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/hello-app-arm64</span> <span class="hljs-comment"># 注意这里使用的镜像仅适用于 arm64 机器</span><br>    <span class="hljs-comment"># image: gcr.io/google-samples/hello-app:2.0 # 如果你的机器是 amd64 的可以使用这个</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">81</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 转发到 pod 的 8080 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30111</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 转发到 pod 的 80 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30222</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">6379</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">82</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6379</span> <span class="hljs-comment"># 转发到 pod 的 8080 端口</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30333</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis</span><br></code></pre></td></tr></table></figure><p>ingress.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ingress</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-comment"># ingressClassName: nginx # 如果你使用的不是 minikube，需要加上这行</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">ingress.example.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/redis</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">redis-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">82</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/hello-app</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">81</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/nginx</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>运行上面的 2 个 yaml</p><p>查看 ingress 的 ip：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get ingress</span><br>NAME              CLASS   HOSTS                 ADDRESS        PORTS   AGE<br>example-ingress   nginx   ingress.example.com   192.168.49.2   80      9h<br></code></pre></td></tr></table></figure><p>将 ingress ip 写入到 &#x2F;etc&#x2F;hosts：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim /etc/hosts</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入这一条：192.168.49.2 ingress.example.com</span><br></code></pre></td></tr></table></figure><p>问题：</p><p>访问 &#x2F;hello-app 可以正常显示结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">curl ingress.example.com/hello-app</span><br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app<br></code></pre></td></tr></table></figure><p>但是 &#x2F;nginx 和 &#x2F;redis 都显示 404：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl ingress.example.com/nginx</span><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx/1.23.1&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>但是直接访问 service 又是通的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br>hello-app-service   NodePort    10.103.218.83   &lt;none&gt;        81:30111/TCP   9h<br>kubernetes          ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        14h<br>nginx-service       NodePort    10.99.214.102   &lt;none&gt;        80:30222/TCP   9h<br>redis-service       NodePort    10.104.106.67   &lt;none&gt;        82:30333/TCP   9h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">minikube ip</span><br>192.168.49.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.49.2:30222</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>ps: minikube 如果想访问 service，需要将 service 定义为 nodePort 类型，然后通过 <code>minikube ip</code> 命令来获取 minikube 的 ip，然后用 <code>&lt;minikube_IP:nodePort&gt;</code> 的方式进行访问。似乎不能直接在集群内通过  <code>curl ClusterIP</code> 的方式来访问 service。</p></blockquote><p>解决方法：</p><p>在 ingress.yaml 中添加 <code>nginx.ingress.kubernetes.io/rewrite-target: /</code> 注解</p><p>修改后的 metadata：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>现在试试访问 &#x2F;nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl ingress.example.com/nginx</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>可以看到成功使用 ingress 访问了 nginx ，而不是之前的 404。</p><p>但是访问 &#x2F;redis 会报 502 错误（可能对于 ingress 而言，redis 不是一个好的例子）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl ingress.example.com/redis</span><br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>这里暂时不知道什么原因，感觉这里用 redis 来做实践本身也不太合理，毕竟 curl redis 本来就不会正常工作，但是用 redis-cli 通过访问 service 的方式可以正常工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br>hello-app-service   NodePort    10.103.218.83   &lt;none&gt;        81:30111/TCP   12h<br>kubernetes          ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        17h<br>nginx-service       NodePort    10.99.214.102   &lt;none&gt;        80:30222/TCP   12h<br>redis-service       NodePort    10.104.106.67   &lt;none&gt;        82:30333/TCP   12h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">k8s minikube ip</span><br>192.168.49.2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -h 192.168.49.2 -p 30333</span><br>192.168.49.2:30333&gt; keys *<br>1) &quot;1&quot;<br>192.168.49.2:30333&gt;<br></code></pre></td></tr></table></figure><p>但是用 ingress 的地址访问是不行的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -h ingress.example.com/redis -p 82</span><br>Could not connect to Redis at ingress.example.com/redis:82: Name or service not known<br>not connected&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">redis-cli -h ingress.example.com/redis -p 30333</span><br>Could not connect to Redis at ingress.example.com/redis:30333: Name or service not known<br>not connected&gt;<br></code></pre></td></tr></table></figure><p>这个问题暂时将其搁置，毕竟这里主要还是以学习 ingress 为主。</p><h1 id="特殊的-headless-service"><a href="#特殊的-headless-service" class="headerlink" title="特殊的 headless service"></a>特殊的 headless service</h1><p>service 提供了稳定的对外访问服务，同时还提供了负载均衡的能力，每次访问 service，都会将其转发到该 service selector 对应的 pod 中的某一个，具体转发给哪个是由 service 决定的，访问者没有自主选择权，但是如果访问者想自主选择访问哪个 pod，或者想访问该 service 下的所有 pod，此时该如何处理呢？为了解决这类问题，就需要 Headless Service 闪亮登场了。</p><p>顾名思义，headless service 一种特殊的 service，它是没有 IP 的，想要访问它，只能通过 DNS 的方式访问，DNS 的固定格式是 <service_name>.<namespace>.svc.cluster.local。而访问 headless service 也不同于普通 service ，它不会随机访问其代理的某个 pod，而是直接将其代理的所有 pod 的 address 提供给你。</p><p>除此以外，它还会为 <strong>其代理的每个 pod</strong> 的 IP 地址绑定一个如下格式的 DNS 记录：</p><p><pod_name>.<service_name>.<namespace>.svc.cluster.local</p><p>通过上面这种格式的 DNS 记录，就可以获取 headless service 下的某个 pod 的 IP 地址了。</p><p>更新：</p><p>感觉 headless service 会为其代理的 pod 生成 DNS 不太准确？因为我实践了一下，用 headless service + 由 rs 创建出来的 pod，然后 exec 到随便一个 pod 执行 <code>nslookup &lt;pod_name&gt;.&lt;service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code> 是无法解析到地址的，报错 <code>server can&#39;t find nginx-rs-wzc4r.nginx-service-headless.default.svc.cluster.local: NXDOMAIN</code>，而用 headless service + 由 StatefulSet 创建出来的 pod 则可以成功解析到地址。</p><blockquote><ul><li>疑问：用户自行选择 pod 的场景有哪些？用户需要访问 service 下所有 pod 的场景有哪些？</li></ul><p> 用户自行选择 pod 的场景可能包括：</p><ol><li>特定的服务需要访问特定的 pod，例如需要使用某个 pod 上特定的配置或者数据。</li><li>测试或者调试需要针对特定的 pod 进行操作，例如分析特定 pod 的日志或者性能数据。</li></ol><p> 需要访问 service 下所有 pod 的场景可能包括：</p><ol><li>执行批量操作，例如向 service 下所有 pod 发送某个指令或者获取所有 pod 的状态信息。</li><li>在服务发现场景下，需要获取 service 下所有可用的 pod 列表。</li></ol><p> 需要注意的是，在 k8s 中，用户一般不需要直接访问 pod，而是通过 service 提供的稳定的对外访问服务来访问应用程序。只有在特定的情况下，才需要直接访问 pod。</p><ul><li>疑问：使用 headless service 后，是否代表负载均衡已经失效，需要用户自行实现？</li></ul></blockquote><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践 1"></a>实践 1</h2><p><strong>这个实践将会测试 headless service 的特性，并且会和普通的 service 进行对比，加深理解。</strong></p><p>下面这个 yaml 会创建一个 nginx rs，以及两个对应的 service，一个是正常的 service，还有一个是 headless 类型的 service：</p><p>（ps：好像如果 pod 指定了 containerPort，那么 service 这边可以不指定 targetPort）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service-headless</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-comment">#targetPort: 8080 # 转发到 pod 的 8080 端口</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-comment">#targetPort: 8080 # 转发到 pod 的 8080 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-rs</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f headless_service_test.yaml</span><br>service/nginx-service-headless unchanged<br>service/nginx-service created<br>replicaset.apps/nginx-rs unchanged<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME             READY   STATUS    RESTARTS   AGE<br>nginx-rs-f2b4j   1/1     Running   1 (33m ago)   47m<br>nginx-rs-dhxz7   1/1     Running   1 (33m ago)   47m<br>nginx-rs-sn8wk   1/1     Running   1 (33m ago)   47m<br>dnsutils         1/1     Running   1 (33m ago)   36m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME                     TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE<br>kubernetes               ClusterIP   10.43.0.1      &lt;none&gt;        443/TCP   24h<br>nginx-service-headless   ClusterIP   None           &lt;none&gt;        80/TCP    48s<br>nginx-service            ClusterIP   10.43.27.242   &lt;none&gt;        80/TCP    29s<br></code></pre></td></tr></table></figure><p>测试一下普通的 service 能否访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 10.43.27.242</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br></code></pre></td></tr></table></figure><p>可以看到，普通的 service 是可以正常访问的，但是 headless service 是不可以访问的，因为 headless service 明确指定了 clusterIP 为 None，所以不会给它分配一个集群内 IP，所以无法通过 curl 的方式访问。</p><p>使用 nslookup 查看二者的 dns 解析，看看他们两的区别，service 的 dns 格式是 <code>&lt;service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code>，注意这里需要在容器内部执行。</p><blockquote><p>Tips: nginx 容器默认应该是没有安装 nsloopup 的，你需要执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">apt install dnsutils</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-rs-dhxz7 -- nslookup nginx-service.default.svc.cluster.local</span><br>Server:10.43.0.10<br>Address:10.43.0.10:53<br><br>Name:nginx-service.default.svc.cluster.local<br>Address: 10.43.27.242<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl <span class="hljs-built_in">exec</span> -it nginx-rs-dhxz7 -- nslookup nginx-service-headless.default.svc.cluster.local</span><br>Server:10.43.0.10<br>Address:10.43.0.10:53<br><br>Name:nginx-service-headless.default.svc.cluster.local<br>Address: 10.42.0.36<br>Name:nginx-service-headless.default.svc.cluster.local<br>Address: 10.42.0.32<br>Name:nginx-service-headless.default.svc.cluster.local<br>Address: 10.42.0.30<br></code></pre></td></tr></table></figure><p>发现区别了吗？普通的 service 只返回了一条地址，这条地址正是 service 自身的 ip，而 headless service 返回了 3 条地址，这 3 条地址正是 service 代理的几个 pod 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -o wide</span><br>NAME             READY   STATUS    RESTARTS      AGE   IP           NODE     NOMINATED NODE   READINESS GATES<br>nginx-rs-f2b4j   1/1     Running   1 (40m ago)   54m   10.42.0.36   ubuntu   &lt;none&gt;           &lt;none&gt;<br>nginx-rs-dhxz7   1/1     Running   1 (40m ago)   54m   10.42.0.30   ubuntu   &lt;none&gt;           &lt;none&gt;<br>nginx-rs-sn8wk   1/1     Running   1 (40m ago)   54m   10.42.0.32   ubuntu   &lt;none&gt;           &lt;none&gt;<br>dnsutils         1/1     Running   1 (40m ago)   43m   10.42.0.31   ubuntu   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p><del>此外，我们还可以验证一下 headless 为其代理的 pod 生成的 DNS 记录：</del></p><p><del>待完成，不知道为什么解析不出 IP，报错：&#96;server can’t find nginx-rs-wzc4r.nginx-service-headless.default.svc.cluster.local: NXDOMAIN</del></p><h2 id="实践-2"><a href="#实践-2" class="headerlink" title="实践 2"></a>实践 2</h2><p>这个实践会用通过代码的方式，从 headless service 中获取 pod 地址，然后访问这些 pod。</p><p>首先需要准备下面的几个 yaml。</p><p><strong>Deployment.yaml</strong></p><p>这个 deploy 将会创建 3 个 pod，每个 pod 都是一个 http server ，通过 -h 来指定地址，-p 来指定监听端口，访问该 server 会返回包括主机名等基本信息。注意这里的 -h 需要指定为 0.0.0.0 而不是 localhost，指定为 localhost 的话其他 pod 将无法访问。（为什么呢？）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/hello-app</span><br>        <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-h&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>Service.yaml</strong></p><p>这是一个 headless service。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 该 service 的端口</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 转发到 pod 的 80 端口</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">hello-app</span> <span class="hljs-comment"># 具有 app=hello-app 标签的 pod 都属于该 service</span><br></code></pre></td></tr></table></figure><p><strong>httpget.yaml</strong></p><p>这个 pod 通过 -s 来指定 headless service 的 FQDN，最终这个镜像内部的程序会调用 net.LookupSRV 解析出每个 pod 对应的 SRV 记录，然后通过 SRV 记录进行访问。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-get</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">stdoutt/service-headless-test</span><br>    <span class="hljs-attr">args:</span> [<span class="hljs-string">&quot;-s&quot;</span>, <span class="hljs-string">&quot;hello-app.default.svc.cluster.local&quot;</span>, <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>]<br></code></pre></td></tr></table></figure><p>然后依次创建 Deployment，headless service：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get deploy</span><br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>hello-app          3/3     3            3           130m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get svc</span><br>NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE<br>hello-app    ClusterIP   None            &lt;none&gt;        80/TCP    119m<br>kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP   80d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME                               READY   STATUS    RESTARTS      AGE<br>hello-app-7b5f4475c8-bv8lz         1/1     Running   0             131m<br>hello-app-7b5f4475c8-pcrv8         1/1     Running   0             131m<br>hello-app-7b5f4475c8-wm528         1/1     Running   0             131m<br></code></pre></td></tr></table></figure><p>最后创建 httpget，然后等待一会，等 pod 起来后，通过 logs 查看输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f httpget_headless.yaml</span><br>pod/http-get created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 <span class="hljs-built_in">log</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs http-get</span><br>url: http://10-1-0-117.hello-app.default.svc.cluster.local.:8080<br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app-7b5f4475c8-pcrv8<br><br>url: http://10-1-0-118.hello-app.default.svc.cluster.local.:8080<br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app-7b5f4475c8-bv8lz<br><br>url: http://10-1-0-116.hello-app.default.svc.cluster.local.:8080<br>Hello, world!<br>Version: 1.0.0<br>Hostname: hello-app-7b5f4475c8-wm528<br></code></pre></td></tr></table></figure><p>从 log 可以看到，我们成功访问到了每一个 pod，日志里的 3 个 Hostname 和 pod name 相符。</p><blockquote><p>附：</p><p>http-get 镜像的 go 源码：</p><p>通过 net.LookupSRV 解析出 SRV 记录，从 SRV 里可以拿到 taget 和 port，将这个两个参数拼接成一个完整的 HTTP URL 进行访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>HeadlessServiceName <span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.StringVar(&amp;HeadlessServiceName, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;headless service name&quot;</span>)<br>flag.Parse()<br><br>_, addrs, err := net.LookupSRV(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, HeadlessServiceName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-type">string</span>(b))<br>&#125;<br><br><span class="hljs-keyword">for</span> _, addr := <span class="hljs-keyword">range</span> addrs &#123;<br>url := fmt.Sprintf(<span class="hljs-string">&quot;http://%v:%v&quot;</span>, addr.Target, addr.Port)<br>fmt.Printf(<span class="hljs-string">&quot;url: %v\n&quot;</span>, url)<br>fn(url)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>待补充&#x2F;疑问：</p><p>SRV 记录是什么？</p><p>为什么 net.LookupSRV 返回的 SRV.Target 是 <code>10-1-0-117.hello-app.default.svc.cluster.local. </code>这样的，而不是像 nslookup 那样直接返回 IP？</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>multipass 修改配置（内存、硬盘、CPU 等）适用于 m1 mac</title>
    <link href="/2022/05/08/multipass-xiu-gai-pei-zhi/"/>
    <url>/2022/05/08/multipass-xiu-gai-pei-zhi/</url>
    
    <content type="html"><![CDATA[<p><strong>multipass</strong> 是一款比较轻量级的虚拟机方案，使用起来也比较方便，操作方式与容器类似，但是使用过程中发现没有直接提供修改配置的简单方法，比如默认创建的虚拟机硬盘大小只会分配 5G，如果要跑 k8s 之类的显然是不够用的（k3s 都不够），而且默认创建的 CPU 只有 1 核，连 minikube 都跑不起来（最低需要 2 核），所以就需要修改配置。</p><p>在 github 上找到的解决方案（适用于 m1 mac）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">停止 multipass</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo launchctl unload /Library/LaunchDaemons/com.canonical.multipassd.plist</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件（CPU 对应 num_cores）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo vim /var/root/Library/Application\ Support/multipassd/qemu/multipassd-vm-instances.json</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 multipass</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo launchctl load /Library/LaunchDaemons/com.canonical.multipassd.plist</span><br></code></pre></td></tr></table></figure><p>参考：</p><p><a href="https://github.com/canonical/multipass/issues/1158">https://github.com/canonical/multipass/issues/1158</a></p><p>更新：</p><p>CPU 能更改成功，但是修改内存无法生效，这玩意还是不太好用</p>]]></content>
    
    
    
    <tags>
      
      <tag>multipass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s nginx pod 的 containerPort 问题</title>
    <link href="/2022/05/08/k8s-nginx-pod-de-containerport-wen-ti/"/>
    <url>/2022/05/08/k8s-nginx-pod-de-containerport-wen-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h1><p>有如下 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">9527</span><br></code></pre></td></tr></table></figure><p>此时 curl nodeIP:9527 会发现报 Connection refused 错误，使用 <code>kubectl exec -it nginx -- curl localhost:8080</code> 也是如此</p><h1 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">9527</span><br></code></pre></td></tr></table></figure><p>将 containerPort 改为 80，这是 nginx 的默认监听端口。</p><p>此时从浏览器访问 NodeIP:9527 发现可以显示 nginx 的主页，使用 <code>kubectl exec -it nginx -- curl localhost:80</code> 也可以正常工作，<code>curl localhost:9527</code> 也同样可以正常工作。但是 <code>kubectl exec -it nginx -- curl localhost:9527</code> 会报 Connection refused 错误。</p><h1 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h1><p>从上面的例子中可以得出：hostPort 是主机对外暴露的 IP 地址，其指向容器内部的 containerPort，在 <strong>修改</strong> 的例子中，意义为：对外暴露 9527 端口，该端口指向 nginx 容器内部的 80 端口，所以访问主机的 9527 相当于访问 nginx 容器的 80 端口，从 <code>kubectl exec -it nginx -- curl localhost:9527</code> 报 Connection refused 可以得出，容器内部是没有监听 9527 这个端口的。</p><p>在 stackoverflow 上找到了两个同样的问题：</p><p><a href="https://stackoverflow.com/questions/69282237/nginx-pod-not-taking-specified-port">https://stackoverflow.com/questions/69282237/nginx-pod-not-taking-specified-port</a></p><p>回答：</p><blockquote><p>NGINX Docker image uses port 80 to listen for HTTP connections by default. containerPort is the port which you expose your application to external traffic.</p><p>NGINX Docker 镜像默认使用 80 端口来监听 HTTP 连接。容器端口是您将应用程序公开给外部流量的端口。</p></blockquote><p><a href="https://stackoverflow.com/questions/66526811/unable-to-curl-pod-ip-using-containerport">https://stackoverflow.com/questions/66526811/unable-to-curl-pod-ip-using-containerport</a></p><p>回答：</p><blockquote><p>By default, <code>nginx</code> server listen to the port 80. You can see it in their docker image <a href="https://hub.docker.com/layers/nginx/library/nginx/1.18.0-alpine/images/sha256-d7038eae37cfa36cd8e286f6d6daf0df7a445a2da327517b3cde4ba1833adc0c?context=explore">ref</a>.</p><p>With <code>kubectl run nginx --image=nginx --port=8888</code> what you have done here is you have expose another port along with 80. But the server is still listening on the <code>80</code> port.</p><p>So, try with target port <code>80</code>. For this reason when you tried with other than port <code>80</code> it’s not working. Try with set <code>--target-port=8888</code> to <code>--target-port=80</code>.</p><p>Or, If you want to change the server port you need to use configmap along with pod to pass custom config to the server.</p><p>默认情况下，<code>nginx</code> 服务器监听 80 端口。你可以在他们的 docker 镜像中看到它 [ref](<a href="https://hub.docker.com/layers/nginx/library/nginx/1.18.0">https://hub.docker.com/layers/nginx/library/nginx/1.18.0</a> - alpine&#x2F;images &#x2F;sha256 - d7038eae37cfa36cd8e286f6d6daf0df7a445a2da327517b3cde4ba1833adc0c?context&#x3D;explore)。<br>使用 <code>kubectl run nginx - image=nginx - port=8888</code> 你在这里所做的是你已经暴露了另一个端口以及 80。但是服务器仍在监听 <code>80</code> 端口。<br>因此，请尝试使用目标端口“80”。因此，当您尝试使用端口“80”以外的其他端口时，它不起作用。尝试将<code>-target-port=8888</code>设置为<code>-target-port=80</code>。<br>或者，如果要更改服务器端口，则需要使用 configmap 和 pod 将自定义配置传递给服务器。</p></blockquote><p>那么 containerPort 这个参数到底是什么作用呢？</p><p>查阅资料，有这几种说法：</p><ol><li><p>containerPort 是 pod 中的容器需要暴露的端口</p></li><li><p>containerPort 是容器内部的 port</p></li><li><blockquote><p><strong>ports</strong> <em>:</em> <strong>containerPort</strong> List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses,<strong>but is primarily informational</strong>. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default “0.0.0.0” address inside a container will be accessible from the network. Cannot be updated.</p><p><em>containerPort</em> 是要从容器公开的端口列表。在此处公开端口可为系统提供有关容器使用的网络连接的附加信息，<strong>但主要是信息性</strong>的。此处不指定端口不会阻止该端口被暴露。任何侦听容器内默认“0.0.0.0”地址的端口都可以从网络访问。无法更新。（机翻，来自 <a href="https://faun.pub/should-i-configure-the-ports-in-kubernetes-deployment-c6b3817e495%EF%BC%89">https://faun.pub/should-i-configure-the-ports-in-kubernetes-deployment-c6b3817e495）</a></p></blockquote></li></ol><p>从上面这些说法大致了解了，nginx 容器会默认监听 80 端口，而我指定的 containerPort 实际上不会改变 nginx 监听的端口，所以如果将其指定为非 80 端口，比如 8080，那么 hostPort 会访问容器内的 8080 端口，但 8080 没有被任何程序监听，所以会产生 Connection refused 错误。就和上面所说的，containerPort 主要是信息性的，它只是<strong>注明</strong>了容器对外暴露的端口，不会实际对容器造成影响。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s DaemonSet</title>
    <link href="/2022/05/07/k8s-daemonset/"/>
    <url>/2022/05/07/k8s-daemonset/</url>
    
    <content type="html"><![CDATA[<p>顾名思义，daemon 代表守护程序，所以 DaemonSet （简称 ds）会在每个节点上运行一个专门的 pod，这个 pod 是特殊的，比如资源监控器或者日志收集器，或者 k8s 自己的 kube-proxy。与 rc 或者 rs 不同，这两个会随机地分布在整个集群中，比如副本数量为 5，一共有 4 个节点，可能会在节点 1 创建两个副本，节点 2 创建 1 个副本，节点 4 创建 2 个副本，但 DaemonSet 会保证这 4 个节点各自都有一个副本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ssd-monitor</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment"># DaemonSet 会对标签为 app=ssd-monitor 的 pod 进行管理</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">ssd-monitor</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span> <span class="hljs-comment"># 这个标签不能省略，且必须与上面的 matchLabels 相同，否则 create 会报错</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">ssd-monitor</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br></code></pre></td></tr></table></figure><p>ps：因为书上提供的镜像都是 x86 的，在我的机器上无法运行，所以把镜像替换为了 nginx，反正只是学习，也无所谓了</p><p>书上的 template.spec 下其实还有一个 nodeSelector，值为 disk&#x3D;ssd，代表该 ds 只会在标签为 disk&#x3D;ssd 的节点上创建、管理 pod，这里偷懒了没写，不然还要给节点添加标签。</p><p>如果将一个已经运行 ds 创建的 pod 的节点的标签改掉，比如上面的例子中，将节点的标签 disk&#x3D;ssd 改为 dsik&#x3D;hdd，那么先前已经创建好的 ds pod 会被终止。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s ReplicaSet</title>
    <link href="/2022/05/07/k8s-replicaset/"/>
    <url>/2022/05/07/k8s-replicaset/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 本篇笔记摘自 《Kubernetes in Aciton 》</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ReplicaSet（简称 rs） 是 ReplicationController （简称 rc）的升级版，它的标签选择器功能更加强大。</p><h1 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h1><p>使用 selector.matchExpressions 进行标签选择，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">selector:</span><br><span class="hljs-attr">matchExpressions:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><span class="hljs-comment"># 此选择器要求该 pod 包含名为 “app” 的标签</span><br><span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br><span class="hljs-attr">values:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">kubia</span><span class="hljs-comment"># 标签的值必须是 &quot;kubia&quot;</span><br></code></pre></td></tr></table></figure><p>其中，key 和 operator 是必须的，values 可能为空，也可能为多个值，运算符有以下几个：</p><ul><li>In : Label 的值必须与其中一个指定的 values 匹配。</li><li>Notln : Label 的值与任何指定的 values 不匹配。</li><li>Exists : pod 必须包含一个指定名称的标签(值不重要)。使用此运算符时，不应该指定 values 字段。</li><li>DoesNotExist : pod 不得包含有指定名称的标签。values 属性不得指定 。不应指定 values字段。</li><li>DoesNotExist : pod不得包含有指定名称的标签。values属性不得指定 。</li></ul><p>如果你指定了多个表达式，则所有这些表达式都必须为 true 才能使选择器与 pod 匹配。如果同时指定matchLabels 和 matchExpressions，则所有标签都必须匹配，并且所有表达式必须计算为 true 以使该 pod 与选择器匹配。</p><p>例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">selector:</span><br>  <span class="hljs-attr">matchLabels:</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">matchExpressions:</span><br>    <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">tier</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">cache</span>]&#125;<br>    <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-string">environment</span>, <span class="hljs-attr">operator:</span> <span class="hljs-string">NotIn</span>, <span class="hljs-attr">values:</span> [<span class="hljs-string">dev</span>]&#125;<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="rs-是否会抢占-rc-的-pod"><a href="#rs-是否会抢占-rc-的-pod" class="headerlink" title="rs 是否会抢占 rc 的 pod"></a>rs 是否会抢占 rc 的 pod</h2><p>现在有 3 个 rc 创建的 pod，标签都为 app&#x3D;kubia，容器为 nginx、数量为 3 ，如果此时使用 rs 创建条件相同的 pod 会怎样？会直接将 rc 的 3 个容器抢过来吗？</p><p>rs 的 yaml 如下：</p><p>kubia-replicaset.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>创建 rs：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-replicaset.yaml</span><br></code></pre></td></tr></table></figure><p>查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          13h<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-dg2j8   1/1     Running   0          17m<br>kubia-vdrf6   1/1     Running   0          10m<br>kubia-cq4wt   1/1     Running   0          10m<br>kubia-qx467   1/1     Running   0          10m<br></code></pre></td></tr></table></figure><p>发现 k8s 又新创建了 3 个 pod，通过 kubectl describe 可以看到每个 pod 的管理者，<code>kubia-qb26r</code> 显示的是：<code>Controlled By:  ReplicationController/kubia</code>，<code>kubia-qx467</code> 显示的是：<code>Controlled By:  ReplicaSet/kubia</code>，说明 rs 不会抢占 rc 的 pod。</p><h2 id="脱离-rc-管理的-pod-会被-rs-接管吗"><a href="#脱离-rc-管理的-pod-会被-rs-接管吗" class="headerlink" title="脱离 rc 管理的 pod 会被 rs 接管吗"></a>脱离 rc 管理的 pod 会被 rs 接管吗</h2><p>还是和上面的条件一样，有 3 个 rc 创建的 pod，并且标签都为 app&#x3D;kubia，先删除之前创建的 rs，这会一并删除其创建的 3 个 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rs kubia</span><br>replicaset.apps &quot;kubia&quot; deleted<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          13h<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-dg2j8   1/1     Running   0          20m<br></code></pre></td></tr></table></figure><p>删除之前的 rc，注意添加 –cascade&#x3D; false 来避免删除 pod（有个警告，意思 –cascade&#x3D;false 被废弃了，应该替换为 cascade&#x3D;orphan，查了下 orphan 是孤儿的意思，挺贴切的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rc kubia --cascade=<span class="hljs-literal">false</span></span><br>warning: --cascade=false is deprecated (boolean value) and can be replaced with --cascade=orphan.<br>replicationcontroller &quot;kubia&quot; deleted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-dg2j8   1/1     Running   0          28m<br>kubia-qb26r   1/1     Running   0          13h<br></code></pre></td></tr></table></figure><p>再创建之前的 rs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f kubia-replicaset.yaml</span><br>replicaset.apps/kubia created<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>nginx         1/1     Running   0          20h<br>kubia-dg2j8   1/1     Running   0          30m<br>kubia-d9xc6   1/1     Running   0          13h<br>kubia-qb26r   1/1     Running   0          13h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod kubia-dg2j8</span><br>Name:         kubia-dg2j8<br>Labels:       app=kubia<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略</span><br>Controlled By:  ReplicaSet/kubia<br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略</span><br></code></pre></td></tr></table></figure><p>可以看到 rs 会直接接管这 3 个脱离 rc 管理的 pod。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s ReplicationController</title>
    <link href="/2022/05/06/k8s-replicationcontroller/"/>
    <url>/2022/05/06/k8s-replicationcontroller/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇笔记摘自 《Kubernetes in Aciton 》</p></blockquote><p>ReplicationController 通过标签选择器（selector）与 pod 相关联。可以通过修改一个 pod 的标签将其移出 ReplicationController 的管理，或者移入到另一个 ReplicationController。</p><p><strong>查看所有的 ReplicationController</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get rc</span><br>NAME    DESIRED   CURRENT   READY   AGE<br>kubia   2         2         2       39m<br></code></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>按照书上的 yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br><span class="hljs-attr">spec:</span><br>        <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>        <span class="hljs-attr">selector:</span><br>                <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><br>        <span class="hljs-attr">template:</span><br>                <span class="hljs-attr">metadata:</span><br>                        <span class="hljs-attr">labels:</span><br>                                <span class="hljs-attr">app:</span> <span class="hljs-string">kubia</span><span class="hljs-comment"># 这里需要与 selectro 中的标签保持一致</span><br>                <span class="hljs-attr">spec:</span><br>                        <span class="hljs-attr">containers:</span><br>                        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>                          <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia</span><br>                          <span class="hljs-attr">ports:</span><br>                          <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>发现无法运行 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME          READY   STATUS             RESTARTS         AGE<br>kubia-25mrj   0/1     CrashLoopBackOff   22 (3m22s ago)   92m<br>kubia-x4dd8   0/1     CrashLoopBackOff   22 (3m11s ago)   92m<br>kubia-8gdfz   0/1     CrashLoopBackOff   22 (2m45s ago)   92m<br></code></pre></td></tr></table></figure><p>打印一下日志看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs kubia-25mrj</span><br>standard_init_linux.go:228: exec user process caused: exec format error<br></code></pre></td></tr></table></figure><p>查了一下，貌似是因为 luksa&#x2F;kubia 这个镜像是 x86 的，而我的电脑是 arm 的，所以导致容器无法运行</p><p>可以将其换成 nginx:alpine</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get po<br>NAME          READY   STATUS        RESTARTS   AGE<br>kubia-fcf4d   1/1     Running       0          16s<br>kubia-d9xc6   1/1     Running       0          16s<br>kubia-qb26r   1/1     Running       0          16s<br></code></pre></td></tr></table></figure><p>尝试删除一个 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete pod kubia-fcf4d</span><br>pod &quot;kubia-fcf4d&quot; deleted<br></code></pre></td></tr></table></figure><p>再次查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS        RESTARTS   AGE<br>nginx         1/1     Running       0          7h12m<br>kubia-d9xc6   1/1     Running       0          3m6s<br>kubia-qb26r   1/1     Running       0          3m6s<br>kubia-6lp8k   1/1     Running       0          23s<br></code></pre></td></tr></table></figure><p>发现 ReplicationController 又新创建了一个 pod，在最下方的 kubia-6lp8k</p><h2 id="修改标签实验"><a href="#修改标签实验" class="headerlink" title="修改标签实验"></a>修改标签实验</h2><p>先看一下当前的 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-d9xc6   1/1     Running   0          20m<br>kubia-qb26r   1/1     Running   0          20m<br>kubia-6lp8k   1/1     Running   0          17m<br></code></pre></td></tr></table></figure><p>修改一个 pod 的 label：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po kubia-d9xc6 app=kubia1 --overwrite</span><br>pod/kubia-d9xc6 labeled<br></code></pre></td></tr></table></figure><p>再次查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          21m<br>kubia-6lp8k   1/1     Running   0          18m<br>kubia-d9xc6   1/1     Running   0          21m<br>kubia-mnfft   1/1     Running   0          4s<br></code></pre></td></tr></table></figure><p>发现此时又新创建了一个 pod</p><p>使用 kubectl describe 查看 kubia-d9xc6，发现 Controlled By:  ReplicationController&#x2F;kubia 这句话消失了，说明该 pod 当前已经不由任何 ReplicationController 管理了。</p><p><strong>问题来了</strong>，如果把 kubia-d9xc6 的标签再改回去会怎么样？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po kubia-d9xc6 app=kubia --overwrite</span><br>pod/kubia-d9xc6 unlabeled<br></code></pre></td></tr></table></figure><p>这个 unlabeled 没太搞懂，但是 describe 查看发现还是更改成功了。</p><p>此时再查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          26m<br>kubia-6lp8k   1/1     Running   0          24m<br>kubia-d9xc6   1/1     Running   0          26m<br></code></pre></td></tr></table></figure><p>发现先前新创建的 pod 又被删除了。</p><p>看来 ReplicationController 会始终保证 pod 符合指定数量，多删少补。</p><h1 id="水平缩放"><a href="#水平缩放" class="headerlink" title="水平缩放"></a>水平缩放</h1><p>可以改变 spec.replicas 来变更 pod 的数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl edit rc kubia</span><br></code></pre></td></tr></table></figure><p>此时会打开一个 vim，将 spec.replicas 修改为 2，esc + :wq 退出，退出后 k8s 会自动更新，输出：<code>replicationcontroller/kubia edited</code>，此时再查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po</span><br>NAME          READY   STATUS    RESTARTS   AGE<br>kubia-qb26r   1/1     Running   0          37m<br>kubia-d9xc6   1/1     Running   0          37m<br></code></pre></td></tr></table></figure><p>可以看到 pod 的数量已经缩减到 2 个了</p><p>同样也可以用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl scale rc kubia --replicas=2</span><br></code></pre></td></tr></table></figure><h1 id="删除-rc"><a href="#删除-rc" class="headerlink" title="删除 rc"></a>删除 rc</h1><p>使用下面的命令进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete rc [rcName]</span><br></code></pre></td></tr></table></figure><p>删除 rc 会一并删除其所管理的 pod，不过不想这么做，则需要添加 <code>--cascade=false</code> 选项。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s 存活探针</title>
    <link href="/2022/05/06/k8s-cun-huo-tan-zhen/"/>
    <url>/2022/05/06/k8s-cun-huo-tan-zhen/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇笔记摘自 《Kubernetes in Aciton 》4.1 保持 pod 健康</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>k8s 会 <strong>检测 pod 中的容器</strong> 是否正常工作，如果容器的主线程奔溃，那么 k8s 会自动重启该容器，对于开发者而言，无需对应用程序任何额外操作便获得了自动修复的能力，但有时容器没有奔溃也不一定就代表正常，比如遇到了死锁问题，此时虽然容器不会奔溃，但是整个程序已经完全卡死无法继续工作了，针对这种情况，k8s 提供了一个 <strong>存活探针</strong> 功能。</p><p><strong>存活探针</strong> 会检查容器是否正常工作，如果探测失败， k8s 将定期执行探针并重新启动容器。</p><p><strong>存活探针</strong> 有以下几种机制：</p><ol><li><p>HTTP，对容器进行 HTTP 访问（端口和路由需要自己指定），根据返回码来判断是否正常工作（2xx，3xx代表正常，其他代表错误），如果长时间未响应也同样代表无法正常工作。</p></li><li><p>TCP socket，对容器的指定端口建立 TCP 连接，如果建立成功则代表存活，否则容器重新启动。</p></li><li><p>Exec，在容器内部执行任意命令，并检查命令的退出状态码。如果状态码是 0, 则探测成功。所有其他状态码都被认为失败。</p></li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="使用-http-方式"><a href="#使用-http-方式" class="headerlink" title="使用 http 方式"></a>使用 http 方式</h2><p>实践会创建一个基于 HTTP 的存活探针。</p><p>yaml 文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">kubia-liveness</span><br><span class="hljs-attr">spec:</span><br>        <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia-unhealthy</span> <span class="hljs-comment"># 这个镜像包含了不知道怎么坏掉的应用</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br>          <span class="hljs-attr">livenessProbe:</span><br>                  <span class="hljs-attr">httpGet:</span>      <span class="hljs-comment"># 一个 HTTP GET 存活探针</span><br>                          <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>       <span class="hljs-comment"># HTTP 请求的路径</span><br>                          <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>    <span class="hljs-comment"># 探针连接的网络端口</span><br></code></pre></td></tr></table></figure><p>创建后，查看 pod 状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">kubectl get pods</span><br>NAME             READY   STATUS             RESTARTS       AGE<br>kubia-liveness   0/1     CrashLoopBackOff   16 (21s ago)   60m<br></code></pre></td></tr></table></figure><p>RESTARTS 代表重启次数，上面重启了 16 次，说明 k8s 一直在尝试自动修复，只是这个镜像会在重启后不久坏掉，导致一直在重启（为了演示刻意而为之，这个镜像会正确处理前 5 个 HTTP 请求，之后每个请求都会返回 500，导致探针检测失败而重启）</p><blockquote><p>注意：当容器被强行终止时，会创建一个全新的容器——而不是重启原来的容器。</p></blockquote><blockquote><h2 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h2><p>官方文档里说，http 存活指针的判断依据是：返回大于或等于 200 并且小于 400 的任何代码都标示成功，其它返回代码都标示失败。那如果整个容器都挂掉了，不会返回任何状态码，此时会如何处理呢？是超时未收到回复后就自动判定为未存活吗？这个需要自己实践一下（ps：官方文档包括一些书籍里面提供了现成的镜像，但是这些镜像基本都是 amd64 的，在我的 m1 上无法成功运行，所以有点麻烦，需要自己写代码，然后 docker build，再 push 到 hub，）</p></blockquote><h2 id="如果-pod-中有多个容器，如何检测"><a href="#如果-pod-中有多个容器，如何检测" class="headerlink" title="如果 pod 中有多个容器，如何检测"></a>如果 pod 中有多个容器，如何检测</h2><p>可以使用存活探针，为每个容器设置不同的探测方案，比如可以使用 tcp 探针，让 pod 中的每个容器暴露一个端口，然后存活探针分别尝试与这些端口建立连接，如果其中有一个端口建立连接失败，则说明容器出现了问题，然后 k8s 就会删除这个有问题的 pod，并新建一个相同的 pod 替代。</p><p><strong>待实践</strong></p><h1 id="查看-pod-探针"><a href="#查看-pod-探针" class="headerlink" title="查看 pod 探针"></a>查看 pod 探针</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl describe pod kubia-liveness</span><br>Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3<br></code></pre></td></tr></table></figure><p>delay&#x3D;0s 表示在容器启动后立即开始探测，timeout&#x3D;1s 表示容器必须在 1s 内对探针做出响应，period&#x3D;10s 代表每 10s 进行一次探测，failure&#x3D;3 表示累计失败 3 次则视为容器无法正常工作。success&#x3D;1 书中没有说明，不过应该可以猜到是代表探针成功一次便视为容器可以正常工作。</p><p>对于一些比较重的应用，启动可能需要较长的时间，此时将 delay 设置为 0 就不太合适了，可能程序都还没跑起来，探针却已经探测过好几次了，导致错误的重启当前容器。通过 livenessProbe 下的 initialDelaySeconds 进行设置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s pod</title>
    <link href="/2022/05/04/k8s-pod-bi-ji/"/>
    <url>/2022/05/04/k8s-pod-bi-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇笔记摘自 《Kubernetes in Aciton 》第三章：<code>pod：运行于 Kubernetes 中的容器</code></p></blockquote><h1 id="什么是-pod"><a href="#什么是-pod" class="headerlink" title="什么是 pod"></a>什么是 pod</h1><p>pod 是 k8s 的最基本构建模块，他是多个容器的集合（当然也可以只有1个容器），一个 pod 里的所有容器都会运行在同一个节点上，不存在一个 pod 中的容器 A 在节点 1 运行，容器 B 在节点 2 运行这种情况。</p><p><strong>为何不将所有进程放到一个容器中？</strong></p><p>容器被设计为每个容器只运行一个进程(除非进程本身产生子进程)。 如果在单个容器中运行多个不相关的进程，那么保持所有进程运行、 管理它们的日志等将会是我们的责任。 例如，我们需要包含一种在进程崩溃时能够自动重启的机制。同时这些进程都将记录到相同的标准输出中， 而此时我们将很难确定每个进程分别记录了什么。</p><p>综上所述， 我们需要让每个进程运行在自己的容器中， 而这就是 Docker 和 Kubernetes 期望使用的方式。</p><p><strong>隔离性</strong>：pod 中的容器互相之间并不是完全隔离的，它们共享相同的主机名和网络接口，也能使用 ipc 进行通信。进程和文件系统也可以共享，但这两个需要做一些额外的操作。因为共享网络接口，所以也共享相同的 IP 地址和端口，这代表一个 pod 中不同容器的进程不能绑定到同一个端口号，此外容器可以通过 localhost 与同一 pod 中的其他容器进行通信。</p><p><strong>pod 间通信</strong>：k8s 集群中的所有 pod 都在同一个共享网络地址空间中，所以 pod 间可以通过 IP 进行相互访问</p><p><strong>总结</strong>：pod 类似于一台物理机或者虚拟机，只是其每个进程都封装在一个容器中，同时比较轻量，开销小</p><h1 id="通过-pod-合理管理容器"><a href="#通过-pod-合理管理容器" class="headerlink" title="通过 pod 合理管理容器"></a>通过 pod 合理管理容器</h1><h2 id="每个-pod-只包含紧密相关的组件或进程"><a href="#每个-pod-只包含紧密相关的组件或进程" class="headerlink" title="每个 pod 只包含紧密相关的组件或进程"></a>每个 pod 只包含紧密相关的组件或进程</h2><p>pod 有一条总的原则：应该将应用程序组织到多个 pod 中， 而 <strong>每个 pod 只包含紧密相关的组件或进程</strong>，而不是将所有程序都放到一个 pod。</p><p>原因有几下几点：</p><ol><li><strong>最大程度利用节点</strong>，比如现在有一个前端应用和一个后端应用，以及一个双节点的 k8s 集群，此时应该将前端 pod 放到一个节点，后端 pod 放到另一个节点，而不是将前后端放到一个 pod 中。</li><li><strong>方便扩缩容</strong>，pod 是 k8s 的扩缩容基本单位，它只能扩缩整个 pod，不能扩缩某个容器，如果一个 pod 中同时存放了前后端程序，那么如果发生扩容，会导致前后端同时扩容，但可能我只想让后端进行扩容（这是很正常的，毕竟前后端的需求不同）。</li></ol><h2 id="何时在-pod-中使用多个容器"><a href="#何时在-pod-中使用多个容器" class="headerlink" title="何时在 pod 中使用多个容器"></a><strong>何时在 pod 中使用多个容器</strong></h2><p>举个例子：有两个容器，一个负责对外提供文件访问服务，一个负责从外部下载资源到文件（sidecar容器），这两个容器间是紧密关联的，此时便可以放到一个 pod 中。</p><h2 id="如果一个-pod-中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？"><a href="#如果一个-pod-中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？" class="headerlink" title="如果一个 pod 中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？"></a>如果一个 pod 中存在多个容器，而其中有一个容器挂掉了，此时会如何处理？</h2><p>可以使用存活探针，为每个容器设置不同的探测方案，比如可以使用 tcp 探针，让 pod 中的每个容器暴露一个端口，然后存活探针分别尝试与这些端口建立连接，如果其中有一个端口建立连接失败，则说明容器出现了问题，然后 k8s 就会删除这个有问题的 pod，并新建一个相同的 pod 替代。</p><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p><strong>查看一个 pod 的 yaml 定义</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po [pod name] -o [yaml|json]</span><br></code></pre></td></tr></table></figure><p>-o 可以输入 yaml 或者 json</p><p><strong>查看 pod yaml 的字段含义</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl explain pods</span><br></code></pre></td></tr></table></figure><p><strong>创建 pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl [create|apply] -f [srcFile]</span><br></code></pre></td></tr></table></figure><p>通过 srcFile 来创建 pod，该文件可以是 yaml 或者 json</p><p>**查看当前的 pod **</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br></code></pre></td></tr></table></figure><p><strong>获取 pod 日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs [podName]</span><br></code></pre></td></tr></table></figure><p>获取指定容器的日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl logs [podName] -c [containerName]</span><br></code></pre></td></tr></table></figure><p><strong>更新 pod</strong></p><p>修改 yaml 后重新执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f [srcFile]</span><br></code></pre></td></tr></table></figure><p>这只适用于更改 Pod 中容器（包括工作容器与初始化容器）的镜像，以及 activeDeadlineSeconds （对 Job 类型的 Pod 定义失败重试的最大时间）， tolerations （Pod 对污点的容忍）</p><p>如果是其他情况，则需要删除后重新创建容器</p><blockquote><p>Kubernetes 对 Pod 的更新做了限制，除了更改 Pod 中容器（包括工作容器与初始化容器）的镜像，以及 activeDeadlineSeconds （对 Job 类型的 Pod 定义失败重试的最大时间）， tolerations （Pod 对污点的容忍），修改其它部分将不会产生作用，如我们可以尝试在前面 Pod 定义文档 pod-test.yaml 中将宿主机端口 8081 改为 8082，重新执行 <code>kubectl apply</code>， 将提示如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">The Pod &quot;nginx&quot; is invalid: spec: Forbidden: pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds`, `spec.tolerations` (only additions to existing tolerations) or `spec.terminationGracePeriodSeconds` (allow it to be set to 1 if it was previously negative)<br></code></pre></td></tr></table></figure></blockquote><p><strong>删除 pod</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl delete [podName]</span><br></code></pre></td></tr></table></figure><h1 id="pod-提供对外访问"><a href="#pod-提供对外访问" class="headerlink" title="pod 提供对外访问"></a>pod 提供对外访问</h1><p>对外访问 pod 的最普遍方式是使用 service，但 service 是一个相当重要的内容，所以会另起一篇笔记，在本篇笔记中只会记录除 service 外的方式，这些方式并不常用，仅作为记录。</p><h2 id="hostNetwork"><a href="#hostNetwork" class="headerlink" title="hostNetwork"></a>hostNetwork</h2><p>在 yaml 中添加 hostNetwork: true 字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>执行 yaml：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f hostnetwork.yaml</span><br></code></pre></td></tr></table></figure><p>查看 pod：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -o wide</span><br>NAME      READY   STATUS    RESTARTS   AGE   IP             NODE       NOMINATED NODE   READINESS GATES<br>nginx     1/1     Running   0          18m   192.168.49.2   minikube   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><p>此时通过 pod IP 就可以进行访问了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl 192.168.49.2</span><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h2 id="HostPort"><a href="#HostPort" class="headerlink" title="HostPort"></a>HostPort</h2><p>参考 <strong>pod 实战</strong> 部分</p><h2 id="port-forward"><a href="#port-forward" class="headerlink" title="port-forward"></a>port-forward</h2><p>使用 kubectl 自带的端口转发命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward [podName] [对外暴露的端口]:[pod内部端口]</span><br></code></pre></td></tr></table></figure><p>比如在我的电脑上实践（访问这个 pod 会输出一句谚语，参考书上的 p168）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl port-forward fortune 8080:80</span><br>Forwarding from 127.0.0.1:8080 -&gt; 80<br>Forwarding from [::1]:8080 -&gt; 80<br></code></pre></td></tr></table></figure><p>此时上面的 shell 会阻塞，新开一个 shell，执行 curl：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://localhost:8080</span><br>Q:How many psychiatrists does it take to change a light bulb?<br>A:Only one, but it takes a long time, and the light bulb has<br>to really want to change.<br></code></pre></td></tr></table></figure><blockquote><p>🤔️ 疑问：</p><p>1）curl 必须要添加 http 协议才行，如果只是 curl localhost 8080 会报错：curl: (7) Failed to connect to localhost port 80: Connection refused，这是为什么？</p><p>😅 格式错误，应该是 curl localhost:8080，curl <a href="http://localhost:8080/">http://localhost:8080</a> 和 curl localhost:8080 实际是一样的</p><p>2）此外，我在宿主机用 curl 虚拟机IP:8080 也无法成功访问，只有在虚拟机内部才行</p></blockquote><h1 id="pod-实战"><a href="#pod-实战" class="headerlink" title="pod 实战"></a>pod 实战</h1><p>通过实战创建一个 nginx pod</p><p>nginx yaml 如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">hostPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>创建 pod</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl apply -f nginx_pod.yaml</span><br></code></pre></td></tr></table></figure><p>等待一会，直到创建完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get pods</span><br>NAME    READY   STATUS              RESTARTS   AGE<br>nginx   0/1     ContainerCreating   0          2s<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME    READY   STATUS    RESTARTS   AGE<br>nginx   1/1     Running   0          2m17s<br></code></pre></td></tr></table></figure><p>在 yaml 中设置了 <code>hostPort</code> 为 8080，代表对外暴露 8080 端口，映射到容器内部的 80 端口，此时便可以通过 IP:8080 进行访问了，如果不设置 <code>hostPort</code>，那么需要使用 <code> kubectl exec -it nginx sh</code>  进入容器内部，执行 <code> curl localhost</code>，可以看到 nginx 欢迎页的 HTML 代码。</p><p><img src="https://autsu.github.io/post-images/1651804699715.jpg"></p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>标签用来为 pod 进行分类。</p><p>有几种方式可以为 pod 创建标签：</p><ol><li>在 yaml 中的 metadata labels 中指定，标签是 key:value 的方式，key 需要全局唯一，比如在上面 nginx yaml 中，添加了一个 app: nginx 标签。</li><li>使用 <code>kubectl label po nginx key=value</code> 添加标签</li></ol><p>pod 的 key 必须唯一，否则报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po nginx key=value1</span><br>error: &#x27;key&#x27; already has a value (value), and --overwrite is false<br></code></pre></td></tr></table></figure><p>查看 pod 的所有标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po --show-labels</span><br>NAME    READY   STATUS    RESTARTS   AGE    LABELS<br>nginx   1/1     Running   0          118m   app=nginx,key=value<br></code></pre></td></tr></table></figure><p>查看 pod 的某个标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -L app,key</span><br>NAME    READY   STATUS    RESTARTS   AGE    APP     KEY<br>nginx   1/1     Running   0          120m   nginx   value<br></code></pre></td></tr></table></figure><p>修改 pod 的标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label po nginx key=value1 --overwrite</span><br>pod/nginx labeled<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po --show-labels</span><br>NAME    READY   STATUS    RESTARTS   AGE    LABELS<br>nginx   1/1     Running   0          122m   app=nginx,key=value1<br></code></pre></td></tr></table></figure><p>指定 <code>--overwrite</code> 进行修改</p><h1 id="将-pod-调度到特定节点"><a href="#将-pod-调度到特定节点" class="headerlink" title="将 pod 调度到特定节点"></a>将 pod 调度到特定节点</h1><p>可以为某个 node 设置一个标签，然后在 pod yaml 中指定 spec.nodeSelector ，保证 pod 被调度到符合其需求的节点。</p><p>通过以下命令为 node 设置标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl label node [nodeName] [key=value]</span><br></code></pre></td></tr></table></figure><p>pod yaml 指定被调度节点：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">vl</span> <br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span> <br><span class="hljs-attr">metadata:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">kubia-gpu</span> <br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">nodeSelector:</span><br><span class="hljs-attr">gpu:</span> <span class="hljs-string">&quot;true&quot;</span> <br><span class="hljs-attr">containers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">luksa/kubia</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">kubia</span><br></code></pre></td></tr></table></figure><p>以上会保证该 pod 被调度到 gpu&#x3D;true 的节点上，通过 nodeSelector 指定。</p><h1 id="pod-如何调度"><a href="#pod-如何调度" class="headerlink" title="pod 如何调度"></a>pod 如何调度</h1><p>之前实验使用的都是单节点方式，所以没在意 pod 是如何调度的，后来用 kind 搭建了一个 3 节点的 k8s 集群后才意识到这个问题，所以做了一个实验：</p><p>当前集群的 node：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get node -o wide | awk <span class="hljs-string">&#x27;&#123;printf &quot;%-30s%-15s\n&quot;, $1, $6&#125;&#x27;</span></span><br>NAME                          INTERNAL-IP<br>kind-control-plane            172.18.0.2<br>kind-worker                   172.18.0.4<br>kind-worker2                  172.18.0.3<br></code></pre></td></tr></table></figure><p>创建 3 个 nginx pod（使用 deployment）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br></code></pre></td></tr></table></figure><p>查看 po：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl get po -o wide | awk <span class="hljs-string">&#x27;&#123;printf &quot;%-30s%-15s\n&quot;, $1,$9&#125;&#x27;</span></span><br>NAME                          NODE<br>nginx-66b9cc684d-8l7hg        kind-worker2<br>nginx-66b9cc684d-flj48        kind-worker<br>nginx-66b9cc684d-hxzc9        kind-worker<br></code></pre></td></tr></table></figure><p>发现这三个 pod 都被调度到 worker 节点，没有被调度到 <code>kind-control-plane</code> 节点，网上查阅资料，得知 pod 的调度是由 kube-scheduler 来执行的，有一系列规则来完成这件事，比如官方文档里所描述的：</p><blockquote><p>kube-scheduler 给一个 pod 做调度选择包含两个步骤：</p><ol><li>过滤</li><li>打分</li></ol><p>过滤阶段会将所有满足 Pod 调度需求的 Node 选出来。 例如，PodFitsResources 过滤函数会检查候选 Node 的可用资源能否满足 Pod 的资源请求。 在过滤之后，得出一个 Node 列表，里面包含了所有可调度节点；通常情况下， 这个 Node 列表包含不止一个 Node。如果这个列表是空的，代表这个 Pod 不可调度。</p><p>在打分阶段，调度器会为 Pod 从所有可调度节点中选取一个最合适的 Node。 根据当前启用的打分规则，调度器会给每一个可调度节点进行打分。</p><p>最后，kube-scheduler 会将 Pod 调度到得分最高的 Node 上。 如果存在多个得分最高的 Node，kube-scheduler 会从中随机选取一个。</p></blockquote><p>鉴于目前实力有限，无法摸清具体的流程，待我日后研究再详细展开（）</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode 选中文本时滑动速度过快</title>
    <link href="/2022/04/10/vscode-xuan-zhong-wen-ben-shi-hua-dong-su-du-guo-kuai/"/>
    <url>/2022/04/10/vscode-xuan-zhong-wen-ben-shi-hua-dong-su-du-guo-kuai/</url>
    
    <content type="html"><![CDATA[<p>这是一个困扰我已久的问题，当选中一段代码并继续向下滑动时，滑动速度会非常快，导致无法准确选中我想要的部分，比如我的屏幕能显示200行代码，我想选中1-250行的代码，这就需要我向下滑动来选中剩余的50行，但是因为速度太快，导致我轻轻一滑就会瞬间跑到第800行代码的位置，于是我又要向上滑动，结果又瞬间到了第150行，非常令人蛋疼。</p><p>在网上用中文搜索不到相关的问题，没办法只能用我蹩脚的英文搜索 vscode scroll too fast selecting，没想到还找出来不少，看来有时候还是得用英文搜索才能解决问题。<a href="https://github.com/microsoft/vscode/issues/40890">https://github.com/microsoft/vscode/issues/40890</a> 这里描述了同样的问题，但是里面的解决方案都对我无效，像 <code>&quot;editor.smoothScrolling&quot;: true</code>，<code>editor.mouseWheelScrollSensitivity:0.1</code> 这些都不行，似乎 vscode 本身也没有提供一个专门针对选中后滑动速度的选项。</p><p>最后在 <a href="https://stackoverflow.com/questions/44374762/visual-studio-code-scroll-speed-too-fast-for-selecting-with-mouse">https://stackoverflow.com/questions/44374762/visual-studio-code-scroll-speed-too-fast-for-selecting-with-mouse</a> 这里找到了一个将将就的解决方案:</p><blockquote><p>While not a solution to the scroll speed issue, there is a rather trivial<br>workaround. Select part of the region you want selected, scroll down to the point<br>the region to select ends and Shift-Click. Voila, whole region selected.</p></blockquote><p>意思就是先选中一小部分文字，然后松开鼠标&#x2F;触控板，然后向下滑动到要选择内容的末尾，再 shift + 左键点击此处，即可完成区域选择。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k3s 踩坑记录</title>
    <link href="/2022/04/08/k3s/"/>
    <url>/2022/04/08/k3s/</url>
    
    <content type="html"><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -s - --write-kubeconfig-mode 666<br></code></pre></td></tr></table></figure><p>–write-kubeconfig-mode设置读写权限，否则每次 kubectl 都要 sudo，同时使用国内镜像进行下载</p><h1 id="设置镜像"><a href="#设置镜像" class="headerlink" title="设置镜像"></a>设置镜像</h1><p>参考 <a href="https://blog.csdn.net/xs20691718/article/details/106515605">https://blog.csdn.net/xs20691718/article/details/106515605</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1</span><br>cp /var/lib/rancher/k3s/agent/etc/containerd/config.toml /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl # 拷贝一份配置文件<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2</span><br>sudo vim /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 config.toml.tmpl 文件中添加</span><br>[plugins.cri.registry.mirrors]<br>  [plugins.cri.registry.mirrors.&quot;docker.io&quot;]<br>    endpoint = [&quot;https://docker.mirrors.ustc.edu.cn&quot;]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3 重启服务</span><br>systemctl restart k3s<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 查看修改是否成功</span><br>sudo crictl info | grep mirror<br><br><br></code></pre></td></tr></table></figure><h1 id="创建-pod-一直处于-pending-状态"><a href="#创建-pod-一直处于-pending-状态" class="headerlink" title="创建 pod 一直处于 pending 状态"></a>创建 pod 一直处于 pending 状态</h1><p>一开始以为是污点问题，因为 pod 描述中有 warning 警告：0&#x2F;1 nodes are available: 1 node(s) had taint {node.kubernetes.io&#x2F;not-ready: }, that the pod didn’t tolerate.，使用 <code> kubectl describe node [nodename]</code> 查看，发现节点的污点为 <code>:NoSchedule</code>，而 pod 的 Tolerations 是 <code>:NoExecute</code>，先尝试移除节点的污点，使用 <code>kubectl taint nodes node1 key1:NoSchedule-</code> 进行移除，但是移除后执行 <code>kubectl get no -o yaml | grep taint -A 5</code> 发现依然显示有污点（正常应该输出为空），难道是移除污点失效了吗？网上也查不到任何相关资料，于是又尝试更改 pod 的容忍度，修改 yaml 文件，添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tolerations:<br>      - key: &quot;node.kubernetes.io/disk-pressure&quot;<br>        operator: &quot;Exists&quot;<br>        effect: &quot;NoSchedule&quot;<br></code></pre></td></tr></table></figure><p>之后再重新执行 <code>kubectl apply -f </code>  重新创建 pod，发现还是无效。最后重启了一下 k3s ，然后莫名其妙的发现 pod 创建成功了，此时再查看 node 描述信息，发现 taint 为 none 了。</p><p>一开始的 pod 描述信息中还有一条错误信息： kubernetes The node was low on resource: ephemeral-storage.” Evicted ，网上找了半天资料，也没有看到很好的解决方法（其实是我看不懂😅）</p><p>​&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 更新 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>破案了，注意 node 的污点 key 是 <code>node.kubernetes.io/disk-pressure</code>，查了一下这表示当前节点的磁盘容量不足，该污点会阻止 pod 被调度到该节点，且无法去除，这就是 pod 一直 pending 的原因，因为我使用的是 multipass 创建的虚拟机，默认只分配的 5G 的磁盘，所以很容易就满了，导致 k3s 出现这一污点，只要重新创建一个虚拟机并分配大一些的磁盘空间即可（也可以调整现有虚拟机的磁盘空间，但是有些麻烦，尝试无果后放弃了）</p><p>老实说第一次用这个 k3s，<del>感觉比 minikube 要难用很多，发生了不少莫名其妙的问题，不过</del>内存占用确实要低得多，暂且先摸索一下吧，刚好还学到了污点这个新知识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k3s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引</title>
    <link href="/2022/03/26/mysql-suo-yin/"/>
    <url>/2022/03/26/mysql-suo-yin/</url>
    
    <content type="html"><![CDATA[<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>索引类型分为主键索引和非主键索引。</p><p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1648609254561.webp"></p><p>比如在上图中，ID 就是聚簇索引，K 是非聚簇索引</p><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h1 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1648609254561.webp"></p><p>在上图中，如果执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p><ol><li><p>在 k 索引树上找到 k&#x3D;3 的记录，取得 ID &#x3D; 300；</p></li><li><p>再到 ID 索引树查到 ID&#x3D;300 对应的 R3；（因为查询的是 *，所以需要去主键索引处拿到整行的值）</p></li><li><p>在 k 索引树取下一个值 k&#x3D;5，取得 ID&#x3D;500；</p></li><li><p>再回到 ID 索引树查到 ID&#x3D;500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k&#x3D;6，不满足条件，循环结束。</p></li></ol><p>在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。<br>如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</p><p>比如上面的例子中，如果执行的语句是 <code>select ID from T where k between 3 and 5</code>，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Buffer Pool 的一些疑问记录</title>
    <link href="/2022/03/16/mysql-buffer-pool-de-yi-xie-yi-wen-ji-lu/"/>
    <url>/2022/03/16/mysql-buffer-pool-de-yi-xie-yi-wen-ji-lu/</url>
    
    <content type="html"><![CDATA[<p>这是我在看 Mysql <code>Buffer Pool</code> 时的一个疑问，先说说 Buffer Pool，为了提高性能，Mysql 为读写操作添加了一层缓存，这样就可以直接从内存中操作，速度相比操作硬盘要快很多，只要之后再将内存中的数据定期写入到磁盘中即可保证数据一致。但是这样就产生了一个问题：如果在内存写入到磁盘之前，Mysql 进程挂掉了，这样岂不是就丢失数据了？</p><p>通过网上查阅资料，了解了 Mysql 对于这种情况的解决方法：<code>redo log</code>，对内存中的数据进行的操作，会同步把对应的日志写入到 redo log 中，如果发生了上面的情况，可以通过查看 redo log 进行恢复，但是此时我又产生了几个疑问：</p><ol><li>这样不是还会发生上面的问题吗？如果内存中操作了，然后数据库进程挂掉了，没来得及写入到 redo log，那不是一样也发生丢失了吗？</li><li>引入 buffer pool 就是为了防止直接操作硬盘，现在又要同步写入到 redo log 中，等于还是要操作硬盘，那还有什么意义呢？</li></ol><p>查找的一些说法（不确定正不正确）：</p><ol><li>通过 WAL(Write Ahead Log，预写日志) 机制来保证不会发生上面的情况，即：写入日志一定发生在更新内存之前（关于 WAL 暂时也没有完全理解，所以这里标记为<strong>存疑</strong>）</li><li>写入 redo log 的方式使用了追加操作， 所以磁盘操作是 <strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是 <strong>随机写</strong>（具体可以参见硬盘的顺序读写和随机读写），磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go slice append 的坑 [存疑]</title>
    <link href="/2022/03/10/go-slice-append-de-keng-cun-yi/"/>
    <url>/2022/03/10/go-slice-append-de-keng-cun-yi/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>使用过 Go 的小伙伴应该都遇到过这样一个坑：当使用 slice 作为参数传递时，如果调用方函数内部发生了 append 操作，那么对应的改变不会在实参处体现出来，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>slice = fn(slice)<br>fmt.Println(<span class="hljs-string">&quot;[main] slice: &quot;</span>, slice)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> (s []<span class="hljs-type">int</span>) &#123;<br>  s = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>)<br>    fmt.Println(<span class="hljs-string">&quot;[func] slice: &quot;</span>, s)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[func]</span> slice:  <span class="hljs-comment">[1]</span><br><span class="hljs-comment">[main]</span> slice:  <span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>看过一些博客，里面阐述的原因是：slice 的底层数据结构是一个名为 <code>SliceHeader</code> 的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SliceHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>Cap  <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 Data 指向底层数组，将 slice 作为函数参数传递，实际上传递的就是这样一个结构体，而 append 可能会导致扩容，也就是重新分配一个更大的数组，将之前的数据拷贝过去，并且重新将 Data 指向这个新数组，因为传入的参数不是指针类型而是值类型，所以 Data 的改变不能体现在实参中。</p><p>听起来有些道理，那么就动手实践一下，看看实际情况如何：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 通过反射来获取 slice 对应的底层 SliceHeader 结构体</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSliceHeader</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, struc)<br><br>dataPtr := unsafe.Pointer(struc.Data)<br>fmt.Println(dataPtr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceAppend</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(<span class="hljs-string">&quot;[func] sliceHeader info: &quot;</span>)<br>getSliceHeader(slice)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[func] after append, sliceHeader.data: &quot;</span>, data)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader info: &quot;</span>)<br>getSliceHeader(n)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>sliceAppend(n)<br>fmt.Println(<span class="hljs-string">&quot;[main] after call, slice data: &quot;</span>, n)<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;n))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader.data&quot;</span>, data)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码看起来有些长，实际只是通过反射去拿到 slice 对应的 SliceHeader，并通过 unsafe 来获取 data 对应的底层数组，无需过多关注。</p><p>输出结果：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">[main] sliceHeader info: <br>&amp;&#123;Data:4336299344 Len:0 Cap:0&#125;<br><span class="hljs-section">0x10276ad50</span><br><span class="hljs-section">========================</span><br>[func] sliceHeader info: <br>&amp;&#123;Data:1374390272064 Len:4 Cap:4&#125;<br><span class="hljs-section">0x140000b4040</span><br><span class="hljs-section">========================</span><br><span class="hljs-meta">[func] after append, sliceHeader.data:  [1 2 3 4]</span><br><span class="hljs-meta">[main] after call, slice data:  []</span><br><span class="hljs-meta">[main] sliceHeader.data [0 0 0 0]</span><br></code></pre></td></tr></table></figure><p>main 里的 slice 是一个 len 和 cap 都为 0 的 slice，而函数内部需要 append 4 个元素，这势必会发生扩容，从上面的输出信息中也可以看出，data 指向的地址确实发生了改变，main 中 data 指向 0x10276ad50，而 func 中 data 指向了 0x140000b4040。</p><h1 id="新的疑问"><a href="#新的疑问" class="headerlink" title="新的疑问"></a>新的疑问</h1><p>在了解原因后，我又突发奇想，既然是因为扩容才导致的丢失，那我不让他扩容不就好了吗？在 make 时直接指定 cap 为 20，而函数内只 append 4 个元素，这样就不会扩容了，此时结果会如何？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSliceHeader</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, struc)<br><br>dataPtr := unsafe.Pointer(struc.Data)<br>fmt.Println(dataPtr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sliceAppend</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>)</span></span> &#123;<br>slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(<span class="hljs-string">&quot;[func] sliceHeader info: &quot;</span>)<br>getSliceHeader(slice)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[func] after append, sliceHeader.data: &quot;</span>, data)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader info: &quot;</span>)<br>getSliceHeader(n)<br>fmt.Println(<span class="hljs-string">&quot;========================&quot;</span>)<br><br>sliceAppend(n)<br>fmt.Println(<span class="hljs-string">&quot;[main] after call, slice data: &quot;</span>, n)<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;n))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;[main] sliceHeader.data&quot;</span>, data)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[main] sliceHeader info: <br>&amp;&#123;Data:1374390001664 Len:0 Cap:20&#125;<br>0x14000072000<br>========================<br>[func] sliceHeader info: <br>&amp;&#123;Data:1374390001664 Len:4 Cap:20&#125; # 注意这里的 Len<br>0x14000072000<br>========================<br>[func] after append, sliceHeader.data:  [1 2 3 4]<br>[main] after call, slice data:  []<br>[main] sliceHeader.data [1 2 3 4]<br></code></pre></td></tr></table></figure><p>可以看到，SliceHeader.Data 的指向确实没有发生改变，都是 0x14000072000，并且通过最后一句输出 <code>[main] sliceHeader.data [1 2 3 4]</code> 可以得知，底层的数组确实已经发生了改变，但是最终 main 的 slice 输出还是为空，这是为什么呢？</p><p>一个猜测：</p><p>我们在 main 函数调用 sliceAppend 之后在加入一段话：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">sliceAppend(n)<br>fmt.Println(<span class="hljs-string">&quot;[main] after call, slice data: &quot;</span>, n)<br>struc := (*reflect.SliceHeader)(unsafe.Pointer(&amp;n))<br>dataPtr := unsafe.Pointer(struc.Data)<br>data := *(*[<span class="hljs-number">4</span>]<span class="hljs-type">int</span>)(dataPtr)<br>fmt.Println(<span class="hljs-string">&quot;after call, sliceHeader info: &quot;</span>) <span class="hljs-comment">// 新增</span><br>getSliceHeader(n)<span class="hljs-comment">// 新增</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">after call, sliceHeader info:<br>&amp;&#123;Data:1374390730752 Len:0 Cap:20&#125;<br>data address: 0x14000124000<br></code></pre></td></tr></table></figure><p>发现在 append 之后，Len 依然为 0，难道这就是问题所在？fmt.Println 可能是检测到 slice 的 Len 为 0，所以即便底层数组发生了改变，但还是打印出了空切片？（具体还是得看 Println 的源码才能真正知道原因）</p><p>因为传的不是指针类型，所以 Len 的变化不能反映到实参，在之前的输出可以看到，形参的 Len 已经发生了改变：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[func] sliceHeader info: <br>&amp;&#123;Data:1374390001664 Len:4 Cap:20&#125;<br></code></pre></td></tr></table></figure><p>综上所述，以后如果要把 slice 作为参数传递，且调用方要执行 append 操作，直接统一传递指针就好了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统面试题</title>
    <link href="/2022/02/15/cao-zuo-xi-tong-mian-shi-ti/"/>
    <url>/2022/02/15/cao-zuo-xi-tong-mian-shi-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="页的概念"><a href="#页的概念" class="headerlink" title="页的概念"></a>页的概念</h1><h1 id="线程怎么调度的"><a href="#线程怎么调度的" class="headerlink" title="线程怎么调度的"></a>线程怎么调度的</h1><h1 id="进程间通信有哪几种方式，哪种方式最快？"><a href="#进程间通信有哪几种方式，哪种方式最快？" class="headerlink" title="进程间通信有哪几种方式，哪种方式最快？"></a>进程间通信有哪几种方式，哪种方式最快？</h1><p>1.无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>2.高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p>3.有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>4.消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>5.信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>6.信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>7.共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<strong>共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>8.套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVCC 与事务隔离</title>
    <link href="/2022/02/14/mvcc-yu-shi-wu-ge-chi/"/>
    <url>/2022/02/14/mvcc-yu-shi-wu-ge-chi/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 申明：以下内容来自网上的博客、课程，通过自己的理解进行一下转述，可能存在一些错误和纰漏</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>MySQL 的 <strong>可重复读</strong> 和 <strong>读已提交</strong> 是基于 <strong>MVCC</strong> 实现的，它的最大优点是读不加锁，因此读写不冲突，并发性能好，其实现主要基于以下技术及数据结构：</p><p>首先，InnoDB 里面每个事务有一个唯一的事务ID，叫作 transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p><p>同一行记录可能被不同的事务进行操作，这样同一行记录就可能会有多个版本，每个记录都会有以下内容：</p><p>1）隐藏列：InnoDB 中每行数据都有隐藏列，隐藏列中包含了本行数据的事务 id（就是上面提到的，row trx_id）、指向 undo log 的指针等。</p><p>2）基于 undo log 的版本链：前面说到每行数据的隐藏列中包含了指向 undo log 的指针，而每条 undo log 也会指向更早版本的 undo log，从而形成一条版本链。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644829927173.webp"><br>比如在上图中，id 为 15 的事务将 k 更新为 10，此时该版本的 row_trx_id 为当前事务 15，undo log 指针指向之前的版本，以此类推，id 为 17 的事务将 k 更新为 11，并重复上面的操作。这样，同一个记录就有了多个版本，并且通过指针形成了一条版本链。</p><p>此外还有一个 <code>Read View</code> 的概念，可以将其理解为一个数据快照，就像相机拍照那样，定格某一时刻的风景。在 <strong>读已提交</strong> 和 <strong>可重复读</strong> 这两个隔离级别中就用到了 <code>Read View</code> 这个东西，<strong>读提交</strong> 隔离级别是在 <strong>每次读操作执行前</strong> 都会重新生成一个 Read View，而 <strong>可重复读</strong> 隔离级别是 <strong>启动事务时</strong> 生成一个 Read View，然后整个事务期间都在用这个 Read View。</p><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值，可以称为 <strong>低水位</strong>。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1，可以称为 <strong>高水位</strong>；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644832266992.webp"></p><p>当创建出一个 Read View 时，它会根据 select 条件，找到某一行（或者多行）记录，首先找到的是这行的最新版本（如果这里理解不了，请看后面的示例），看一下这个版本的 row trx_id，有以下几种可能：</p><p>如果落在 <strong>绿色部分</strong>（小于低水位），表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是 <strong>可见</strong> 的；</p><p>如果落在 <strong>红色部分</strong>（大于等于高水位），表示这个版本是由将来启动的事务生成的，是肯定 <strong>不可见</strong> 的；</p><p>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id <strong>在数组中</strong>，表示这个版本是由还 <strong>没提交</strong> 的事务生成的，不可见；<br>b. 若 row trx_id <strong>不在数组中</strong>，表示这个版本是 **已经提交 **了的事务生成的，可见。</p><p>如果该版本不可见，那么会通过 undolog 指针，继续查看上个版本，重复上面的流程，直到找到一个可见的版本。</p><h1 id="mvcc-示例"><a href="#mvcc-示例" class="headerlink" title="mvcc 示例"></a>mvcc 示例</h1><p>举个例子：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644832501001.webp"></p><p>假设这三个事务开始前，系统里面还有一个活跃事务， ID 是 99，事务 A、B、C 的事务 ID 分别是100、101、102（事务 ID 按照事务开始时间递增，A 最先执行，所以事务 ID 在三者中最小），且当前系统里只有这四个事务，三个事务开始前，k (1,1）这一行数据的 row trx_id 是 90。</p><p>这样，事务 A 的视图数组就是[99,100], 事务 B 的视图数组是[99,100,101], 事务 C 的视图数组是[99,100,101,102]。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644832593647.webp"></p><p>事务 C 最先将 k 更新为 (1, 2)，此时便产生了一个新的版本，该版本的 row_trx_id 为事务 C 的 id，也就是 102，之后 C 便提交了（事务 C 没有显式地使用 begin&#x2F;commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交）。</p><p>之后，B 进行了更新，此时又产生了一个新的版本，row_trx_id 为 101，但此时 B 还没有 commit，</p><p>之后，A 尝试获取 k 的值，它将从当前版本开始读（也就是这一行的最新值，即 b 更新后的版本），此时 A 的视图数组为 [99, 100]，低水位是数组中的最小值 99，高水位是给下一个事务分配的 ID，也就是 101，查找流程如下：</p><ol><li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，等于高水位<del>大（疑问：如果高水位是数组最大+1，也就是 101，那此时 row trx_id 是等于高水位而不是大于啊？）</del>，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ol><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><h1 id="再次理解视图数组的作用"><a href="#再次理解视图数组的作用" class="headerlink" title="再次理解视图数组的作用"></a><strong>再次理解视图数组的作用</strong></h1><p>假设有事务 A，id 为 90，事务 B，id 为 91，在 A，B 之前还有一个活跃事务，id 为 80，k 这一行的当前版本事务 id 为 30</p><table><thead><tr><th>事务 A [80, 90]</th><th>事务 B [80, 90, 91]</th></tr></thead><tbody><tr><td>begin</td><td></td></tr><tr><td>set k &#x3D; k+1</td><td>begin</td></tr><tr><td></td><td>get k</td></tr></tbody></table><p>前面说到，视图数组保存的是该事务一启动时，当前活跃的事务，事务 A 的 set 操作会产生一个新版本，该版本的 row_trx_id 为 90，当 B 要查询 k 时，先查询当前版本，也就是 A set 后的版本，发现 row_trx_id 为 90，此时事务 B 的低水位是 80（视图数组里的最小值），高水位是 92（91+1，此处存疑），而 row_trx_id 在低水位和高水位之间，那么就进一步查看 B 的视图数组中是否有 90，如果有则说明该事务还未 commit，不能被查看，此时 B 的数组里有 90，所以该版本不能查看，继续通过 undo log指针找到之前的版本，也就是 row_trx_id 为 30 的版本，此时 30 低于低水位，可以查看。这样一套流程下来，就避免了 <strong>读未提交</strong> 的发生。</p><h1 id="可重复读-和-读已提交-在-MVCC-下实现的区别"><a href="#可重复读-和-读已提交-在-MVCC-下实现的区别" class="headerlink" title="可重复读 和 读已提交 在 MVCC 下实现的区别"></a><strong>可重复读</strong> 和 <strong>读已提交</strong> 在 MVCC 下实现的区别</h1><p><strong>可重复读</strong> 和 <strong>读已提交</strong> 都是使用 MVCC 实现的，那么他们有什么区别？<br>RC（读已提交）与 RR（可重复读） 一样，都使用了MVCC，其主要区别在于：</p><p>RR 是在事务开始后第一次执行 select 前创建 ReadView，直到事务提交都不会再创建。根据前面的介绍，RR 可以避免脏读、不可重复读和幻读。（这里有点疑惑，RR 到底能不能解决幻读问题？看不少博客有说能的，也有说不能的，貌似是在 sql 标准下的 RR 是不能解决幻读的，但是 Innodb 的 RR 使用了 next-key，可以防止幻读）</p><p>RC 每次执行 select 前都会重新建立一个新的 ReadView，因此如果事务 A 第一次 select 之后，事务 B 对数据进行了修改并提交，那么事务 A 第二次 select 时会重新建立新的 ReadView，因此此时事务 B 的修改对事务 A 是可见的。因此 RC 隔离级别可以避免脏读，但是无法避免不可重复读和幻读。</p><h1 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a><strong>更新逻辑</strong></h1><p>对于更新语句，使用的是 <strong>当前读</strong>，而不是上面的 <strong>快照读</strong>，select 语句如果加锁，也是当前读，顾名思义，当前读就是获取该值的最新值，比如在下图中，事务 B 读出来的 k 为 3（k 的初值为 1），就是因为当前读的缘故：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644846234451.webp"></p><p>这么做的原因是，如果不使用当前读，那会就会发生更新覆盖的情况。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644846401589.webp"><br>对于这种情况，事务 C 没有马上提交，那么它会持有锁，直到提交后才会释放锁，在它提交之前，B 尝试更新，但是因为拿不到锁，所以 B 就会阻塞，直到 C commit</p><p>参考：</p><ol><li>极客时间——MySQL 实战45讲</li><li><a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SO_REUSEADDR 和 SO_REUSEPORT 实践</title>
    <link href="/2022/02/10/so_reuseaddr-he-so_reuseport-shi-jian/"/>
    <url>/2022/02/10/so_reuseaddr-he-so_reuseport-shi-jian/</url>
    
    <content type="html"><![CDATA[<h1 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h1><p>该选项可以绑定处于 <code>TIME_WAIT</code> 状态的地址，实践：<br>server 端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestServer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := SetsockoptInt(fd, SOL_SOCKET, SO_REUSEADDR, <span class="hljs-number">1</span>); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := Bind(fd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">9999</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := Listen(fd, <span class="hljs-number">1024</span>); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>connfd, _, err := Accept(fd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Log(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err = Read(connfd, buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Log(err)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := Write(connfd, buf); err != <span class="hljs-literal">nil</span> &#123;<br>t.Log(err)<br><span class="hljs-keyword">break</span><br>&#125;<br>Close(connfd)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>client 端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestClient</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fd, err := Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := Connect(fd, &amp;SockaddrInet4&#123;Port: <span class="hljs-number">9999</span>, Addr: [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := Write(fd, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;123&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>Close(fd)<br>t.Fatal(err)<br>&#125;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br><span class="hljs-keyword">if</span> _, err := Read(fd, buf); err != <span class="hljs-literal">nil</span> &#123;<br>Close(fd)<br>t.Fatal(err)<br>&#125;<br>t.Log(<span class="hljs-type">string</span>(buf))<br>time.Sleep(time.Second * <span class="hljs-number">5</span>) <span class="hljs-comment">// client 端不会先退出</span><br>Close(fd)<br>&#125;<br></code></pre></td></tr></table></figure><p>先运行 server 再运行 client，之后迅速关闭 server，此时因为 server 是主动关闭方，所以状态为 <code>TIME_WAIT</code>，此时再次运行 server，发现可以运行成功，如果去掉 <code>SetsockoptInt(fd, SOL_SOCKET, SO_REUSEADDR, 1)</code> ，那么再次运行会报错：address already in use</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP CLOSE_WAIT 和 FIN_WAIT_2</title>
    <link href="/2022/02/02/close_wait-he-fin_wait_2/"/>
    <url>/2022/02/02/close_wait-he-fin_wait_2/</url>
    
    <content type="html"><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p>最近写了一个普通的 tcp demo，发现 server 的状态处于 <code>CLOSE_WAIT</code>，而 client 的状态处于 <code>FIN_WAIT_2</code>，为了排查这个问题，特此写了这篇文章作为记录，这也</p><p>没有 close 的服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(conn net.Conn)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err := conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>_, err = conn.Write(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>addr := <span class="hljs-string">&quot;:8080&quot;</span><br>l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br>log.Printf(<span class="hljs-string">&quot;listen in %v \n&quot;</span>, addr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := l.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := handler(conn); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;handler error: &quot;</span>, err)<br>&#125;<br>&#125;()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有 close 的客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> input <span class="hljs-type">string</span><br>fmt.Scan(&amp;input)<br>n, err := c.Write([]<span class="hljs-type">byte</span>(input))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;write error: &quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>log.Println(<span class="hljs-string">&quot;write byte size: &quot;</span>, n)<br><br>output := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">4096</span>)<br>n, err = c.Read(output)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;read error: &quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;read byte size %v, content: %v \n&quot;</span>, n, <span class="hljs-type">string</span>(output))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实验步骤：<br>打开两个终端分别运行 server 和 client，先运行 server，再运行 client，client 连接后立马 ctrl + c 退出，输入 <code>netstat -an | awk &#39;/^tcp/&#39; | grep 8080</code> 查看连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp4       0      0  127.0.0.1.8080         127.0.0.1.57785        CLOSE_WAIT <br>tcp4       0      0  127.0.0.1.57785        127.0.0.1.8080         FIN_WAIT_2 <br>tcp46      0      0  *.8080                 *.*                    LISTEN  <br></code></pre></td></tr></table></figure><p>发现此时 server 的状态是 <code>CLOSE_WAIT</code>，而 client 的状态是 <code>FIN_WAIT_2</code>，这是为什么呢？分析代码发现，server 端没有对连接进行关闭处理，那么根据四次挥手的状态变化可知：</p><ol><li>第一次挥手，主动关闭方（client）发送 FIN，并进入 <code>FIN_WAIT_1</code> 状态</li><li>第二次挥手，被动关闭方（server）收到 FIN 后，回复一个 ACK，同时进入 <code>CLOSE_WAIT</code> 状态，主动（client）关闭方收到 ACK 后，进入 <code>FIN_WAIT_2</code></li><li>第三次挥手，被动关闭方（server）发送一个 FIN，并进入 <code>LAST_ACK</code>，<strong>问题来了，该 FIN 是调用 close 函数后才会发送的</strong>，而上面的代码没有调用 close，所以不会发送 <code>FIN</code></li></ol><p>一切都明了了，此时因为 server 这边没有没有调用 close 导致无法发出第三次挥手，所以整个挥手流程被卡住，server 的状态停留在 <code>CLOSE_WAIT</code>，而 client 的状态停留在 <code>FIN_WAIT_2</code></p><p>一小段时间后（大约几分钟），<code>CLOSE_WAIT</code> 和 <code>FIN_WAIT_2</code> 状态都会自动消失</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>修改 server 的代码，添加 close：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 省略 </span><br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := handler(conn); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;handler error: &quot;</span>, err)<br>                <span class="hljs-comment">// 新添加的关闭连接函数</span><br>                conn.Close()<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 省略</span><br></code></pre></td></tr></table></figure><p>重复之前的步骤，再次输入 <code>netstat -an | awk &#39;/^tcp/&#39; | grep 8080</code> 查看连接状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcp46      0      0  *.8080                 *.*                    LISTEN     <br>tcp4       0      0  127.0.0.1.57896        127.0.0.1.8080         TIME_WAIT  <br></code></pre></td></tr></table></figure><p>可以看到此时直接进入到了 TIME_WAIT 状态了。</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>通过此次实验，明白了 <code>CLOSE_WAIT</code> 出现的原因，平时写代码比较疏忽，对这些关闭连接的小细节不够重视，如果在上线环境，高并发下可能会导致出现大量的 CLOSE_WAIT，就因为这么一个小小的细节可能导致严重的后果，同时也深刻认识到了基础的重要性。</p><h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><h2 id="CLOSE-WAIT-的危害"><a href="#CLOSE-WAIT-的危害" class="headerlink" title="CLOSE_WAIT 的危害"></a>CLOSE_WAIT 的危害</h2><p>处于 CLOSE_WAIT 状态的 TCP 连接会一直占用端口号、socket fd 等资源，造成资源浪费，如果主机存在大量的 CLOSE_WAIT 状态的连接，甚至可能会导致无法建立新连接，从而整个服务不可用。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/tcp%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><ol><li>第一次挥手，主动关闭方（client）发送 FIN，并进入 <code>FIN_WAIT_1</code> 状态</li><li>第二次挥手，被动关闭方（server）收到 FIN 后，回复一个 ACK，同时进入 <code>CLOSE_WAIT</code> 状态，主动（client）关闭方收到 ACK 后，进入 <code>FIN_WAIT_2</code></li><li>第三次挥手，被动关闭方（server）发送一个 FIN，并进入 <code>LAST_ACK</code>，主动关闭方（client）收到 FIN 后，进入 TIME_WAIT 状态</li><li>第四次挥手，主动关闭方（client）发送 ACK，被动关闭方（server）收到 ACK 后，进入 CLOSED 状态</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面试题</title>
    <link href="/2022/01/28/ji-suan-ji-wang-luo-mian-shi-ti/"/>
    <url>/2022/01/28/ji-suan-ji-wang-luo-mian-shi-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-相关"><a href="#TCP-相关" class="headerlink" title="TCP 相关"></a>TCP 相关</h1><h2 id="1-说说-TIME-WAIT-及其作用"><a href="#1-说说-TIME-WAIT-及其作用" class="headerlink" title="1. 说说 TIME_WAIT 及其作用"></a>1. 说说 TIME_WAIT 及其作用</h2><p>当一端 <strong>主动</strong> 断开连接并发送最后一次挥手后，该端状态变为 <code>TIME_WAIT</code> ，此时会等待 2 MSL （MSL 是  Maximum Segment Lifetime，译为“报文最大生存时间”，可为 30s，1min 或 2min。）<br>作用：</p><ol><li><strong>避免新旧连接混淆</strong></li></ol><p>  如果一个 tcp 连接被关闭了，紧接着马上又有一个相同四元组的 tcp 连接建立了，且此时刚好旧连接中有一个延迟的报文到达了，那么这个旧报文就会错误的被新连接接收（seq 对新连接恰好有效），进而可能会产生一些诡异或者错误的现象。TIME_WAIT 可以在一定程度确保这些延迟的旧报文在网络中消失。</p><ol start="2"><li><strong>确保双方的连接都可以正常关闭</strong></li></ol><p>  假设 A 主动关闭，那么根据四次挥手可知，最后一次挥手，A 需要发送一个 ACK 给 B，如果发送之后没有 <code>TIME_WAIT</code>，而是直接 <code>CLOSED</code>，那么如果该 ACK 丢失，B 会因为超时而重发 FIN，但是因为 A 已经关闭了，所以会回复一个 RST，B 就会认为发生了错误，实际上并没有。如果 A 在发送最后一个 ACK 后进入 <code>TIME_WAIT</code> 等待一段时间，那么 B 的重传 FIN 就可以被正常接收了。</p><p>也有一些博客说，客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 <code>TIME_WAIT</code> 过短或没有，则就直接进入了 <code>CLOSED</code> 状态了，那么服务端则会一直处在 <code>LASE_ACK</code> 状态。<br>当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。</p><h2 id="2-TCP-如何保证可靠性"><a href="#2-TCP-如何保证可靠性" class="headerlink" title="2. TCP 如何保证可靠性"></a>2. TCP 如何保证可靠性</h2><p>TCP (Transmission Control Protocol) 通过以下机制来保证数据传输的可靠性：</p><ol><li>应答机制：TCP 采用应答机制确认数据是否被成功接收。接收方会向发送方发送一个 ACK (Acknowledgment) 确认报文，告诉发送方已经成功接收到数据。如果发送方在一个特定时间内没有收到 ACK，就会重新发送数据。</li><li>超时重传：如果发送方没有收到 ACK，它就会重新发送数据。如果发送方连续多次没有收到 ACK，就会认为这个连接已经失效，并关闭这个连接。</li><li>滑动窗口：TCP 使用滑动窗口机制来控制发送方和接收方之间的数据传输速度。发送方会将多个数据包打包成一个窗口，接收方会告诉发送方它可以接收的最大窗口大小。这样发送方就可以控制它发送的数据包数量，确保不会造成网络拥塞。</li><li>重传机制：如果发送方发送的数据包在网络中丢失或损坏，接收方会发送一个 SACK (Selective Acknowledgment) 报文告诉发送方哪些数据包没有接收到。发送方会根据 SACK 报文重传这些数据包。</li></ol><p>综上所述，TCP 通过这些机制来保证数据传输的可靠性，确保数据能够在网络中成功传输并被正确接收。</p><h2 id="3-三次握手对应到-socket-函数"><a href="#3-三次握手对应到-socket-函数" class="headerlink" title="3. 三次握手对应到 socket 函数"></a>3. 三次握手对应到 socket 函数</h2><h2 id="4-四次挥手对应到-socket-函数"><a href="#4-四次挥手对应到-socket-函数" class="headerlink" title="4. 四次挥手对应到 socket 函数"></a>4. 四次挥手对应到 socket 函数</h2><p>主动关闭方调用 close 发送第一次挥手<br>被动关闭方调用 close 发送第三次挥手<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1643911879647.png"></p><h2 id="5-为什么断开连接需要四次挥手"><a href="#5-为什么断开连接需要四次挥手" class="headerlink" title="5. 为什么断开连接需要四次挥手"></a>5. 为什么断开连接需要四次挥手</h2><h2 id="6-三次握手为什么需要-3-次？2-次或者-4-次不行吗"><a href="#6-三次握手为什么需要-3-次？2-次或者-4-次不行吗" class="headerlink" title="6. 三次握手为什么需要 3 次？2 次或者 4 次不行吗"></a>6. 三次握手为什么需要 3 次？2 次或者 4 次不行吗</h2><p><strong>2 次：无法阻止历史连接，造成资源浪费，比如<a href="https://blog.csdn.net/qq_34827674/article/details/122040501">下图</a>：</strong></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1643774767968.png"></p><p>在上面的图片中，服务端一收到 SYN 就建立连接，但是却无法辨认该 SYN 是否是旧连接，只有在收到客户端的 RST 后才能知道，这导致白白创建了一条连接。</p><p>而使用 3 次握手就可以避免上面的情况，如<a href="https://blog.csdn.net/qq_34827674/article/details/122040501">下图所示</a></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1643775093372.png"></p><p>可以看到，在三次握手的情况下， 可以在服务端建立连接之前，阻止掉历史连接，从而保证建立的连接不是历史连接。</p><p><strong>4 次：既然 3 次已经可以保证连接正常建立了，就没必要再多加一次了</strong></p><h2 id="7-TCP-的拥塞控制"><a href="#7-TCP-的拥塞控制" class="headerlink" title="7. TCP 的拥塞控制"></a>7. TCP 的拥塞控制</h2><h1 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h1><h2 id="1-HTTP-1-0，1-1，2-0，3-0"><a href="#1-HTTP-1-0，1-1，2-0，3-0" class="headerlink" title="1.  HTTP 1.0，1.1，2.0，3.0"></a>1.  HTTP 1.0，1.1，2.0，3.0</h2><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>采用短连接，也就是每次请求都需要与服务器建立一次连接，服务器处理完成后便断开连接。无状态：即每次请求完成后就会断开连接，每个连接断开后都无法获取上次连接的状态和信息。<br>存在的问题：</p><ol><li><p>无法复用连接，每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。</p></li><li><p>队头阻塞(head of line blocking)，由于HTTP1.0规定下一个请求必须在前一个请求响应到达之前才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。</p></li><li><p>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</p></li></ol><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><ol><li><p>长连接：HTTP 1.1 默认支持 keep-alive 的长连接模式，解决了 1.0 中无法复用 TCP 连接的问题，当本次请求结束后不会断开连接并保持本次连接的状态与信息，客户端与服务端都有权取消该模式。</p></li><li><p>管道化：多个请求不用排队发送，但是服务端必须按照发送的顺序进行相应，所以并没有完全解决 HTTP 1.0 的队头阻塞问题。举例：假设文件A中有三个静态文件D,E和F，虽然管道化技术使E不需要等待D请求完成并接收到响应后再开始请求，F也同理，但是最后服务端还是需要按照发送请求时的顺序来依次给出响应，这时候依旧会发生阻塞。 原因是 HTTP1.1 的请求和响应并没有序号标识，所以无法将乱序的响应与请求对应起来。</p></li><li><p>基于长连接的模式就可以实现断点续传的功能了，这样对大文件的传输和下载会更加友好，同时HTTP1.1在请求头中引入了range头域，它允许只请求资源的某部分，此时的返回码是206</p></li></ol><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h3><p>（参考 <a href="https://blog.csdn.net/qq_34827674/article/details/115188949%EF%BC%89">https://blog.csdn.net/qq_34827674/article/details/115188949）</a></p><ol><li>头部压缩：在 HTTP 1&#x2F;1.1 中，可以通过指定 <code>Content-Encoding</code> 来设置 body 的压缩方式，比如 gzip，但是 header 部分不能进行压缩，且 header 部分存在几个问题：1. 使用 ASCII 码，效率低 2. 可能很多请求的 header 的字段值都是相同的，比较冗余 3. 存在一些固定字段，比如 Cookie</li></ol><p>解决方式：<br><strong>静态编码表</strong><br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1644679813525.png"><br>静态编码表为一些常见的 Header 进行了映射，用一个 index 来标识，比如在上图中，:method GET 使用 2 来代替，这样传输就会节省很多字节，服务器在接收到报文后，通过静态编码表就可以获取到相应的信息。<br>但是也会发现一个问题，一些 index 是没有 header value 的，这是因为这些 Value 并不是固定的而是变化的，这些 Value 都会经过 Huffman 编码后，才会发送出去。具体的编码方式参考上面给出来的原文链接。</p><p><strong>动态编码表</strong><br>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建动态表，它的 Index 从 62 起步，会在编码解码的时候随时更新。</p><p>比如发送的报文包含这样一个头部：XXX: YYY，那么客户端和服务端都会在各自的动态编码表中添加这一 header，并且用一个 index 标识，如果客户端之后要再次发送该头部，那么只需要发送对应得 index 即可。</p><p>使得动态表生效有一个前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部。</strong> 如果消息字段在 1 个连接上只发送了 1 次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。</p><p>因此，随着在同一 HTTP&#x2F;2 连接上发送的报文越来越多，客户端和服务器双方的「字典」积累的越来越多，理论上最终每个头部字段都会变成 1 个字节的 Index，这样便避免了大量的冗余数据的传输，大大节约了带宽。</p><p>动态表的弊端是：随着表字段的增长，占用的内存也会越来越大，为了解决该问题，Web 服务器都会提供类似 http2_max_requests 的配置，用于限制一个连接上能够传输的请求数量，避免动态表无限增大，请求数量到达上限后，就会关闭 HTTP&#x2F;2 连接来释放内存。</p><ol start="2"><li><p>二进制帧</p></li><li><p>多路复用<br>为了解决 HTTP 1&#x2F;1.1 中的对头阻塞问题，HTTP 2 使用了<strong>流 (stream)</strong> 的概念，每一次请求对应一个流，有一个唯一的 ID，用来区分不同的请求，多个 stream 复用一条 TCP 连接，达到并发的效果。在每个 stream 中还有多个 <strong>message</strong>，<strong>message</strong> 对应 HTTP1 中的请求或响应，由 header 和 body 组成。message 中有一个或多个 <strong>frame</strong>（帧），frame 是 HTTP2 的最小单位，以二进制压缩格式存放 HTTP1 中的内容。一个请求的数据会被分成多个帧，方便进行数据分割传输，每个帧都唯一属于某一个流 ID，将帧按照流 ID进行分组，即可分离出不同的请求。这样同一个TCP连接中就可以同时并发多个请求，不同请求的帧数据可穿插在一起，根据流 ID 分组即可。</p></li></ol><p>HTTP2 依然存在的问题：TCP 的队头阻塞<br>如果 HTTP&#x2F;2 连接双方的网络中有一个数据包丢失，或者任何一方的网络出现中断，整个TCP连接就会暂停，丢失的数据包需要被重新传输。 因为TCP是一个按序传输的链条，因此如果其中一个点丢失了，链路上之后的内容就都需要等待。 这种单个数据包造成的阻塞，就是TCP上的队头阻塞（head of line blocking）。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><p>TODO</p><h2 id="HTTP-状态码，1xx-5xx"><a href="#HTTP-状态码，1xx-5xx" class="headerlink" title="HTTP 状态码，1xx-5xx"></a>HTTP 状态码，1xx-5xx</h2><p>1xx：表示已接收请求，需要继续发送请求<br>2xx：表示成功处理了请求<br>3xx：表示需要进行重定向<br>4xx：表示请求不能被理解、处理<br>5xx：表示服务器在处理请求时发生了内部错误，这些错误可能是服务器本身的错误，而不是请求出错</p><h2 id="输入-url-到浏览器的过程"><a href="#输入-url-到浏览器的过程" class="headerlink" title="输入 url 到浏览器的过程"></a>输入 url 到浏览器的过程</h2><ol><li><p><del>首先需要确保本机拥有一个 IP 地址，如果没有，则需要通过 DHCP 获取一个 IP，获取流程如下：</del></p><p><del>1.1 本机生成一个 DHCP 请求报文，放入到一个目的端口为 67，源端口为 68 的 UDP 报文中</del></p><p><del>1.2 再将这个 UDP 报文放到一个目的地址为 255.255.255.255 （广播地址）和源地址为 0.0.0.0 （无 IP 地址）的 IP 报文中</del></p><p><del>1.3 再将这个 IP 报文放到一个以太网帧中，该以太网帧的目的 MAC 地址为 FF:FF:FF:FF:FF:FF（表示广播给局域网内的所有主机），     源 MAC 地址为 00:16:D3:23:68:8A</del> </p><p><del>1.4</del></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GMP 面试题</title>
    <link href="/2022/01/26/gmp-mian-shi-ti/"/>
    <url>/2022/01/26/gmp-mian-shi-ti/</url>
    
    <content type="html"><![CDATA[<h1 id="Goroutine-阻塞的话，是不是对应的-M-也会阻塞"><a href="#Goroutine-阻塞的话，是不是对应的-M-也会阻塞" class="headerlink" title="Goroutine 阻塞的话，是不是对应的 M 也会阻塞"></a>Goroutine 阻塞的话，是不是对应的 M 也会阻塞</h1><p>如果 G 被阻塞在某个系统调用上，那么不仅仅 G 会阻塞，执行 G 的 M 也会解绑 P，与 G 一起进入挂起状态。如果此时有空闲的 M,则 P 和与其绑定并继续执行其他的 G;如果没有空闲的 M,但还是有其他 G 需要去执行，那么会创建一个新 M。当系统调用返回后，阻塞在该系统调用上的 G 会尝试获取一个可用的 P,如果没有可用的 P,那么这个 G 会被标记为 <code>runnable</code> 并把它放入全局的 runqueue 中等待调度，之前的那个挂起的 M 将再次进入挂起状态。</p><h1 id="GMP-当一个-G-阻塞时，G、M、P-会发生什么"><a href="#GMP-当一个-G-阻塞时，G、M、P-会发生什么" class="headerlink" title="GMP 当一个 G 阻塞时，G、M、P 会发生什么"></a>GMP 当一个 G 阻塞时，G、M、P 会发生什么</h1><p><strong>用户态阻塞</strong></p><p>当 goroutine 因为 channel 操作或者 network I&#x2F;O 而阻塞时（实际上 golang 已经用 netpoller 实现了goroutine网络 I&#x2F;O 阻塞不会导致 M 被阻塞，仅阻塞 G ），对应的 G 会被放置到某个 wait 队列(如 channel 的 waitq )，该 G 的状态由 _Gruning 变为 _Gwaitting，而 M 会跳过该 G 尝试获取并执行下一个 G，如果此时没有 runnable 的G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态；当阻塞的 G 被另一端的 G2 唤醒时（比如 channel 的可读&#x2F;写通知），G 被标记为 runnable，尝试加入 G2 所在 P 的 runnext，然后再是 P 的 Local 队列和 Global  队列。</p><p><strong>系统调用阻塞</strong></p><p>当 G 被阻塞在某个系统调用上时，此时 G 会阻塞在 _Gsyscall 状态，M 也处于 block on syscall 状态，此时的 M可被抢占调度：执行该 G 的 M 会与 P 解绑，而 P 则尝试与其它 idle 的 M 绑定，继续执行其它 G。如果没有其它idle 的 M，但 P 的 Local 队列中仍然有 G 需要执行，则创建一个新的 M；当系统调用完成后，G 会重新尝试获取一个 idle 的 P 进入它的 Local 队列恢复执行，如果没有 idle 的 P，G 会被标记为 runnable 加入到 Global 队列。</p><h1 id="P-和-M-数量可以无限扩增的吗？"><a href="#P-和-M-数量可以无限扩增的吗？" class="headerlink" title="P 和 M 数量可以无限扩增的吗？"></a>P 和 M 数量可以无限扩增的吗？</h1><p>不是无线扩增的。</p><p>P 的数量：由启动时环境变量 <code>$GOMAXPROCS</code> 或者是由 <code>runtime</code> 的方法 <code>GOMAXPROCS()</code> 决定。</p><p>M的数量：goroutine 程序启动时，会设置 M 的最大数量，默认10000。但是内核很难创建出如此多的线程，因此默认情况下 M 的最大数量取决于内核。也可以调用 runtime&#x2F;debug 中的 SetMaxThreads 函数，手动设置 M 的最大数量。</p><h1 id="P-的调度逻辑"><a href="#P-的调度逻辑" class="headerlink" title="P 的调度逻辑"></a>P 的调度逻辑</h1><p>先从本地 runq 获取待执行的 G，如果没有，再从全局 runq 获取待执行的 G，还没有的话，就从别的 P 中拿（偷）走一半的 G</p><h1 id="如果一个-G-运行时间过长，导致队列中后续-G-都无法运行呢？"><a href="#如果一个-G-运行时间过长，导致队列中后续-G-都无法运行呢？" class="headerlink" title="如果一个 G 运行时间过长，导致队列中后续 G 都无法运行呢？"></a>如果一个 G 运行时间过长，导致队列中后续 G 都无法运行呢？</h1><p>内容来自：<a href="https://www.bilibili.com/video/BV1zT4y1F7XF?spm_id_from=333.999.0.0%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BB%8B%E7%BB%8D">https://www.bilibili.com/video/BV1zT4y1F7XF?spm_id_from=333.999.0.0，里面有非常详细的介绍</a></p><p>这涉及到 GMP 的抢占，在 main goroutine 启动时，会创建一个 <strong>sysmon goroutine</strong>，这是一个特殊的协程，其不依赖 P，也不由 GMP 调度，他会本着公平调度的原则，对运行时间过长的 P，实行抢占操作，就是告诉那些运行时间超过阈值的 P 该让出了，那么怎么知道运行时间过长了呢？P 里面有一个 <code>schedtick</code> 字段，每当调度执行一个新的 G，并且不继承上个 G 的时间片时（这里不懂），就会把它自增 1，还有一个 <code>sysmontick.schedwhen</code> 记录的是上次调度的时间，监测协程如果检测到 <code>sysmontick.schedtick</code> 不等于 <code>p.schedtick</code>，说明这个 P 又发生了新的调度，就会同步 <code>schedwhen</code> 和 <code>schedtick</code>，但如果相等，则说明子 <code>schedwhen</code> 这个时间点之后，这个 P 并未发生了新的调度，或者沿用了之前 G 的时间片，所以可以通过当前时间与 <code>schedwhen</code> 的差值，(sysmontick.schedwhen + forcePreemptNS &lt; now)，来判断当前 P 上的 G 是否运行时间过长了，如果运行时间过长，那么就要通知该 P 让出了。</p><p>如何通知 P 呢？使用的是 <strong>栈增长</strong> 的方式。除了对协程栈没什么消耗的函数调用，Go 语言编译器都会在函数头部插入栈增长检测相关代码，会根据栈帧大小来插入不同的代码，<code>SP</code> 表示当前的栈使用到了哪个位置，<code>stackguard0</code> 表示协程栈的空间下界，当栈的消耗达到或超过 <code>stackguard0</code> 时，就需要进行栈增长，会根据超出大小的多少来使用不同的增长代码（这个具体看视频里的说明，一共 3 种策略），如果调度器希望当前 P 让出，那么就会将 <code>stackguard0</code> 设置为 <code>stackPreempt</code>，这是一个非常大的值，真正的栈指针不可能指向这个位置，所以可以安全的用作特殊标识，此外因为该值足够大，那么 3 种策略都会满足条件，从而 goto 到 <code>morestack</code> 处，<code>morestack</code> 会调用 <code>runtime.newstack</code> 函数，负责栈增长工作，但是在增长前，会先判断 <code>stackguard0</code> 是否等于 <code>stackPreempt</code>，如果等于就不进行栈增长了，而是执行一次协程调度，从而达到抢占的目的。</p><p>不过这种抢占方式的缺陷就是过于依赖栈增长代码，如果来个 for{}，因为不涉及到函数调用，所以与栈增长无关，也就无法通过上面的方式来实现抢占，这一问题在 go1.14 中得到了解决，因为它实现了异步抢占，是通过信号（signal）实现的，当要抢占时，会向协程关联的 M 发送一个 <code>sigPreempt</code> 信号（好像底层是 SIGURG），目标线程（M）收到信号后会被中断，转去执行 <code>sigHandler</code>，该函数检测到信号为 <code>sigPreempt</code> 后，会调用 <code>runtime.doSigPreempt</code> 函数，它会向当前被打断的协程上下文中，注入一个异步抢占函数调用，之后返回，被打断的协程恢复，立刻执行被注入的异步抢占函数，该函数最终会调用 runtime 中的调度逻辑，从而实现让出。</p><h1 id="G-陷入系统调用会发生什么"><a href="#G-陷入系统调用会发生什么" class="headerlink" title="G 陷入系统调用会发生什么"></a>G 陷入系统调用会发生什么</h1><p>一个协程要执行系统调用，就要切换到 g0 栈（为什么要切换到 g0 栈），在系统调用过程中，G 和 M 会一直绑定在一起，不能被分开，也就用不到 P 了，所以在陷入系统调用前，当前 M 会让出 P，解除 m.P 与当前 P 的强关联，并且记录到 m.oldp 中。但是这个 P 如果放着不管就有点浪费了，还是需要将其关联到其他 M，继续执行工作，当之前的 M 结束系统调用后，会先检查之前的 P（m.oldp）是否被占用，没有的话就继续使用，否则就重新申请一个，没申请到的话（什么情况下会申请不到？），就把当前 G 放到全局 runq 中，然后 M 就进入睡眠。</p><h1 id="如果当前-M-没有绑定-P，那么如何获取-G"><a href="#如果当前-M-没有绑定-P，那么如何获取-G" class="headerlink" title="如果当前 M 没有绑定 P，那么如何获取 G"></a>如果当前 M 没有绑定 P，那么如何获取 G</h1><h1 id="GMP-的几个队列"><a href="#GMP-的几个队列" class="headerlink" title="GMP 的几个队列"></a>GMP 的几个队列</h1><p>貌似 GMP 里的全局队列有两种，一种就是单纯保存用作记录的，还有一种是调度器的全局队列，里面保存的是空闲状态的</p><p><strong>调度器的可运行 G 队列</strong></p><p>存放等待执行的 g，新创建的 g 会先尝试保存到当前 g （这个 g 就是新创建 g 的父 goroutine）对应的 p 的本地队列，如果本地队列已满（256个），就会把 g 放到全局队列中。</p><ul><li><p>该队列有容量限制吗？</p></li><li><p>该队列里的 g 什么时候被消费？</p></li></ul><p>如果某个 p 的本地 g 队列为空，则会从全局队列里获取</p><p><strong>全局 M 队列</strong></p><ul><li>作用：</li></ul><ol><li>获取所有 M 的信息 </li><li>防止 M 被当作垃圾回收掉</li></ol><p><strong>调度器的空闲 M 队列</strong></p><p>运行时系统在停止 M 时，会把它放入调度器的空闲 M 队列</p><ul><li>什么时候被消费</li></ul><p>当 G 陷入系统调用时，与其关联的 M 也会被阻塞，而与之关联的 P 会被分离，使得这个 P 中剩余的 G 可以被执行，此时 P 就会去全局 M 队列里查找，如果有的话</p><p><strong>全局 P 队列</strong></p><p>保存了当前 runtime 创建的所有 P，runtime 会把这些 p 中的可运行 g 全部取出，并放入调度器的可运行 g 队列中，被转移的这些 g，会在以后经由调度再次放入某个 p 的可运行 g 队列</p><p><strong>调度器的空闲 P 队列</strong></p><p>当一个 p 不与任何 m 关联时，runtime 就会把它放入该列表，当 runtime 需要一个空闲的 p 来关联某个 m 时，就会从该队列获取。此外，p 进入空闲队列的一个重要条件是，本地队列里没有可运行的 g</p><p><strong>P 的 G 队列</strong></p><p>保存的是可运行的 g，新创建的 g 会先尝试放到这里，最大容量为 256。</p><p><strong>P 的自由 G 队列，调度器的自由 G 列表</strong></p><p>自由 g 表示的是已经运行完成的 g，主要是为了提高复用率，避免频繁创建 g，因为 g 本质也是一个对象。</p><p>运行完成的 g 会先放到对应的 p 的自由 g 队列里，如果太多了，就会转移一部分到调度器的自由 g 列表</p><p>当创建一个 goroutine 时，会先尝试从 p 的自由 g 队列中获取一个现成的 g，如果没有或者太少，会从调度器的自由 g 队列中拿一部分，如果调度器中也没有，才会新创建一个 g</p><h1 id="g0，m0-是什么"><a href="#g0，m0-是什么" class="headerlink" title="g0，m0 是什么"></a>g0，m0 是什么</h1><h1 id="程序题"><a href="#程序题" class="headerlink" title="程序题"></a>程序题</h1><p>以下程序的运行结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;sync&quot;</span><br>        <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>        wg.Add(<span class="hljs-number">3</span>)<br><br>  <span class="hljs-comment">// goroutine1</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>                fmt.Println(n)<br>                wg.Done()<br>        &#125;(<span class="hljs-number">1</span>)<br><br>  <span class="hljs-comment">// goroutine2</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>                fmt.Println(n)<br>                wg.Done()<br>        &#125;(<span class="hljs-number">2</span>)<br><br>  <span class="hljs-comment">// goroutine3</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>                fmt.Println(n)<br>                wg.Done()<br>        &#125;(<span class="hljs-number">3</span>)<br><br>        wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：3 1 2</p><p>P 有一个 runnext 字段，保存的是下一个要运行的 g，当创建一个新的 g 时，会调用 runqput 将其添加到 P 的 runq 中，如果当前 P 的 runq 中已经有 g 了，则会将其挤走，被挤走的那个进入 P 的本地 runq。runnext 的优先度比 runq 高，会先执行 runnext 的 g，再按顺序执行 runq 中的 g。</p><p>在上面的程序中，因为设置了 runtime.GOMAXPROCS(1)，所以整个 runtime 中只有 1 个 P，也就是说上面的 3 个goroutine 都共用这一个 P，首先，goroutine1（简称 g1） 先放到 runnext，之后 g2 进来把 g1 挤走，g1 放到 runq，再之后，g3 把 g2 挤走，g2 放到 runq，此时 runnext 保存的是 g3，runq 中是 g1，g2，所以输出结果是 3，1，2</p><h1 id="goroutine-的调度时机有哪些"><a href="#goroutine-的调度时机有哪些" class="headerlink" title="goroutine 的调度时机有哪些"></a>goroutine 的调度时机有哪些</h1>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境下， VMware Fusion下的虚拟机（ CentOS 7/Ubuntu20）的 NAT网络配置</title>
    <link href="/2022/01/17/mac-huan-jing-xia-vmware-fusion-xia-de-xu-ni-ji-centos-7de-nat-wang-luo-pei-zhi/"/>
    <url>/2022/01/17/mac-huan-jing-xia-vmware-fusion-xia-de-xu-ni-ji-centos-7de-nat-wang-luo-pei-zhi/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/u010476994/article/details/104001848">https://blog.csdn.net/u010476994/article/details/104001848</a> （Centos 7 部分）<br><a href="https://blog.csdn.net/u014630144/article/details/108129079">https://blog.csdn.net/u014630144/article/details/108129079</a> （Ubuntu 20 部分）</p></blockquote><p>本帖子能够实现的效果：<br>    1、虚拟机能访问外网、虚拟机能访问Mac本机；<br>    2、Mac本机可以连接虚拟机。</p><h1 id="Mac-前提步骤"><a href="#Mac-前提步骤" class="headerlink" title="Mac 前提步骤"></a>Mac 前提步骤</h1><h2 id="1、配置-VMware-Fusion-虚拟网络配置"><a href="#1、配置-VMware-Fusion-虚拟网络配置" class="headerlink" title="1、配置 VMware Fusion 虚拟网络配置"></a>1、配置 VMware Fusion 虚拟网络配置</h2><p>VMware Fusion 安装完成后，会在Mac OS中新建两个网卡：  vmnet1以及vmnet8（在 &#x2F;Library&#x2F;Preferences&#x2F;VMware Fusion 下可以看到），其中 vmnet1 是Host-only模式， vmnet8是NAT模式。此处仅对网卡vmnet8 进行修改（ 修改过程中需关闭VMWare Fusion）。</p><h3 id="1-1-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-networking-。"><a href="#1-1-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-networking-。" class="headerlink" title="1.1   修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;networking 。"></a>1.1   修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;networking 。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /Library/Preferences/VMware\ Fusion/networking<br></code></pre></td></tr></table></figure><p><img src="https://youseebiggirl.github.io/post-images/1642402883661.png"></p><p>将 DHCP 设置为 no， 即使用静态IP。 将 SUBNET 修改为自己想用的网段，此处我填的是 192.168.111.0 网段。 </p><p>保存退出。<br>注意：只修改 vmnet8 的配置， 不要修改 vmnet1 的配置。</p><h3 id="1-2-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-vmnet8-x2F-nat-conf-。"><a href="#1-2-修改-x2F-Library-x2F-Preferences-x2F-VMware-Fusion-x2F-vmnet8-x2F-nat-conf-。" class="headerlink" title="1.2    修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;vmnet8&#x2F;nat.conf 。"></a>1.2    修改 &#x2F;Library&#x2F;Preferences&#x2F;VMware\ Fusion&#x2F;vmnet8&#x2F;nat.conf 。</h3><p><img src="https://youseebiggirl.github.io/post-images/1642402997231.png"><br>设置网关为 192.168.111.2 ， 网关的IP要和上一步中的IP 保持网关一致。<br>至此，VMware   Fusion的配置完毕。</p><h3 id="1-3-将虚拟机网络切换到NAT模式。"><a href="#1-3-将虚拟机网络切换到NAT模式。" class="headerlink" title="1.3    将虚拟机网络切换到NAT模式。"></a>1.3    将虚拟机网络切换到NAT模式。</h3><p><img src="https://youseebiggirl.github.io/post-images/1642403059793.png"></p><h1 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h1><p>步骤如下：</p><h2 id="1、打开虚拟机，配置虚拟机网络配置信息"><a href="#1、打开虚拟机，配置虚拟机网络配置信息" class="headerlink" title="1、打开虚拟机，配置虚拟机网络配置信息"></a>1、打开虚拟机，配置虚拟机网络配置信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>可按如下格式配置网络信息（部分信息需按照自己的情况配置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">TYPE=Ethernet<br>PROXY_METHOD=none<br>BROWSER_ONLY=no<br>BOOTPROTO=static<br>DEFROUTE=yes<br>IPV4_FAILURE_FATAL=no<br>IPV6INIT=yes<br>IPV6_AUTOCONF=yes<br>IPV6_DEFROUTE=yes<br>IPV6_FAILURE_FATAL=no<br>IPV6_ADDR_GEN_MODE=stable-privacy<br>NAME=ens33<br>UUID=405afcb9-08fe-4507-8775-232604d2e819<br>DEVICE=ens33<br>ONBOOT=yes<br>IPADDR=192.168.110.14 # 自定义的虚拟机IP， 需与VMware Fusion配置的IP在同一个网段上<br>GATEWAY=192.168.110.2 # 网关。1.2中配置的网关地址<br>NETMASK=255.255.255.0 # 掩码。1.2中配置的掩码<br>DNS1=192.168.1.1 # Mac本机的DNS地址。 系统偏好设置-&gt; 网络 -&gt; 在左侧选择当前使用的网络，点击右下角的“高级”按钮 -&gt; 切换Tab页，可找到DNS地址。<br>DNS2=192.168.1.1 # 同上<br></code></pre></td></tr></table></figure><p>保存退出，重启网络服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart network<br></code></pre></td></tr></table></figure><p>至此。所有网络配置完成。</p><p>注意：修改完 DNS 后需要重启 VMware 才能生效 （貌似只需要重启一次，后续再更改 DNS 不需要重启了）</p><h1 id="Ubuntu-20"><a href="#Ubuntu-20" class="headerlink" title="Ubuntu 20"></a>Ubuntu 20</h1><h2 id="1-编辑网络配置文件："><a href="#1-编辑网络配置文件：" class="headerlink" title="1. 编辑网络配置文件："></a>1. 编辑网络配置文件：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/netplan/00-installer-config.yaml<br></code></pre></td></tr></table></figure><p>编辑文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">This is the network config written by <span class="hljs-string">&#x27;subiquity&#x27;</span></span><br>network:<br>  ethernets:<br>    ens33:<br>      dhcp4: no<br>      addresses: [192.168.110.10/24] # 确保该值在前提步骤 1.1 中设置的 ip 段内，且子网掩码相同<br>      gateway4: 192.168.110.2 # 与前提步骤 1.2 中网管 ip 相同<br>      nameservers:<br>              addresses: [114.114.114.114]<br>  version: 2<br></code></pre></td></tr></table></figure><p>使配置的ip地址生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo netplan apply<br></code></pre></td></tr></table></figure><p>重启 VMware Fusion 生效。</p>]]></content>
    
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 间隙锁实践</title>
    <link href="/2021/10/19/mysql-jian-xi-suo-shi-jian/"/>
    <url>/2021/10/19/mysql-jian-xi-suo-shi-jian/</url>
    
    <content type="html"><![CDATA[<p>测试数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> c    <span class="hljs-operator">|</span> d    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">0</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span>    <span class="hljs-number">0</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span>    <span class="hljs-number">5</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">10</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">15</span> <span class="hljs-operator">|</span>   <span class="hljs-number">15</span> <span class="hljs-operator">|</span>   <span class="hljs-number">15</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">20</span> <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">25</span> <span class="hljs-operator">|</span>   <span class="hljs-number">25</span> <span class="hljs-operator">|</span>   <span class="hljs-number">25</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+------+------+</span><br></code></pre></td></tr></table></figure><h2 id="测试情景-1-不存在的主键，select-是否会加间隙锁"><a href="#测试情景-1-不存在的主键，select-是否会加间隙锁" class="headerlink" title="测试情景 1 不存在的主键，select 是否会加间隙锁"></a>测试情景 1 不存在的主键，select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where id &#x3D; 9 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(11,5,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(6,5,5);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(10,5,5);</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center">insert into t values(4,5,5);</td></tr><tr><td align="center">8</td><td align="center"></td><td align="center">select * from t where id &#x3D; 9 for update;</td></tr></tbody></table><p>结果：</p><p>B1：成功执行，输出 Empty set</p><p>B4：成功执行</p><p>B5：被阻塞</p><p>B6：Duplicate entry ‘10’ for key ‘t.PRIMARY’ 主键不能重复</p><p>B7：成功执行</p><p>B8：成功执行，输出 Empty set</p><p>说明：</p><p>因为 id &#x3D; 9 这一行不存在，所以会加间隙锁，区间为 (5, 10]，左开右闭。所以所有尝试在 [5, 10) 区间 insert 数据的 sql 都被阻塞了，但是区间外不会被阻塞，比如 id&#x3D;11 和 id &#x3D; 4 就成功执行了。</p><p>关于 B8 为什么没有被阻塞，可能是因为因为 id&#x3D;9 不存在，所以 A3 处的 for update 并没有生效加锁。</p><h2 id="测试情景-2"><a href="#测试情景-2" class="headerlink" title="测试情景 2"></a>测试情景 2</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where id &#x3D; 9 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">insert into t values(9,9,9);</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">select * from t where id &#x3D; 9 for update;</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">select * from t where id &#x3D; 7 for update;</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">8</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>A3：成功执行，输出 Empty set</p><p>A4：成功执行</p><p>B5：被阻塞</p><p>B6：成功执行，输出 Empty set</p><p>为什么 B5 会被阻塞呢？似乎除了 id&#x3D;9 以外，其他的查询都不会被阻塞</p><p>破案了，insert 会加排它锁</p><h2 id="测试情景-3-已经存在的主键，select-是否会加间隙锁"><a href="#测试情景-3-已经存在的主键，select-是否会加间隙锁" class="headerlink" title="测试情景 3 已经存在的主键，select 是否会加间隙锁"></a>测试情景 3 已经存在的主键，select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where id &#x3D; 10 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(11,5,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(9,5,5);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">select * from t where id &#x3D; 10 for update;</td></tr><tr><td align="center">7</td><td align="center">select * from t where id &#x3D; 9 for update;</td><td align="center"></td></tr><tr><td align="center">8</td><td align="center">select * from t where id &#x3D; 11 for update;</td><td align="center"></td></tr><tr><td align="center">9</td><td align="center">select * from t where id &#x3D; 8 for update;</td><td align="center"></td></tr></tbody></table><p>A3：成功执行</p><p>B4：成功执行</p><p>B5：成功执行</p><p>B6：被阻塞</p><p>A7：被阻塞</p><p>A8：被阻塞</p><p>A9：成功执行</p><p>因为 id&#x3D;10 存在且 id 为主键，所以只加了排他锁，没有加间隙锁，所以 B4，B5 的插入都成功了，B6 被阻塞了，因为 id&#x3D;10 这一行已经上锁了。</p><p>由于主键是唯一索引，而且是只使用一个索引查询，并且只锁定一条记录，所以以上的例子，只会对 id &#x3D; 10 的数据加上记录锁，而不会产生间隙锁。</p><p>比较怪异的是 A7、A8 这两个地方，居然被阻塞了，观察发现，这两个 sql 查询的 id 是 9 和 10，刚好是 B 中插入的两个 id，而 A9 处的 id&#x3D;8 没有被阻塞，难道在 insert 之后会给新插入的行加锁吗？</p><p>破案了，insert 会加排它锁</p><h2 id="测试情景-4-已经存在的非索引列（可能查出多条数据），select-是否会加间隙锁"><a href="#测试情景-4-已经存在的非索引列（可能查出多条数据），select-是否会加间隙锁" class="headerlink" title="测试情景 4 已经存在的非索引列（可能查出多条数据），select 是否会加间隙锁"></a>测试情景 4 已经存在的非索引列（可能查出多条数据），select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where d&#x3D;5 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(26,26,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(26,26,4);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(100,100,100);</td></tr></tbody></table><p>A3：成功执行</p><p>B4：被阻塞</p><p>B5：被阻塞</p><p>B6：被阻塞</p><p>因为 A3 查询条件是 d&#x3D;5，而 d 既不是主键也没有索引，所以会加间隙锁，防止幻读出现，间隙锁的范围是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]，所有的 insert 全部被阻塞了，</p><h2 id="测试情景-5-不存在的非索引列（可能查出多条数据），select-是否会加间隙锁"><a href="#测试情景-5-不存在的非索引列（可能查出多条数据），select-是否会加间隙锁" class="headerlink" title="测试情景 5 不存在的非索引列（可能查出多条数据），select 是否会加间隙锁"></a>测试情景 5 不存在的非索引列（可能查出多条数据），select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where d&#x3D;100 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(26,26,5);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(26,26,4);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(100,100,100);</td></tr></tbody></table><p>结论：session B 的 insert 全部被阻塞，由此可见，即便 d&#x3D;100 这一行不存在，依然会加间隙锁</p><h2 id="测试场景-6-不存在的普通索引列，select-是否会加间隙锁"><a href="#测试场景-6-不存在的普通索引列，select-是否会加间隙锁" class="headerlink" title="测试场景 6 不存在的普通索引列，select 是否会加间隙锁"></a>测试场景 6 不存在的普通索引列，select 是否会加间隙锁</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">select * from t where c&#x3D;9 for update;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">insert into t values(11,11,11);</td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">insert into t values(100,8,100);</td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">insert into t values(100,10,100);</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center">insert into t values(101,5,100);</td></tr><tr><td align="center">8</td><td align="center"></td><td align="center">insert into t values(102,4,100);</td></tr></tbody></table><p>B4：成功执行</p><p>B5：被阻塞</p><p>B6：成功执行</p><p>B7：被阻塞</p><p>B8：成功执行</p><p>对于列 c 而言，有这些间隙： (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]</p><p>因为查询的是 c&#x3D;9 ，所以间隙锁范围是 (5,10]，但是我没有太明白这个范围的意思，按照数学来说，应该是不包含 5，但是包含 10 的意思，也就是 c&#x3D;5 不加锁，c&#x3D;10 加锁，但是从上面的测试来看，insert c&#x3D;5 被阻塞，而 insert c&#x3D;10 没有被阻塞，完全相反，这是为什么？</p><h2 id="测试情景-6"><a href="#测试情景-6" class="headerlink" title="测试情景 6"></a>测试情景 6</h2><table><thead><tr><th align="center"></th><th align="center">session A</th><th align="center">session B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">begin</td></tr><tr><td align="center">3</td><td align="center">insert into t values(9,9,9);</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">select * from t where id&#x3D;9 for update;</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>A3：执行成功</p><p>B4：阻塞</p><p>可以参考 <a href="https://zhuanlan.zhihu.com/p/48269420">https://zhuanlan.zhihu.com/p/48269420</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL实战笔记 20讲幻读是什么</title>
    <link href="/2021/10/19/mysql-shi-zhan-bi-ji-20-jiang-huan-du-shi-shi-me/"/>
    <url>/2021/10/19/mysql-shi-zhan-bi-ji-20-jiang-huan-du-shi-shi-me/</url>
    
    <content type="html"><![CDATA[<p>全文基于此表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `c` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `d` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<br>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>),(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">25</span>,<span class="hljs-number">25</span>,<span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><h1 id="1-什么是幻读"><a href="#1-什么是幻读" class="headerlink" title="1. 什么是幻读"></a>1. 什么是幻读</h1><p>如下是文章中的图，需要注意的是，这里的 result 是基于 <strong>如果只在id&#x3D;5这一行加锁，而其他行的不加锁</strong> （也就是行锁）这一基础上的，当时没注意这句话，导致自己用 Mysql 做实验时出现了不一样的结果：session A 的 T1 执行完成后，session B 的 T2 被阻塞，直到 A 事务结束，因为 B 被阻塞了，所以 A 的 T3 查询结果依然是 (5,5,5) 而不是图中的 (0,0,5)(5,5,5)<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634646186038.webp"></p><p><strong>幻读</strong> 指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。比如在上图中，Q3 读到了 (1,1,5) ，便是幻读。</p><p><strong>幻读</strong> 在 <strong>当前读</strong> 下才会出现，图中的 <code>select</code> 都加了 <code>for update</code>，代表当前读。（当前读：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录），在<strong>快照读</strong>下不会出现（可重复读隔离级别下），因为快照读看不到别的事务插入的数据。</p><p><strong>幻读</strong> 仅专指 <strong>新插入的行</strong>，所以 session B T2 的 update 操作，导致的 A T3 结果不算是幻读。比如在上图中，Q2 读到了 (0,0,5) ，但不是幻读。</p><h1 id="2-幻读有什么问题"><a href="#2-幻读有什么问题" class="headerlink" title="2. 幻读有什么问题"></a>2. 幻读有什么问题</h1><p>这是原文中的标题，但是我不是很理解之后举的例子和幻读有什么关系，倒是换成 <strong>只加行锁有什么问题</strong> 更贴切（个人拙见）。</p><h2 id="2-1-语义被破坏"><a href="#2-1-语义被破坏" class="headerlink" title="2.1 语义被破坏"></a>2.1 语义被破坏</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634648873422.webp"></p><p>session A 里 Q1 语句，表示要锁住所有 d&#x3D;5 的行，阻塞其他事务的读写操作。但是在 session B T2 中找个了漏洞，先将 id&#x3D;0 这一行的 d 改成 5，再对这一行进行更改，这样就破坏了 A 中锁住所有 d&#x3D;5 这一语句进行了破坏，session C 也是一样的道理。</p><h2 id="2-2-数据一致性的问题"><a href="#2-2-数据一致性的问题" class="headerlink" title="2.2 数据一致性的问题"></a>2.2 数据一致性的问题</h2><p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634649601817.webp"></p><p>看看 binlog 里面的内容：</p><ol><li><p>T2 时刻，session B 事务提交，写入了两条语句；</p></li><li><p>T4 时刻，session C 事务提交，写入了两条语句；</p></li><li><p>T6 时刻，session A 事务提交，写入了update t set d&#x3D;100 where d&#x3D;5 这条语句。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> session B<br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,0,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,5,5)*/</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> session C<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">/*(1,1,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">/*(1,5,5)*/</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> session A<br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<span class="hljs-comment">/*所有d=5的行，d改成100*/</span><br></code></pre></td></tr></table></figure><p>因为 binlog 是按照 commit 的先后顺序记录的，而不是按 update 的执行顺序记录的（上图中 A 最先执行 update，然后是 B，最后是 C），所以会导致错误的结果，如果以后用 binlog 来克隆一个库，这三行的结果变成了 (0,5,100)、(1,5,100) 和 (5,5,100)，与实际的 (0,5,5)、(1,5,5) 和 (5,5,100) 不符，因为 A 被记录到了最后。</p><p>如何让 binlog 按 update 的执行顺序记录呢？按照文中的说法是，<strong>把扫描过程中碰到的行，也都加上写锁</strong>，（这里没太明白，意思是把 session A 中的 select 语句扫描到的行全部加锁吗？如果是这样的话，因为 d 没有索引，所以会扫描全表，也就是把整张表都加锁吗？暂时先这么理解吧）A select for update 时直接将所有行锁起来，这样后续的 B C 都会被阻塞，直到 A commit，这样 binlog 中，最先记录的就是 A，此时的 binlog：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">/*(1,1,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-comment">/*(1,5,5)*/</span><br><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span>;<span class="hljs-comment">/*所有d=5的行，d改成100*/</span><br><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,0,5)*/</span><br><span class="hljs-keyword">update</span> t <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">0</span>; <span class="hljs-comment">/*(0,5,5)*/</span><br></code></pre></td></tr></table></figure><p>可以看到上面的记录依然存在问题，最先记录的不是预想中的 A，而是 C，这是为什么呢？明明都已经把整张表都锁起来了，还是阻止不了id&#x3D;1这一行的插入和更新呢？</p><p>原因很简单。在T3时刻，我们给所有行加锁的时候，id&#x3D;1这一行还不存在，不存在也就加不上锁。</p><p>也就是说，<strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong>，这也是为什么“幻读”会被单独拿出来解决的原因。</p><h1 id="3-如何解决幻读"><a href="#3-如何解决幻读" class="headerlink" title="3. 如何解决幻读"></a>3. 如何解决幻读</h1><h2 id="3-1-间隙锁"><a href="#3-1-间隙锁" class="headerlink" title="3.1 间隙锁"></a>3.1 间隙锁</h2><p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的<strong>间隙</strong>。</p><p>何为间隙？比如 (0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25) 这六条记录中，便存在以下 7 个间隙：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634652727224.webp"></p><p>这样，当你执行 select * from t where d&#x3D;5 for update 的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>跟 <strong>间隙锁</strong> 存在冲突关系的，是“往这个间隙中<strong>插入一个记录</strong>”这个操作。间隙锁之间都不存在冲突关系。</p><p>对于指定<strong>查询某一条记录</strong>的加锁语句，如果该记录<strong>不存在，会产生记录锁和间隙锁</strong>，如果记录存在，则只会产生记录锁。（注意这里的查询一条记录，如果是范围查询，或者查询出多条结果，那么不管存不存在，都会加间隙锁）</p><p>对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE <code>id</code> BETWEEN 5 AND 7 FOR UPDATE。</p><p>间隙锁是在可重复读隔离级别下才会生效的。</p><p>间隙锁和行锁合称 <code>next-key lock</code>，每个 <code>next-key lock</code> 是<strong>前开后闭</strong>区间。</p><h2 id="3-2-间隙锁导致的死锁案例"><a href="#3-2-间隙锁导致的死锁案例" class="headerlink" title="3.2 间隙锁导致的死锁案例"></a>3.2 间隙锁导致的死锁案例</h2><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1634653283134.webp"></p><ol><li><p>session A 执行select … for update语句，由于id&#x3D;9这一行并不存在，因此会加上间隙锁(5,10);</p></li><li><p>session B 执行select … for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</p></li><li><p>session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；</p></li><li><p>session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。</p></li></ol><p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转载] 进程的虚拟地址空间分布</title>
    <link href="/2021/10/04/zhuan-zai-jin-cheng-de-xu-ni-di-zhi-kong-jian-fen-bu/"/>
    <url>/2021/10/04/zhuan-zai-jin-cheng-de-xu-ni-di-zhi-kong-jian-fen-bu/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/Joezzz/p/9803344.html">https://www.cnblogs.com/Joezzz/p/9803344.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转载] Mac 通过DOSBox搭建汇编环境（附编译、链接、执行、调试详细过程）</title>
    <link href="/2021/10/04/mac-tong-guo-dosbox-da-jian-hui-bian-huan-jing-fu-bian-yi-lian-jie-zhi-xing-diao-shi-xiang-xi-guo-cheng/"/>
    <url>/2021/10/04/mac-tong-guo-dosbox-da-jian-hui-bian-huan-jing-fu-bian-yi-lian-jie-zhi-xing-diao-shi-xiang-xi-guo-cheng/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_41855420/article/details/103746234">https://blog.csdn.net/qq_41855420/article/details/103746234</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39. 组合总和</title>
    <link href="/2021/09/25/39-zu-he-zong-he/"/>
    <url>/2021/09/25/39-zu-he-zong-he/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p><p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p>示例 1：<br>输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出: [[7],[2,2,3]]</p><p>示例 2：<br>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><p>示例 3：<br>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><p>示例 4：<br>输入: candidates &#x3D; [1], target &#x3D; 1<br>输出: [[1]]</p><p>示例 5：<br>输入: candidates &#x3D; [1], target &#x3D; 2<br>输出: [[1,1]]</p><p>提示：<br>1 &lt;&#x3D; candidates.length &lt;&#x3D; 30<br>1 &lt;&#x3D; candidates[i] &lt;&#x3D; 200<br>candidate 中的每个元素都是独一无二的。<br>1 &lt;&#x3D; target &lt;&#x3D; 500</p></blockquote><h1 id="方法-1-回溯"><a href="#方法-1-回溯" class="headerlink" title="方法 1 回溯"></a>方法 1 回溯</h1><p>递归树如下：（以 candidates &#x3D; [2,3,6,7], target &#x3D; 7 为例）<br><img src="https://zengh1.github.io/post-images/1632580624361.png"> </p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span><br>    backtrack(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, tmp, &amp;res)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(c []<span class="hljs-type">int</span>, t, sum, start <span class="hljs-type">int</span>, tmp []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> sum == t &#123;<br>        tmpp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(tmp))<br>        <span class="hljs-built_in">copy</span>(tmpp, tmp)<br>        *res = <span class="hljs-built_in">append</span>(*res, tmpp)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> sum &gt; t &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(c); i++ &#123;<br>        tmp = <span class="hljs-built_in">append</span>(tmp, c[i])<br>        sum += c[i]<br>        fmt.Println(tmp)<br>        backtrack(c, t, sum, i, tmp, res)<br>        tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        sum -= c[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 批量 kill 进程</title>
    <link href="/2021/09/21/linux-pi-liang-kill-jin-cheng/"/>
    <url>/2021/09/21/linux-pi-liang-kill-jin-cheng/</url>
    
    <content type="html"><![CDATA[<h1 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep name | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill<br></code></pre></td></tr></table></figure><h1 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h1><p><code>ps -ef</code>：查看全格式的全部进程</p><p><code>grep name</code>：将 ps -ef 的输出作为输入，过滤出其中包含 ”name“ 的结果</p><p><code>grep -v grep</code>：-v 代表反向选择，这条是比较迷惑的，为什么要加这条语句呢？因为之前的 <code>grep name</code> 这句话本身也会创建一个进程，并且该进程中也会包含 “name” 这个字段，所以 <code>grep name</code> 输出的列表中也会包含其自身的进程，但是该进程在 grep 执行之后就会退出，如果此时再将其 kill，会产生 <code>kill: 32169: No such process</code> 错误。所以这里需要使用 -v grep，反向选择，选择出不包含 grep 的条目</p><p><code>awk</code>：ps 输出的命令包含了 root、pid 等多个字段，但是 kill 只需要 pid 字段，通过该命令，可以筛选出需要的 pid，$2 表示每行第二个变量，在这个例子中就是进程号</p><p><code>xargs</code>：表示用前面命令的输出结果（也就是一系列的进程号）作为 kill 命令的参数</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>使用 go 进行实践<br>首先创建出任意一个二进制文件，这里使用 go 编写一个简单程序，并编译出来，文件名为 sleep.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Hour)<br>&#125;<br></code></pre></td></tr></table></figure><p>编译为二进制：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build sleep.go<br></code></pre></td></tr></table></figure><p>编译出来的二进制文件名为 sleep</p><p>再创建一个 go 程序，用来创建多个进程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>cmd := exec.Command(<span class="hljs-string">&quot;./sleep&quot;</span>)<br>_, err := cmd.CombinedOutput()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br>&#125;()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>此时执行 <code>ps -ef | grep sleep</code>，终端输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">501 32764  1880   0 10:16下午 ttys000    0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox sleep<br>501 32660 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>501 32661 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>501 32662 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>501 32663 32659   0 10:16下午 ttys009    0:00.01 ./sleep<br>.... 省略<br></code></pre></td></tr></table></figure><p>注意，这里的第一条就是 grep 自身的进程</p><p>我们尝试一下，不加 <code>grep -v grep</code> 会怎么样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep sleep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill: 32772: No such process<br></code></pre></td></tr></table></figure><p>运行出错了（这里比较疑惑的是，为什么不是 32764？）</p><p>此时再执行 <code>ps -ef | grep sleep</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">501 32784  1880   0 10:17下午 ttys000    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox sleep<br></code></pre></td></tr></table></figure><p>发现还有一条没被 kill 掉</p><p>而如果使用 <code>ps -ef | grep name | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill</code>，则不会产生错误，并且所有带有 ”sleep“ 的进程都被 kill 掉了</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的面经</title>
    <link href="/2021/09/17/wo-de-mian-jing/"/>
    <url>/2021/09/17/wo-de-mian-jing/</url>
    
    <content type="html"><![CDATA[<p>2021.9.17<br>梦想工场 go 实习生</p><p>现场面，只有纸和笔（吐槽：公司的大厦正好在装修，找了半天才找到，还好出门比较早，不然多半得迟到）</p><p>一上来就是一道算法题：字符串的比较，根据字典序，如果字符串特别大，问我用什么数据结构合适（完全不会，于是换了一道，期间为了遮掩自己的一无所知，随口瞎说了个 kmp 。。。面完才想起来，比较字符串不是可以使用双指针吗？）</p><p>第二道是括号匹配，面试官还在描述题意，我就打断说了句：“括号匹配吧”，然后面试官说：“做过？那就换一道”，顿时想抽自己一巴掌</p><p>第三道题直接把我整懵逼了，假如有很多辆送货车，每辆车都有一个坐标（x, y），他们需要把货物送到一个驿站，找出一个合适的坐标作为驿站，使得每辆车到驿站的距离加起来最短。（完全不会，面试官引导我说，那就先从一维开始，只有 x 坐标，比如数组下标的 [1, 3, 5] 处有三辆车，此时在哪里建驿站最合适，然后我想了一会，说建在中间最合适，偶数个就取中间两个，然后引申到二维，因为我完全不会，所以只能瞎扯，说找出所有 x 坐标的中间坐标，和所有 y 坐标的中间坐标，此时的坐标就是最近的，面试官问我为什么，我沉默了一会说不知道。。。没想到面试官说，其实你这个做法是对的，也不知道是不是在安慰我。。。后来又加了新的条件：每辆车不仅有坐标，还有运货次数，还是一维的，此时又如何建站？此时我的内心是痛苦的，能不能别折磨我了，这面试官不会是个搞算法的吧，我又胡乱扯了下，说根据运货次数进行排序，因为这个问题实在是不会，所以也没有继续往下说了）</p><p>前面刚好提到了排序，面试官让我在纸上手写快排，幸好昨天刚练过，开始写的很熟练流程，结果有一句话卡住了，就是 n[l] &#x3D; p 这句话。。。连快排这种基础算法都能卡，估计是凉透了</p><p>问完以后又问了我 go 的优点，为什么选 go ，我随便瞎扯了一下，之后说换一个面试官问我项目，可能是因为他不太懂 go ？</p><p>第二个面试官穿着一件印有 pincap 的短袖，一看就是个大佬，问了我项目中的一些问题：</p><ol><li>jwt 如何防止数据篡改？（不知道，硬是瞎扯了半天，简直就是造孽，只是照着网上教程简单使用过）</li><li>websocket 的发布订阅？（完全没听说过）如何辨别每一条连接？（不知道，瞎说了每条连接都有一个随机 id）</li><li>用过哪些 linux 命令，如何杀死一批进程？（说了 ps -ef | grep，但是不知道如何筛选 pid，也不知道如何处理一批）</li><li>kill 和 kill - 9 的区别，我说 -9 是强制的，又继续问原理，我说 kill 的信号能被接收，kill -9 的不能被接收。。。又错了</li><li>go pprof 怎么使用的，怎么找项目里的性能问题？我把我写项目遇到的经历说了下，其间提到了 cpu 占用 500%，面试官问 500% 代表什么，我说占了 5 个核</li><li>简历上的项目哪个写的时间最长？</li><li>介绍一下简历上的 【TCP 服务器】项目，期间我提到了心跳、长连接和 CLOSE_WAIT，面试官只是点点头，没有过多地提问</li></ol><p>没有反问</p><p>总结：<br>人生中第一次面试，给我整傻了，全程没有八股，算法题也是我没刷过的（虽然一共也没刷多少题），充分认识到了自己菜的程度，不过面试体验不错，第一个面试官全程笑脸。</p><p>其次，只要是写到简历上的，一定要比较熟悉，起码要了解一些原理，不管你写的是熟练、了解还是简单使用过，面试官不会管你这么多，也不会问你“这是干嘛的？怎么使用？”这种特别浅的问题，像我今天的 jwt 和 websocket 就吃亏了。</p><p>2021.9.22</p><p>汇量科技 go 实习生<br>一面</p><p>说一下你的项目<br>说说项目里的限流是如何实现的<br>new 和 make 分别是分配在堆上还是栈上？二者的区别<br>如何使用 pprof，pprof 除了可以分析 cpu 以外，还能分析什么<br>说说 go 的逃逸分析<br>go 如何检测逃逸（我回答说使用 go tool，面试官说可以设置一个 flag，后来网上查了下，正确答案是go run -gcflags “-m -l” (-m打印逃逸分析信息，-l禁止内联编译)）<br>说说 go 的垃圾回收<br>进程、线程、协程区别，介绍协程时我说了 gmp<br>gmp 中 g 有哪几种状态<br>如何给一个程序分配内存，流程是怎样的？画图说明（不会）<br>说说虚拟内存<br>如果给进程分配虚拟内存时缺页，怎么办<br>说说淘汰算法（说虚拟内存时提到了会淘汰一部分页）<br>介绍项目的时候，我说 go 不能强制结束掉一个 goroutine，只能等待其自己退出，后来面试官说其实可以，说 runtime 有一个函数可以强制结束，但是我没听清<br>goroutine 初始的栈空间大小是多少？<br>linux 用过 awk 吗？一个文本文件，有三列，每列以空格分隔，筛选出所有第三列大于 100 的行<br>如果不是以空格分隔，而是以 \t 分隔呢？，我说好像可以用 -F，（瞎说的，因为之前刚好有看过这个参数），没想到说对了，但是我不知道判断大于 100 的命令<br>如果是统计次数呢？（我瞎说了 wc -l，不知道对不对）<br>redis 的持久化，哪种比较好，有没有不需要持久化的场景？<br>redis 是用来做什么的<br>说说数据库的事务，我说了说 ACID，顺便提了提隔离级别<br>幻读和不可重复读的区别<br>可重复读是如何实现的<br>链表和数组的区别<br>链表和数组哪个内存占用更大</p><p>算法题：<br>括号匹配<br>用切片实现一个栈<br>最长不重复子串（没写出来，有些bug，面试官说思路差不多）</p><p>2021.9.24 二面</p><p>说说项目里的心跳检测和封包协议<br>虽然协议记录了数据包的长度，但是还是会被截断（？没听清），这时该怎么处理？<br>tcp 三次握手对应到 socket<br>redis 主要用来干什么<br>redis 有哪几种数据结构<br>redis zset 是如何实现的<br>redis 的 io 模型</p><p>算法题：<br>连续递增子序列的最大和<br>反转链表2</p><p>吐槽：相比一面而言，二面的体验简直太差了，面试官在最后一分钟才进入房间，并且没开摄像头，声音很小并且断断续续，导致有些问题都没听清；全程心不在焉，不断传来点击鼠标的声音，可能是边工作边面试；回答完问题后没有任何反馈，沉默几十秒后再问下一个，场面一度十分尴尬；在随便问了几个问题后，就开始做题了，第一道做完以后让我说了下思路，第二道没完全ac，只通过了 15&#x2F;20，面试官说差不多了，应该是还有一些特殊情况没处理好，然后就结束了面试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 为什么使用 B+ 树</title>
    <link href="/2021/09/11/mysql-wei-shi-me-shi-yong-b-shu/"/>
    <url>/2021/09/11/mysql-wei-shi-me-shi-yong-b-shu/</url>
    
    <content type="html"><![CDATA[<h1 id="B-树和-B-树的区别"><a href="#B-树和-B-树的区别" class="headerlink" title="B 树和 B+ 树的区别"></a>B 树和 B+ 树的区别</h1><p><strong>来源：<a href="https://draveness.me/whys-the-design-mysql-b-plus-tree/">https://draveness.me/whys-the-design-mysql-b-plus-tree/</a></strong></p><p>B 树与 B+ 树的最大区别就是，B 树可以在非叶结点中存储数据，但是 B+ 树的<strong>所有数据其实都存储在叶子节点中</strong>，当一个表底层的数据结构是 B 树时，假设我们需要访问所有『大于 4，并且小于 9 的数据』：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1631366394543.png"></p><p>如果不考虑任何优化，在上面的简单 B 树中我们需要进行 4 次磁盘的随机 I&#x2F;O 才能找到所有满足条件的数据行：</p><ol><li>加载根节点所在的页，发现根节点的第一个元素是 6，大于 4；</li><li>通过根节点的指针加载左子节点所在的页，遍历页面中的数据，找到 5；</li><li>重新加载根节点所在的页，发现根节点不包含第二个元素；</li><li>通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到 7 和 8；</li></ol><p>当然我们可以通过各种方式来对上述的过程进行优化，不过 B 树能做的优化 B+ 树基本都可以，所以我们不需要考虑优化 B 树而带来的收益，直接来看看什么样的优化 B+ 树可以做，而 B 树不行。</p><p>由于<strong>所有的节点都可能包含目标数据</strong>，我们总是要<strong>从根节点向下遍历子树</strong>查找满足条件的数据行，这个特点带来了大量的<strong>随机 I&#x2F;O</strong>，也是 B 树最大的性能问题。</p><p>B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以<strong>通过『指针』依次按顺序连接</strong>，当我们在如下所示的 B+ 树<strong>遍历数据时可以直接在多个子节点之间进行跳转</strong>，这样能够节省大量的磁盘 I&#x2F;O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1631366964858.png"></p><p>我的理解：因为 B+ 树把所有数据存储在了叶节点，并且叶节点全部连接起来形成了一个<strong>双向链表</strong>，所以在<strong>范围查找</strong>时特别高效，只需要通过指针前后移动即可，这也是其相对于 B 树而言最大的优势，不再需要像 B 树那样进行回溯操作了（比如上面的例子中，要查找一个范围内的数据，需要在叶节点和根节点之间移动）。</p><p><strong>补充一点</strong></p><p>B+ 树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</p><p>这个很好理解，由于 B- 树节点内部每个 key 都带着 data 域，而 B+ 树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着 B+ 树单次磁盘 IO 的信息量大于 B- 树，从这点来看 B+ 树相对 B- 树磁盘 IO 次数少。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>来源：<a href="https://leetcode-cn.com/circle/discuss/F7bKlM/">https://leetcode-cn.com/circle/discuss/F7bKlM/</a></strong></p><p><strong>1. B+ 树和 B 树的区别？</strong><br>B 树非叶子结点和叶子结点都存储数据,因此查询数据时，时间复杂度最好为 O(1)，最坏为 O(log n)。<br>B+ 树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。</p><p>B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B树只能通过中序遍历。</p><p><strong>2. 为什么 B+ 树比 B 树更适合应用于数据库索引？</strong><br>B+ 树更加适应磁盘的特性，相比 B 树减少了 I&#x2F;O 读写的次数。由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而<strong>单个页可以存储更多的关键字</strong>，即<strong>一次性读入内存的需要查找的关键字也就越多</strong>，磁盘的随机 I&#x2F;O 读取次数相对就减少了。</p><p>B+ 树的查询效率相比 B树 更加稳定，由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)。</p><p>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，<strong>利于扫库和范围查询</strong>；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</p><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><h2 id="为什么不使用二叉搜索树？"><a href="#为什么不使用二叉搜索树？" class="headerlink" title="为什么不使用二叉搜索树？"></a>为什么不使用二叉搜索树？</h2><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，<strong>索引不止存在内存中，还要写到磁盘上</strong>。</p><p>你可以想象一下一棵100万节点的平衡二叉树，树高20（2^20 &#x3D; 1048576）。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 下构建基于 C++ 的 gRPC</title>
    <link href="/2021/08/31/mac-xia-gou-jian-ji-yu-c-de-grpc/"/>
    <url>/2021/08/31/mac-xia-gou-jian-ji-yu-c-de-grpc/</url>
    
    <content type="html"><![CDATA[<p>来源于官方文档（<a href="https://grpc.io/docs/languages/cpp/quickstart/%EF%BC%89%EF%BC%8C%E4%BD%86%E6%98%AF%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E4%BA%9B%E5%9D%91%EF%BC%8C%E7%89%B9%E6%AD%A4%E8%AE%B0%E5%BD%95%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%B8%BA">https://grpc.io/docs/languages/cpp/quickstart/），但是其中有一些坑，特此记录，系统为</a> macOS 11.0.1 (20B29)：</p><h1 id="1-设置目录（很重要，必须执行该步骤）"><a href="#1-设置目录（很重要，必须执行该步骤）" class="headerlink" title="1. 设置目录（很重要，必须执行该步骤）"></a>1. 设置目录（很重要，必须执行该步骤）</h1><p>选择一个目录来保存本地安装的软件包。此页面假定环境变量MY_INSTALL_DIR包含此目录路径。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MY_INSTALL_DIR=$HOME/.local<br>mkdir -p $MY_INSTALL_DIR<br>export PATH=&quot;$MY_INSTALL_DIR/bin:$PATH&quot;<br></code></pre></td></tr></table></figure><p>这一步没什么好说的，照着文档做就好。</p><h1 id="2-安装-cmake"><a href="#2-安装-cmake" class="headerlink" title="2. 安装 cmake"></a>2. 安装 cmake</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install cmake<br></code></pre></td></tr></table></figure><h1 id="3-安装构建-gRPC-所需的基本工具"><a href="#3-安装构建-gRPC-所需的基本工具" class="headerlink" title="3. 安装构建 gRPC 所需的基本工具"></a>3. 安装构建 gRPC 所需的基本工具</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install autoconf automake libtool pkg-config<br></code></pre></td></tr></table></figure><h1 id="4-从-GitHub-上-clone-gRPC-源码"><a href="#4-从-GitHub-上-clone-gRPC-源码" class="headerlink" title="4. 从 GitHub 上 clone gRPC 源码"></a>4. 从 GitHub 上 clone gRPC 源码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --recurse-submodules -b v1.38.0 https://github.com/grpc/grpc<br></code></pre></td></tr></table></figure><h1 id="5-构建和安装-gRPC、Protocol-Buffers-和-Abseil"><a href="#5-构建和安装-gRPC、Protocol-Buffers-和-Abseil" class="headerlink" title="5. 构建和安装 gRPC、Protocol Buffers 和 Abseil"></a>5. 构建和安装 gRPC、Protocol Buffers 和 Abseil</h1><p>以下来自官方，但是需要修改一些内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> grpc</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pushd</span> cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DgRPC_INSTALL=ON \</span><br><span class="language-bash">      -DgRPC_BUILD_TESTS=OFF \</span><br><span class="language-bash">      -DCMAKE_INSTALL_PREFIX=<span class="hljs-variable">$MY_INSTALL_DIR</span> \</span><br><span class="language-bash">      ../..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">popd</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p third_party/abseil-cpp/cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">pushd</span> third_party/abseil-cpp/cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake -DCMAKE_INSTALL_PREFIX=<span class="hljs-variable">$MY_INSTALL_DIR</span> \</span><br><span class="language-bash">      -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \</span><br><span class="language-bash">      ../..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make -j</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">popd</span></span><br></code></pre></td></tr></table></figure><p>这一步遇到的问题比较多。<br>问题 1：<br>执行第一个 <code>make install</code> 后产生如下错误：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">-- Install configuration: &quot;&quot;</span><br>CMake Error <span class="hljs-keyword">at</span> cmake_install.cmake:<span class="hljs-number">41</span> (<span class="hljs-built_in">file</span>):<br>  <span class="hljs-built_in">file</span> cannot <span class="hljs-built_in">create</span> <span class="hljs-built_in">directory</span>: /lib.  Maybe need administrative privileges.<br></code></pre></td></tr></table></figure><p>在网上查了下，是因为 macOS 从 big sur 开始就不允许对根目录进行读写操作了，一开始还以为要解决根目录的读写问题，后来在 GitHub 上找到了对应的 issues（<a href="https://github.com/grpc/grpc/issues/24660%EF%BC%89%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E8%BF%B0%E6%96%87%E7%AB%A0%E4%B8%80%E5%BC%80%E5%A7%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF**%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95**%E3%80%82%EF%BC%88%E8%BF%98%E5%A5%BD%E6%B2%A1%E6%8A%98%E8%85%BE%E7%B3%BB%E7%BB%9F%EF%BC%89">https://github.com/grpc/grpc/issues/24660），解决方法是执行上述文章一开始的第一步，也就是**设置目录**。（还好没折腾系统）</a></p><p>问题 2:<br><code>make -j</code> 电脑直接卡死<br>还没找到原因，不过找到了解决方法：<code>make -j 4</code> ，即在 j 的后面指定一个数字即可，这个数字貌似代表的意思是开启多个线程，并发的进行编译。（难道不加数字的话默认开启最大线程？）</p><p>问题 3：<br>执行第二个 <code>make install</code> 后产生如下错误：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">3</span> warnings and <span class="hljs-number">9</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/base/</span>CMakeFiles<span class="hljs-regexp">/log_severity.dir/</span>log_severity.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [absl<span class="hljs-regexp">/base/</span>CMakeFiles<span class="hljs-regexp">/log_severity.dir/</span>all] Error <span class="hljs-number">2</span><br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/civil_time.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/civil_time_detail.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_format.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/civil_time.dir/</span>all] Error <span class="hljs-number">2</span><br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_if.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_lookup.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_info.cc.o] Error <span class="hljs-number">1</span><br><span class="hljs-number">15</span> warnings and <span class="hljs-number">20</span> errors generated.<br>make[<span class="hljs-number">2</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/i</span>nternal<span class="hljs-regexp">/cctz/</span>src/time_zone_impl.cc.o] Error <span class="hljs-number">1</span><br>make[<span class="hljs-number">1</span>]: *** [absl<span class="hljs-regexp">/time/</span>CMakeFiles<span class="hljs-regexp">/time_zone.dir/</span>all] Error <span class="hljs-number">2</span><br>make: *** [all] Error <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>总而言之就是编译失败，解决方法是：<br>将第二个 cmake 替换为如下语句，就是多加了一行 <code>-DCMAKE_CXX_STANDARD=11 </code>，指定使用 c++ 11 进行编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \<br>      -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \<br>      -DCMAKE_CXX_STANDARD=11 \<br>      ../..<br></code></pre></td></tr></table></figure><p>记得如果之前已经执行过 cmake，则需要先清除（<code>rm -rf third_party/abseil-cpp/cmake/build</code>，再执行 <code>mkdir -p third_party/abseil-cpp/cmake/build</code>），再重新执行上面的 cmake 语句。之后就可以正确的 make install 了。</p><p>之后就可以愉快的开始构建示例了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd examples/cpp/helloworld<br>mkdir -p cmake/build<br>pushd cmake/build<br>cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../..<br>make -j<br></code></pre></td></tr></table></figure><p>构建完成后，运行服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行服务器：</span><br>./greeter_server<br></code></pre></td></tr></table></figure><p>新创建一个终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./greeter_client<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Greeter received</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Hello world</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 锁</title>
    <link href="/2021/08/29/mysql-suo/"/>
    <url>/2021/08/29/mysql-suo/</url>
    
    <content type="html"><![CDATA[<h1 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h1><p>语法：</p><ul><li><p>加锁：</p><p>  加读锁<br>  <code>LOCK TABLES [tablename] READ;</code>  </p><p>  加写锁<br>  <code>LOCK TABLES [tablename] WRITE;</code>  </p></li><li><p>释放锁：<br><code>UNLOCK TABLES;</code></p></li></ul><p>加锁后会阻塞其他线程的部分操作，同时也会对加锁线程进行一些限制，直到加锁的线程释放锁。</p><p>读锁和写锁的区别：<br>当加 <strong>读锁</strong> 后，其他线程的 <code>SELECT</code> 语句不会被阻塞，但是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 这些写语句都会被阻塞。此外，加锁线程只能执行读语句，不能执行写语句， 否则会产生错误 <code>Table &#39;sort_demo&#39; was locked with a READ lock and can&#39;t be updated</code>。</p><p>当加 <strong>写锁</strong> 后，其他线程的读写语句都会被阻塞，但是加锁线程的读写语句都可以正常执行。</p><p>可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 <strong>InnoDB</strong> 这种支持行锁的引擎，一般不使用 <code>lock tables</code> 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h1 id="MDL-锁（元数据锁）"><a href="#MDL-锁（元数据锁）" class="headerlink" title="MDL 锁（元数据锁）"></a>MDL 锁（元数据锁）</h1><p><code>MDL</code> 不需要显式使用，在访问一个表的时候会被自动加上。<code>MDL</code> 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 <code>MDL</code>，当对一个表做增删改查操作的时候，加 <code>MDL</code> 读锁；当要对表做结构变更操作的时候，加 <code>MDL</code> 写锁。</p><ul><li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p></li><li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p></li></ul><p>虽然 <code>MDL</code> 锁是系统默认会加的，但却是你不能忽略的一个机制。比如下面这个例子，我经常看到有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。<br><img src="https://youseebiggirl.github.io/post-images/1630250653743.webp"></p><p>我们可以看到 <code>session A</code> 先启动，这时候会对表 t 加一个 MDL 读锁。由于 <code>session B </code>需要的也是MDL 读锁，因此可以正常执行。</p><p>之后 <code>session C</code> 会被blocked，是因为 <code>session A</code> 的 MDL 读锁还没有释放，而 <code>session C</code> 需要MDL 写锁，因此只能被阻塞。</p><p>如果只有 <code>session C</code> 自己被阻塞还没什么关系，但是之后<strong>所有要在表t上新申请MDL读锁的请求</strong>也会被 <code>session C</code> <strong>阻塞</strong>。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p><p>你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到<strong>整个事务提交后再释放</strong>。</p><blockquote><p>划重点：一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请<br>到 MDL 锁后，直到事务执行完才会将锁释放。</p></blockquote><p>基于上面的分析，我们来讨论一个问题，如何安全地给小表加字段？</p><p>首先我们要解决长事务，事务不提交，就会一直占着 <code>MDL</code> 锁。在 <code>MySQL</code> 的 <code>information_schema </code>库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 <code>DDL</code>，或者 <code>kill</code> 掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候 <code>kill</code> 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 <code>alter table</code> 语句里面<strong>设定等待时间</strong>，如果在这个指定的等待时间里面能够拿到 <code>MDL写锁</code> 最好，<strong>拿不到也不要阻塞后面的业务语句</strong>，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><p><code>MariaDB</code> 已经合并了 <code>AliSQL</code> 的这个功能，所以这两个开源分支目前都支持 <code>DDL NOWAIT/WAIT n</code> 这个语法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name NOWAIT <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name WAIT N <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ... <br></code></pre></td></tr></table></figure><h1 id="2-全局锁"><a href="#2-全局锁" class="headerlink" title="2. 全局锁"></a>2. 全局锁</h1><p>顾名思义，全局锁就是对整个数据库实例加锁。<code>MySQL</code> 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：<strong>数据更新语句（数据的增删改）</strong>、<strong>数据定义语句（包括建表、修改表结构等）</strong> 和<strong>更新类事务的提交语句</strong>。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>，也就是把整库每个表都 <code>select</code> 出来存成文本。</p><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version 字段的值一同读出，数据每更新一次，对此version值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p>举例</p><p>1、数据库表设计</p><p>三个字段，分别是id, value, version</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,<span class="hljs-keyword">value</span>,version <span class="hljs-keyword">from</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;id&#125;<br></code></pre></td></tr></table></figure><p>2、每次更新表中的value字段时，为了防止发生冲突，需要这样操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">TABLE</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">value</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>,version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span><br><span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;id&#125; <span class="hljs-keyword">and</span> version<span class="hljs-operator">=</span>#&#123;version&#125;;<br></code></pre></td></tr></table></figure><p>举个例子，比如有下面两个事务：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>select id,value,version from TABLE where id&#x3D;1，结果：version &#x3D; 1</td><td></td></tr><tr><td></td><td>select id,value,version from TABLE where id&#x3D;1，结果：version&#x3D;1</td></tr><tr><td>拿上面查询出来的 version 进行更新，update set version&#x3D;version+1 where version&#x3D;1，结果：version &#x3D; 2</td><td></td></tr><tr><td></td><td>update set version&#x3D;version+1 where version&#x3D;1，此时version已经被 A 更新成了 2，所以这条 sql 语句不会执行成功，从而避免旧数据覆盖新数据</td></tr></tbody></table><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1648548013859.webp"><br>这时候，事务A在等待事务B释放id&#x3D;2的行锁，而事务B在等待事务A释放id&#x3D;1的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。</p><h1 id="for-update-加行锁还是表锁？"><a href="#for-update-加行锁还是表锁？" class="headerlink" title="for update 加行锁还是表锁？"></a>for update 加行锁还是表锁？</h1><p>实验：<br>有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> for_update_is_lock_row_or_lock_table(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    d <span class="hljs-type">int</span>,<br>    c <span class="hljs-type">int</span>,<br>    key(c)c<br>);<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> for_update_is_lock_row_or_lock_table(d, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> for_update_is_lock_row_or_lock_table(d, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> for_update_is_lock_row_or_lock_table(d, c) <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="实验-1-使用索引列作为条件查询"><a href="#实验-1-使用索引列作为条件查询" class="headerlink" title="实验 1 使用索引列作为条件查询"></a>实验 1 使用索引列作为条件查询</h2><p>事务1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">11</span> <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>事务2：<br>更新同一列数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面的语句被被阻塞</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> d<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> c<span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>但是这条语句不会被阻塞，说明此时加的是行锁</p><h2 id="实验2-使用非索引列作为条件查询"><a href="#实验2-使用非索引列作为条件查询" class="headerlink" title="实验2 使用非索引列作为条件查询"></a>实验2 使用非索引列作为条件查询</h2><p>事务1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">11</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>事务2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> for_update_is_lock_row_or_lock_table <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span><span class="hljs-number">22</span> <span class="hljs-keyword">where</span> d<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>被阻塞，此时不是同一行但却被阻塞，说明此时加的是表锁</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果查询条件用了索引&#x2F;主键，那么select ….. for update就会进行行锁。</p><p>如果是普通字段(没有索引&#x2F;主键)，那么select ….. for update就会进行锁表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 的事务隔离级别</title>
    <link href="/2021/08/27/mysql-de-shi-wu-ge-chi-ji-bie/"/>
    <url>/2021/08/27/mysql-de-shi-wu-ge-chi-ji-bie/</url>
    
    <content type="html"><![CDATA[<h1 id="1-未提交读（脏读）"><a href="#1-未提交读（脏读）" class="headerlink" title="1. 未提交读（脏读）"></a>1. 未提交读（脏读）</h1><p>事务的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，称之为 <strong>脏读</strong>。它存在 4 个常见问题（脏读、不可重复读、幻读、丢失更新）。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630079564434.png"></p><h1 id="2-提交读（不可重复读）"><a href="#2-提交读（不可重复读）" class="headerlink" title="2. 提交读（不可重复读）"></a>2. 提交读（不可重复读）</h1><p>就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在 3 个常见问题（不可重复读、幻读、丢失更新）。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630079641737.png"></p><p>新的问题：更新丢失（提交覆盖）<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630079512354.png"></p><p>新的问题：不可重复读<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630080187823.png"></p><p>新的问题：回滚丢失（回滚覆盖）<br>和 <strong>更新丢失</strong> 一样，撤消一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了。</p><h1 id="3-可重复读"><a href="#3-可重复读" class="headerlink" title="3. 可重复读"></a>3. 可重复读</h1><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。<br>就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在2个常见问题（幻读、丢失更新）。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630296234940.png"></p><p>实现原理：<br>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</p><p>适用场景：<br>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p><blockquote><p>Tips： 幻读和不可重复读的区别<br>摘自网上：<br>(1)<br><strong>不可重复读</strong> 主要是说多次读取一条记录, 发现该记录中某些列值被修改过<br> <strong>幻读</strong> 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果<br>不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。<br>(2)<br>幻读问题对应的是插入 <code>INSERT</code> 操作<br>“幻读”是指读的过程中，某些元组被增加或删除，这样进行一些集合操作，比如算总数，平均值等等，就<br>会每次算出不一样的数。所以“不可重复读”和“幻读”都是读的过程中数据前后不一致，只是前者侧重于修<br>改，后者侧重于增删。个人认为，严格来讲“幻读”可以被称为“不可重复读”的一种特殊情况，没错的。但<br>是从数据库管理的角度来看二者是有区别的。解决“不可重复读”只要加行级锁就可以了。而解决“幻读”则<br>需要加表级锁，或者采用其他更复杂的技术，总之代价要大许多。这是搞数据库的那帮家伙非要把这两者<br>区分开的动机吧。</p></blockquote><h1 id="4-可串行化"><a href="#4-可串行化" class="headerlink" title="4. 可串行化"></a>4. 可串行化</h1><p>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><p>串行化是最高的隔离级别，会强制事务串行执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1630293732934.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[牛客][笔试题] 兔子繁衍</title>
    <link href="/2021/08/21/niu-ke-bi-shi-ti-tu-zi-fan-yan/"/>
    <url>/2021/08/21/niu-ke-bi-shi-ti-tu-zi-fan-yan/</url>
    
    <content type="html"><![CDATA[<p>有一对兔子，从出生后的第五个月起每月生出一对小兔子（即满4月就开始生小兔），小兔子也会出生从第五个月起每月生一对小免子。假如兔子不会死，第n个月时，兔群有多少对兔子。</p><p>输入描述:<br>第n月（n为自然数，n&lt;101）</p><p>输出描述:<br>第 n 个月时，兔子的对数（免群的兔子有多少对兔子）。<br>示例 1<br>输入<br>5<br>输出<br>2<br>说明<br>第五个月时，有两对兔子</p><h1 id="方法1-动态规划"><a href="#方法1-动态规划" class="headerlink" title="方法1 动态规划"></a>方法1 动态规划</h1><p>ACM 模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rabbit</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">4</span>; i &lt; n; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-4</span>]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> input <span class="hljs-type">int</span><br>    fmt.Scan(&amp;input)<br>    v := rabbit(input)<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis zset 源码阅读</title>
    <link href="/2021/08/17/redis-zset-yuan-ma-yue-du/"/>
    <url>/2021/08/17/redis-zset-yuan-ma-yue-du/</url>
    
    <content type="html"><![CDATA[<h1 id="types"><a href="#types" class="headerlink" title="types"></a>types</h1><h2 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    sds ele;    <span class="hljs-comment">// 成员</span><br>    <span class="hljs-type">double</span> score;   <span class="hljs-comment">// 分值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span> <span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-comment">// 层</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span>  <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span; <span class="hljs-comment">// 跨度</span><br>    &#125; level[];<br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><h2 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;  <span class="hljs-comment">// 当前跳跃表内，层数最大的那个节点的层数</span><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><h1 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h1><h2 id="zslCreate"><a href="#zslCreate" class="headerlink" title="zslCreate"></a>zslCreate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create a new skiplist. */</span><br>zskiplist *<span class="hljs-title function_">zslCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> j;<br>    zskiplist *zsl;<br><br>    zsl = zmalloc(<span class="hljs-keyword">sizeof</span>(*zsl));<br>    zsl-&gt;level = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始最高层数为 1</span><br>    zsl-&gt;length = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 不包含任何节点</span><br>    <span class="hljs-comment">// header 指向一个空节点，该节点的有 32 层（即 level[] 的长度为 32）</span><br>    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 为头结点每层的属性进行初始化</span><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;<br>        zsl-&gt;header-&gt;level[j].forward = <span class="hljs-literal">NULL</span>;<br>        zsl-&gt;header-&gt;level[j].span = <span class="hljs-number">0</span>;<br>    &#125;<br>    zsl-&gt;header-&gt;backward = <span class="hljs-literal">NULL</span>;<br>    zsl-&gt;tail = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> zsl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zslInsert"><a href="#zslInsert" class="headerlink" title="zslInsert"></a>zslInsert</h2><p>向 <code>skiplist</code> 中插入一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Insert a new node in the skiplist. Assumes the element does not already</span><br><span class="hljs-comment"> * exist (up to the caller to enforce that). The skiplist takes ownership</span><br><span class="hljs-comment"> * of the passed SDS string &#x27;ele&#x27;. */</span><br><span class="hljs-comment">// score: 分数</span><br><span class="hljs-comment">// ele: 成员，是一个 sds 字符串类型</span><br>zskiplistNode *<span class="hljs-title function_">zslInsert</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele)</span> &#123;<br>    <span class="hljs-comment">// update 用来保存每层的某个节点，该节点是待插入节点的前一个节点，例如：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 6 ----- 10</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 4 - 6 ----- 10    插入一个 7</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 4 - 6 - 8 - 10</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 这里先不说明插入的详细过程，只通过上面的跳表就可以知道，7 会被插入到 6 的后面，</span><br>    <span class="hljs-comment">// 并且假设 7 的高度为 3，此时的 update 数组内容如下所示：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// update[2] = 6，代表第三层的 6 是待插入节点 7 的前一个节点。</span><br>    <span class="hljs-comment">// update[1] = 6, update[0] = 6，同理。之后会遍历 update 数组，并将数组中每个元素</span><br>    <span class="hljs-comment">// 的 forward 指向新节点。</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 最终结果为：</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1 --------- 6 - 7 ----- 10</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 4 - 6 - 7 ----- 10    插入一个 7</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 4 - 6 - 7 - 8 - 10</span><br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rank[ZSKIPLIST_MAXLEVEL];<br>    <span class="hljs-type">int</span> i, level;<br><br>    serverAssert(!isnan(score));<br>    x = zsl-&gt;header;<br>    <span class="hljs-comment">// 从 zsl 的最高层开始查找，并不断下降，直到最后到达第 1 层</span><br>    <span class="hljs-comment">// Tips: 什么是最高层？</span><br>    <span class="hljs-comment">// 比如 zsl 当前有 3 个节点（不算头结点），每个节点的层数</span><br>    <span class="hljs-comment">// 分别为 4，2，5，那么 zsl-&gt;level 就是节点中层数最高的 5</span><br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">/* store rank that is crossed to reach the insert position */</span><br>        rank[i] = i == (zsl-&gt;level<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : rank[i+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 循环需要满足的条件如下：</span><br>        <span class="hljs-comment">// 1. level[i] 前进指针指向一个非 null 节点，且前进指针指向的节点的分值</span><br>        <span class="hljs-comment">// 小于当前插入值的分值，那么就可以向前移动，继续查找，例如有如下跳表：</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// head</span><br>        <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6</span><br>        <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6    插入一个 8</span><br>        <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 此时跳表的 level 为 3（此时外层的 for 循环中的 i = 3-1 = 2），</span><br>        <span class="hljs-comment">// 从 head 的 level[3-1] 开始找起，level[2] 的前进指针指向了 1，不为空，</span><br>        <span class="hljs-comment">// 且要插入的节点分值为 8，大于 1，所以可以将 x 移动到当前节点的 forward 节点，</span><br>        <span class="hljs-comment">// 即移动到 4。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 4 还是小于 8，继续向前移动，移动到 6，此时 6 的前进指针为 null，所以不会进入</span><br>        <span class="hljs-comment">// while 循环了，继续向下执行，update[2] = x = 当前节点 6。至此，此轮 for 循环</span><br>        <span class="hljs-comment">// 结束。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 继续进行第二轮 for 循环，此时 i = 1，这代表着现在降到了跳表的第二层。第二层的</span><br>        <span class="hljs-comment">// 6 依然指向 null，所以不进入 while，update[1] = 当前节点 6。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 第三轮 for 循环，此时 i = 0，这代表已经来到了跳表的第一层，此时的 6 依然指向</span><br>        <span class="hljs-comment">// null，update[0] = 6。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 2. level[i] 前进指针指向一个非 null 节点，且前进指针指向的节点的分值</span><br>        <span class="hljs-comment">// 等于当前插入值的分值，也就是遇到了分值一样的情况了，此时会继续判断二者的</span><br>        <span class="hljs-comment">// 成员值，因为成员值是一个字符串，所以会根据字典顺序进行比较，如果 forward</span><br>        <span class="hljs-comment">// 的成员值小于要插入的成员值，则继续向前移动。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 简单的说，如果分值相同，会继续根据成员值进行判断。</span><br>        <span class="hljs-comment">// 比如：</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//   节点 1           节点 2     （省略头结点，头节点指向节点 1）</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-comment">// +   l3   + ----&gt; +   l3   +</span><br>        <span class="hljs-comment">// +   l2   + ----&gt; +   l2   +</span><br>        <span class="hljs-comment">// +   l1   + ----&gt; +   l1   +      添加一个新节点，成员值为 bbbbb，</span><br>        <span class="hljs-comment">// +  30.0  + ----&gt; +  50.0  +      分值为 30.0</span><br>        <span class="hljs-comment">// +  aaaaa + ----&gt; + ccccc  +</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 开始会从头结点开始查找，找到节点 1，发现节点 1 的 score 为 30.0，继续判断成员值，</span><br>        <span class="hljs-comment">// 因为 bbbbb &gt; aaaaa，所以移动到节点 1，看后一个节点 节点 2 的 score 值，因为</span><br>        <span class="hljs-comment">// 50 &gt; 30，所以停止移动，新节点将插入到节点 1 的后面</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//   节点 1           新节点</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-comment">// +   l3   + ----&gt; +   l3   +</span><br>        <span class="hljs-comment">// +   l2   + ----&gt; +   l2   +</span><br>        <span class="hljs-comment">// +   l1   + ----&gt; +   l1   +</span><br>        <span class="hljs-comment">// +  30.0  + ----&gt; +  30.0  +</span><br>        <span class="hljs-comment">// +  aaaaa + ----&gt; + bbbbb  +</span><br>        <span class="hljs-comment">// +--------+       +--------+</span><br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;   <span class="hljs-comment">// level[i] 的前进指针指向非 null 节点</span><br>                <span class="hljs-comment">// 如果插入节点的分值大于 level[i] 指向节点的分值</span><br>                (x-&gt;level[i].forward-&gt;score &lt; score ||<br>                    <span class="hljs-comment">// 插入节点分值等于 level[i] 指向节点的分值</span><br>                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;<br>                    <span class="hljs-comment">// level[i] 指向节点的 ele 小于插入节点的 ele</span><br>                    <span class="hljs-comment">// Tips: sdscmp(x, y), 当 x &lt; y 时，返回一个负数</span><br>                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))<br>        &#123;<br>            <span class="hljs-comment">//</span><br>            rank[i] += x-&gt;level[i].span;<br>            <span class="hljs-comment">// 移动到下一个节点</span><br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        <span class="hljs-comment">// 记录当前层的待插入节点的前一个节点</span><br>        update[i] = x;<br>    &#125;<br>    <span class="hljs-comment">/* we assume the element is not already inside, since we allow duplicated</span><br><span class="hljs-comment">     * scores, reinserting the same element should never happen since the</span><br><span class="hljs-comment">     * caller of zslInsert() should test in the hash table if the element is</span><br><span class="hljs-comment">     * already inside or not. */</span><br>    level = zslRandomLevel();<br>    <span class="hljs-comment">// 如果随机生成的高度大于当前 zsl 的最大高度，那么会多出来独立的几层，需要连接起来，</span><br>    <span class="hljs-comment">// 例如下面这个例子，新插入一个 8，且 8 的随机层数为 5，那么就会多出来 2 层，这两</span><br>    <span class="hljs-comment">// 层是独立的，需要将其与 head 连接起来。</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//  head                                   8 （独立）</span><br>    <span class="hljs-comment">//                                         8 （独立）</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6 --- 8</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 连接后：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[4] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[3] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6 --- 8</span><br>    <span class="hljs-keyword">if</span> (level &gt; zsl-&gt;level) &#123;<br>        <span class="hljs-comment">// 为多出的这几层进行连接</span><br>        <span class="hljs-keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;<br>            rank[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 独立的节点，那么需要用头结点作为 update</span><br>            update[i] = zsl-&gt;header;<br>            update[i]-&gt;level[i].span = zsl-&gt;length;<br>        &#125;<br>        <span class="hljs-comment">// 更新最大高度</span><br>        zsl-&gt;level = level;<br>    &#125;<br>    <span class="hljs-comment">// 创建一个节点</span><br>    x = zslCreateNode(level,score,ele);<br>    <span class="hljs-comment">// 将新节点的每一层与跳表中对应的那一层关联起来</span><br>    <span class="hljs-comment">// 比如：update[0] 指向 x[0]，update[1] 指向 x[1]</span><br>    <span class="hljs-comment">// 文字不好理解，看下面的图示：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 8    插入一个 7, 假设层数为 2</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 8</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 因为层数为 2，所以 for 2 次，每次都会将 7 的层数关联起来</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 --------- 8</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 7 - 8  第二次：4 指向 7，7 指向 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 7 - 8  第一次循环，将 7 的第一层关联起来</span><br>    <span class="hljs-comment">//                                          5 指向 7，7 指向 8</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        <span class="hljs-comment">// 就和链表的添加操作一样，要将 x 添加到 update 的后面，</span><br>        <span class="hljs-comment">// 需要先将 x 指向 update 的后一个节点，再将 update 指向 x</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// update -&gt; update.next, 要将 x 添加到 update 后面</span><br>        <span class="hljs-comment">// 1. x -&gt; update.next</span><br>        <span class="hljs-comment">// 2. update -&gt; x</span><br>        <span class="hljs-comment">// 结果：update -&gt; x -&gt; update.next</span><br>        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;<br>        update[i]-&gt;level[i].forward = x;<br><br>        <span class="hljs-comment">/* update span covered by update[i] as x is inserted here */</span><br>        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="hljs-number">0</span>] - rank[i]);<br>        update[i]-&gt;level[i].span = (rank[<span class="hljs-number">0</span>] - rank[i]) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* increment span for untouched levels */</span><br>    <span class="hljs-keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;<br>        update[i]-&gt;level[i].span++;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新新添加节点的回退指针，如果 update[0] 是 header，那么就将回退指针设置为 null，</span><br>    <span class="hljs-comment">// 不是 header，则设置为 update[0]</span><br>    <span class="hljs-comment">// 这里为什么只有 update[0] 呢？因为每个节点只有一个后退指针，</span><br>    <span class="hljs-comment">// 所以这里只需为第 1 层设置后退节点</span><br>    x-&gt;backward = (update[<span class="hljs-number">0</span>] == zsl-&gt;header) ? <span class="hljs-literal">NULL</span> : update[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 将新节点的下一节点的 backward 指向新节点（如果有下一个节点的话）</span><br>    <span class="hljs-comment">// 就和双链表的添加操作一样</span><br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward)<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 否则说明新节点是最后一个节点，此时更新 tail 为新节点</span><br>        zsl-&gt;tail = x;<br>    zsl-&gt;length++;  <span class="hljs-comment">// 节点数量 + 1</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zslDeleteNode"><a href="#zslDeleteNode" class="headerlink" title="zslDeleteNode"></a>zslDeleteNode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Internal function used by zslDelete, zslDeleteRangeByScore and</span><br><span class="hljs-comment"> * zslDeleteRangeByRank. */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">zslDeleteNode</span><span class="hljs-params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">// 删除每层中的 x</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zsl-&gt;level; i++) &#123;<br>        <span class="hljs-comment">// 如果 update 的下一个节点是 x </span><br>        <span class="hljs-keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;<br>            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 和链表的删除操作一样，将被删除的前一个节点指向要删除的后一个节点</span><br>            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            update[i]-&gt;level[i].span -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果被删除节点有下一个节点，将下一个节点的后退指针指向被删除节点的前一个节点</span><br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward) &#123;<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x-&gt;backward;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则说明被删除节点是跳表中的最后一个节点，更新 tail 为被删除</span><br>        <span class="hljs-comment">// 节点的前一个</span><br>        zsl-&gt;tail = x-&gt;backward;<br>    &#125;<br>    <span class="hljs-comment">// 更新跳表的最大高度字段</span><br>    <span class="hljs-comment">// 从最高层开始，如果头结点在该层没有下一个节点，那么说明该层为空，level--，</span><br>    <span class="hljs-comment">// 循环删除所有空层</span><br>    <span class="hljs-keyword">while</span>(zsl-&gt;level &gt; <span class="hljs-number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="hljs-number">-1</span>].forward == <span class="hljs-literal">NULL</span>)<br>        zsl-&gt;level--;<br>    <span class="hljs-comment">// 更新跳表的节点数量    </span><br>    zsl-&gt;length--;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="zslDelete"><a href="#zslDelete" class="headerlink" title="zslDelete"></a>zslDelete</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete an element with matching score/element from the skiplist.</span><br><span class="hljs-comment"> * The function returns 1 if the node was found and deleted, otherwise</span><br><span class="hljs-comment"> * 0 is returned.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If &#x27;node&#x27; is NULL the deleted node is freed by zslFreeNode(), otherwise</span><br><span class="hljs-comment"> * it is not freed (but just unlinked) and *node is set to the node pointer,</span><br><span class="hljs-comment"> * so that it is possible for the caller to reuse the node (including the</span><br><span class="hljs-comment"> * referenced SDS string at node-&gt;ele). */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">zslDelete</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele, zskiplistNode **node)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 整体流程：</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// head</span><br>    <span class="hljs-comment">// level[4] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[3] ------------------------------ 8</span><br>    <span class="hljs-comment">// level[2] ---- 1---------- 4 ----- 6 --- 8    删除 6</span><br>    <span class="hljs-comment">// level[1] ---- 1 ----- 3 - 4 ----- 6 --- 8</span><br>    <span class="hljs-comment">// level[0] ---- 1 - 2 - 3 - 4 - 5 - 6 --- 8</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 1. 先从最高处 level[4] 开始，下一个节点为 8，比 6 大，不满足 while 条件，</span><br>    <span class="hljs-comment">// x = head.level[4], update[4] = x，降到 level[3]</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 2. level[3] 和 [4] 情况一样，</span><br>    <span class="hljs-comment">// x = head.level[3], update[3] = x</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 3. level[2] 会从头结点前进到节点 4，</span><br>    <span class="hljs-comment">// x = 4, update[2] = x（其实当 score 相同时，还会继续比较 ele，这里省略）</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// 4. level[1] =&gt; x = 4, update[1] = x</span><br>    <span class="hljs-comment">// 5. level[0] =&gt; x = 5, update[0] = x</span><br>    <span class="hljs-comment">// 至此，update 记录了被删除在每层的前一个节点，x 是第一层的被删除节点的前一个</span><br>    <span class="hljs-comment">// 节点</span><br><br>    <span class="hljs-comment">// 和插入操作一样，先查找跳表，找到被删除节点在每层的前一个节点</span><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;<br>                (x-&gt;level[i].forward-&gt;score &lt; score ||<br>                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;<br>                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>)))<br>        &#123;<br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        update[i] = x;<br>    &#125;<br><br>    <span class="hljs-comment">/* We may have multiple elements with the same score, what we need</span><br><span class="hljs-comment">     * is to find the element with both the right score and object. */</span><br>    <span class="hljs-comment">// 此时的 x 是被删除节点在第一层的前一个节点，获取 x 的下一个节点</span><br>    x = x-&gt;level[<span class="hljs-number">0</span>].forward;<br>    <span class="hljs-comment">// 如果 x 存在，且 score 和 ele 都相同，调用删除节点函数进行删除</span><br>    <span class="hljs-keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="hljs-number">0</span>) &#123;<br>        zslDeleteNode(zsl, x, update);<br>        <span class="hljs-keyword">if</span> (!node)<br>            zslFreeNode(x);<br>        <span class="hljs-keyword">else</span><br>            *node = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* not found */</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>数据结构</tag>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 1493. 删掉一个元素以后全为 1 的最长子数组</title>
    <link href="/2021/08/12/leetcode-1493-shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-chang-zi-shu-zu/"/>
    <url>/2021/08/12/leetcode-1493-shan-diao-yi-ge-yuan-su-yi-hou-quan-wei-1-de-zui-chang-zi-shu-zu/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个二进制数组 nums ，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><p>提示 1：</p><p>输入：nums &#x3D; [1,1,0,1]<br>输出：3<br>解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,1,1,0,1,1,0,1]<br>输出：5<br>解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。<br>示例 3：</p><p>输入：nums &#x3D; [1,1,1]<br>输出：2<br>解释：你必须要删除一个元素。<br>示例 4：</p><p>输入：nums &#x3D; [1,1,0,0,1,1,1,0,1]<br>输出：4<br>示例 5：</p><p>输入：nums &#x3D; [0,0,0]<br>输出：0</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5<br>nums[i] 要么是 0 要么是 1 。</p></blockquote><h1 id="方法-1-滑动窗口"><a href="#方法-1-滑动窗口" class="headerlink" title="方法 1 滑动窗口"></a>方法 1 滑动窗口</h1><p><img src="https://zengh1.github.io/post-images/1628786303953.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        l, r          <span class="hljs-type">int</span><br>        windowHasZero <span class="hljs-type">bool</span>  <span class="hljs-comment">// 当前窗口内是否有 0</span><br>        zeroIndex     <span class="hljs-type">int</span><br>        res           <span class="hljs-type">int</span><br>    )<br><br>    <span class="hljs-keyword">for</span> r &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> nums[r] == <span class="hljs-number">0</span> &amp;&amp; !windowHasZero &#123;<br>            windowHasZero = <span class="hljs-literal">true</span><br>            zeroIndex = r<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[r] == <span class="hljs-number">0</span> &amp;&amp; windowHasZero &#123;<br>            z := zeroIndex<br>            <span class="hljs-comment">// 更新当前位置为新的 zeroIndex</span><br>            zeroIndex = r<br>            res = max(res, r-l<span class="hljs-number">-1</span>)<br>            <span class="hljs-comment">// l 移动到之前 0 所在位置之后</span><br>            l = z + <span class="hljs-number">1</span>    <br>        &#125;<br>        r++<br>    &#125;<br>    res = max(res, r-l<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git clone 速度慢的解决方法</title>
    <link href="/2021/08/11/git-clone-su-du-man/"/>
    <url>/2021/08/11/git-clone-su-du-man/</url>
    
    <content type="html"><![CDATA[<p>使用国内镜像，目前已知Github国内镜像网站有 github.com.cnpmjs.org 和 git.sdut.me&#x2F; 。速度根据各地情况而定，在clone某个项目的时候将 github.com 替换为 github.com.cnpmjs.org 即可。</p><p>来源：<a href="https://blog.csdn.net/hzlarm/article/details/115415038">https://blog.csdn.net/hzlarm/article/details/115415038</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git push error: remote: fatal error in commit_refs</title>
    <link href="/2021/08/11/git-push-error-remote-fatal-error-in-commit_refs/"/>
    <url>/2021/08/11/git-push-error-remote-fatal-error-in-commit_refs/</url>
    
    <content type="html"><![CDATA[<p>在一如既往地执行 <code>git push</code> 到 Github 时，出现了一个从未遇到过的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">remote: fatal error in commit_refs<br>To https://github.com/xxx<br> ! [remote rejected] master -&gt; master (failure)<br>error: failed to push some refs to &#x27;https://github.com/xxx&#x27;<br></code></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fsck<br>git gc<br></code></pre></td></tr></table></figure><p>参考： <a href="https://stackoverflow.com/questions/37341960/how-do-i-fix-remote-fatal-error-in-commit-refs-errors-trying-to-push-with-git#comment75666427_37342002">https://stackoverflow.com/questions/37341960/how-do-i-fix-remote-fatal-error-in-commit-refs-errors-trying-to-push-with-git#comment75666427_37342002</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个 main goroutine 操作一个 channel 会怎样</title>
    <link href="/2021/08/08/liang-ge-main-goroutine-cao-zuo-yi-ge-channel-hui-zen-yang/"/>
    <url>/2021/08/08/liang-ge-main-goroutine-cao-zuo-yi-ge-channel-hui-zen-yang/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>定义一个全局变量 <code>chan</code>，然后创建两个 main goroutine，一个往全局 <code>chan</code> 里发送数据，一个从全局 <code>chan</code> 里读取数据，会发生什么？</p><p>这个奇葩问题是我在写一个 server 项目时遇到的，当时的情景是：想为 <code>server</code> 添加一个心跳检测功能，客户端每隔一段时间就向服务端发送一个心跳包，服务端这边维持一个定时器，如果收到心跳包则重置，如果定时器到时则认为客户端已断开，关闭 socket 连接。考虑到心跳包产生的网络传输开销，突发奇想，可不可以用一个全局 <code>channel</code> 来代替？</p><p>于是便定义了一个全局 <code>channel</code>，客户端每隔一段时间就向 <code>channel</code> 中写入数据，服务端使用 <code>select</code> 来读取 <code>channel</code>。但是测试时却发现，客户端处的发送语句 <code>ch &lt;- struct&#123;&#125;&#123;&#125;</code> 被阻塞了，于是又将全局 <code>channel</code> 改为带缓冲的，缓冲为 1，此时再次运行，客户端的发送语句没有被阻塞了，但是服务端那边却压根收不到数据。</p><h1 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h1><p>创建一个 <code>global</code> 包，在其下新建一个 go 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> global<br><br><span class="hljs-keyword">var</span> Ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>创建一个 <code>cli</code> 包及其之下的 go 文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gomodtest/sockchan/global&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second * <span class="hljs-number">8</span>) :<br>fmt.Println(<span class="hljs-string">&quot;timeout !&quot;</span>)<br><span class="hljs-keyword">case</span> v := &lt;-global.Ch:<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后创建一个 <code>sev</code> 包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;gomodtest/sockchan/global&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;send data to global chan&quot;</span>)<br>global.Ch &lt;- <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;send ok&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">├── cli<br>│   └── cli.go<br>├── global<br>│   └── var.go<br>└── sev<br>    └── sev.go<br></code></pre></td></tr></table></figure><p>先运行 <code>cli.go</code>，再开一个 termin 运行 <code>sev.go</code>：</p><p><code>sev.go</code> 输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  sev go run sev.go<br>send data to global chan<br>send ok<br></code></pre></td></tr></table></figure><p><code>cli.go</code> 输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  cli go run cli.go<br>timeout !<br></code></pre></td></tr></table></figure><p>结果说明，可以向 <code>chan</code> 中写入数据，但是不能从 <code>chan</code> 中读取数据。 </p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>两个 main 代表两个进程，进程间通信当然不能使用 channel 了（如此弱智的问题）</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 最左前缀原则失效</title>
    <link href="/2021/08/07/mysql-zui-zuo-qian-zhui-yuan-ze-shi-xiao/"/>
    <url>/2021/08/07/mysql-zui-zuo-qian-zhui-yuan-ze-shi-xiao/</url>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>（<del>以后 mysql 的输出还是截图好一些，复制粘贴格式会很难看</del> 凑合看就完事了）</p><p>有如下表，结构如下，注意其还拥有一个名为 idx_name_age 的，内容为 (name, age) 的联合索引。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------+-------------+------+-----+---------+----------------+<br>|<span class="hljs-string"> Field </span>|<span class="hljs-string"> Type        </span>|<span class="hljs-string"> Null </span>|<span class="hljs-string"> Key </span>|<span class="hljs-string"> Default </span>|<span class="hljs-string"> Extra          </span>|<br>+-------+-------------+------+-----+---------+----------------+<br>|<span class="hljs-string"> id    </span>|<span class="hljs-string"> int         </span>|<span class="hljs-string"> NO   </span>|<span class="hljs-string"> PRI </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string"> auto_increment </span>|<br>|<span class="hljs-string"> name  </span>|<span class="hljs-string"> varchar(50) </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string"> MUL </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">                </span>|<br>|<span class="hljs-string"> age   </span>|<span class="hljs-string"> int         </span>|<span class="hljs-string"> YES  </span>|<span class="hljs-string">     </span>|<span class="hljs-string"> NULL    </span>|<span class="hljs-string">                </span>|<br>+-------+-------------+------+-----+---------+----------------+<br></code></pre></td></tr></table></figure><blockquote><p>PS: 建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE stu_join_index (<br>  id INT NOT NULL AUTO_INCREMENT,<br>  name VARCHAR(50),<br>  age INT,<br>  PRIMARY KEY (id),<br>  INDEX idx_name_age (name, age)<br>);<br></code></pre></td></tr></table></figure><p>此外，我们还可以插入一些数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO stu_join_index (name, age)<br>VALUES<br>  (&#x27;John&#x27;, 20),<br>  (&#x27;Alice&#x27;, 25),<br>  (&#x27;Bob&#x27;, 22),<br>  (&#x27;Emily&#x27;, 21),<br>  (&#x27;David&#x27;, 23),<br>  (&#x27;Sophia&#x27;, 24),<br>  (&#x27;Michael&#x27;, 26),<br>  (&#x27;Olivia&#x27;, 19),<br>  (&#x27;Emma&#x27;, 27),<br>  (&#x27;Daniel&#x27;, 20);<br></code></pre></td></tr></table></figure></blockquote><p>执行下面的 SQL 语句，看看这次查询的索引使用信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;20&#x27;</span>;<br></code></pre></td></tr></table></figure><p>运行后发现 <code>type</code> 为 <code>index</code>，这代表这次查询走了索引。</p><p>（2022.3.20 更新：index 代表的是会对整个索引树进行扫描，仅比 all（全表扫描）要快一些 <del>其实也等同于全表查询，至于 index 相比 all 效率会不会更高，查阅了一些资料，都说 index 效率要更快一些</del>）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------------------</span>+<br>| id | select_type | table          | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | index | idx_name_age  | idx_name_age | 208     | NULL |   10 |    10.00 | Using where; Using index |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">--------------------------</span>+<br></code></pre></td></tr></table></figure><p>这就奇怪了，按照 Mysql 最左前缀原则，建立的索引是 (name, age) ，应该只有 (name)，(name，age) 会走索引啊？再尝试查询一下（age, name），看会不会走索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;25&#x27;</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ref  | idx_name_age  | idx_name_age | 208     | const,const |    1 |   100.00 | Using index |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">--------------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br></code></pre></td></tr></table></figure><p>可以看到这里也同样走了索引，这是为什么呢？</p><blockquote><p>补充：<code>Extra</code> 显示的是 <code>Using where; Using index</code>，其中的 <code>Using index</code> 代表：从表中仅使用索引树中的信息就能获取查询语句的列的信息, 而不必进行其他额外查找（seek）去读取实际的行记录。当查询的列是单个索引的部分的列时, 可以使用此策略。（简单的翻译就是：使用索引来直接获取列的数据，而不需回表，即覆盖索引）。</p></blockquote><p>后来在网上找到了一个同样问题的 <a href="https://segmentfault.com/a/1190000022690969">文章</a>，他的情况和我一样，创建了一张表，表中总共有四个字段。 id 为主键，还有一个由 name，age，address 组成的联合索引，当他执行下面的 SQL 时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> address<span class="hljs-operator">=</span><span class="hljs-string">&#x27;beijing&#x27;</span>;<br></code></pre></td></tr></table></figure><p>同样发现 <code>type</code> 字段为 <code>index</code>，即走了索引。</p><p>最终在评论区找到了答案：</p><blockquote><p>总结下，不是最左原则失效了。是因为一开始设计的字段只有四个：(id,name,age,address)，此时的联<br>合索引是（name, age, address），id 自带一个主键索引。相当于，四个字段都有索引。因为覆盖索引<br>的缘故，怎么查都会走索引。当增加一个字段（use）后，该字段没有索引，因此 select * 的时候不会<br>触发覆盖索引，因此不会走索引。但是如果只查询 select name,age,address,id 的话依然会走索引</p></blockquote><p>于是我进行了进一步测试，为表添加一个字段并插入一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stu_join_index <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> score <span class="hljs-type">int</span>;<br><span class="hljs-keyword">update</span> stu_join_index <span class="hljs-keyword">set</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时的表信息如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+---------+------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name    <span class="hljs-operator">|</span> age  <span class="hljs-operator">|</span> score <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+---------+------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> John    <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> Alice   <span class="hljs-operator">|</span>   <span class="hljs-number">25</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">3</span> <span class="hljs-operator">|</span> Bob     <span class="hljs-operator">|</span>   <span class="hljs-number">22</span> <span class="hljs-operator">|</span>    <span class="hljs-number">90</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">4</span> <span class="hljs-operator">|</span> Emily   <span class="hljs-operator">|</span>   <span class="hljs-number">21</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">5</span> <span class="hljs-operator">|</span> David   <span class="hljs-operator">|</span>   <span class="hljs-number">23</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">6</span> <span class="hljs-operator">|</span> Sophia  <span class="hljs-operator">|</span>   <span class="hljs-number">24</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">7</span> <span class="hljs-operator">|</span> Michael <span class="hljs-operator">|</span>   <span class="hljs-number">26</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">8</span> <span class="hljs-operator">|</span> Olivia  <span class="hljs-operator">|</span>   <span class="hljs-number">19</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">9</span> <span class="hljs-operator">|</span> Emma    <span class="hljs-operator">|</span>   <span class="hljs-number">27</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">10</span> <span class="hljs-operator">|</span> Daniel  <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+---------+------+-------+</span><br></code></pre></td></tr></table></figure><p>此时再使用 (score, age) 条件进行查询，看看结果如何：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">22</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>可以看到此时 <code>type</code> 变为了 <code>ALL</code>，代表要扫描全表。</p><p>因为 (name, age) 相当于创建了 name 单列索引和 (name, age) 联合索引。对于多个字段的联合索引，也同理，比如 index(a, b, c) 这个联合索引，相当于创建了 a 单列索引，(a, b) 联合索引，和 (a, b, c )联合索引。上面的查询条件 (score, age) 既没有联合索引，各自也没有单列索引，所以自然要扫描全表。</p><p>测试：</p><p>思考一下，之前的查询语句 <code>explain select * from stu_join_index where age = 20;</code> 还会不会走索引？</p><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key  <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>可以看到此时的 type 为 ALL，这是为什么呢？</p><p>我的猜测是，因为我们加了一个非索引字段 <code>score</code>，而我们的查询结果又是 *，而查询条件又是 age 这个无索引字段（我们创建的联合索引是 name, age），所以就会走全表扫描，但是 Extra 这里的 <code>Using where</code> 又是什么意思呢？</p><blockquote><p>来自 ChatGPT：</p><p>在 MySQL 的 <code>Extra</code> 列中，<code>Using where</code> 表示查询需要在存储引擎层面使用额外的条件过滤。具体含义如下：</p><ul><li><code>Using where</code> 表示在读取行数据后，MySQL 需要进一步应用 WHERE 条件进行过滤，以满足查询条件。这意味着查询结果中可能包含一些不符合 WHERE 条件的行，需要在 MySQL 层面进行进一步过滤。</li><li>当出现 <code>Using where</code> 时，MySQL 可能会使用索引或者全表扫描来获取满足 WHERE 条件的行数据。如果查询涉及到大量数据，或者没有适用的索引，可能会导致性能下降。</li><li>注意，<code>Using where</code> 并不表示一定会使用索引，它只表示需要在查询结果集上进行进一步的条件过滤。具体是否使用索引还需要考虑索引的定义、查询条件的复杂性以及数据分布等因素。</li></ul><p>总之，<code>Using where</code> 表示查询需要在 MySQL 层面进一步过滤数据以满足 WHERE 条件，但不表示一定会使用索引。需要综合考虑索引的设计和查询条件的优化，以提高查询性能。</p></blockquote><p>如果我们将查询条件修改为 name，或者查询结果由 * 改为 id,name,age，结果又会如何？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">203</span>     <span class="hljs-operator">|</span> const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span><br><br>explain <span class="hljs-keyword">select</span> id,name,age <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> index <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">208</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>   <span class="hljs-number">10</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> index <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br></code></pre></td></tr></table></figure><p>可以看到，这两个查询都走了索引</p><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><h2 id="1-where-条件只有-name"><a href="#1-where-条件只有-name" class="headerlink" title="1. where 条件只有 name"></a>1. where 条件只有 name</h2><p>如果 <code>where</code> 条件只有 <code>score</code> ，或者只有 <code>age</code> ，结果会怎样呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;12&#x27;</span>;<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |    20.00 | Using where |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br></code></pre></td></tr></table></figure><p>结果会扫描全表。这是因为 <code>socre</code> 和 <code>age</code> 都没有单列索引。</p><p>但是当 <code>where</code> 条件只有 <code>name</code> 时会怎样呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ref  | name_age      | name_age | 203     | const |    1 |   100.00 | NULL  |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">-------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------</span>+<br></code></pre></td></tr></table></figure><p>此时 <code>type</code> 为 <code>ref</code>，在上面已经说过，(name, age) 联合索引会同时创建一个 <code>name</code> 单列索引。但是这里为什么是 <code>ref</code> 而不是 <code>index</code> 呢？</p><blockquote><p><code>ref</code> 使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值的记录行。</p><p>出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</p></blockquote><p>我的猜测：</p><p><del>在没有添加 <code>score</code> 字段前，联合索引 (name, age) 是覆盖索引，但是添加了 <code>score</code> 后便不再是覆盖索引了</del></p><p>覆盖索引依然是 <code>ref</code></p><h2 id="2-为什么-name-为非字符串时不走索引"><a href="#2-为什么-name-为非字符串时不走索引" class="headerlink" title="2. 为什么 name 为非字符串时不走索引"></a>2. 为什么 name 为非字符串时不走索引</h2><p>在 1 中提到，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span>;<br></code></pre></td></tr></table></figure><p>的 <code>type</code> 为 <code>ref</code>，那么如果把查询条件改为非字符串会怎样呢？（name 为 varchar 类型）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>| id | select_type | table          | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br>|  1 | SIMPLE      | stu_join_index | NULL       | ALL  | name_age      | NULL | NULL    | NULL |    5 |    20.00 | Using where |<br>+<span class="hljs-params">----</span>+<span class="hljs-params">-------------</span>+<span class="hljs-params">----------------</span>+<span class="hljs-params">------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">---------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">-------------</span>+<br></code></pre></td></tr></table></figure><p>结果变为了 <code>ALL</code>，为什么不是字符串就会索引失效呢？</p><p><strong>回答</strong></p><p>在博客 <a href="https://blog.csdn.net/qq_28194001/article/details/90488782">https://blog.csdn.net/qq_28194001/article/details/90488782</a> 中得出结论：</p><blockquote><ol><li>当我们使用的字段是数值类型时，加引号或者不加引号（sql中单引号和双引号实现相同效果）都不影响<br>索引的使用</li><li>当我们的字段是字符串类型时，不加引号的查询无法使用索引，加引号的查询才可正常使用索引</li></ol></blockquote><p>但是还是没给出原因，于是我又问了下 ChatGPT：</p><blockquote><p>Q：为什么 select * from stu_join_index where name &#x3D; ‘aa’; 会走索引，而 select * from stu_join_index where name &#x3D; 1 不会？</p><p>A：<code>select * from stu_join_index where name = 1;</code> 不会走索引：</p><p>这条查询语句中的条件 <code>name = 1</code> 的值类型为整数，而 <code>name</code> 字段的索引 <code>idx_name_age</code> 是建立在字符串类型上的。索引是按照索引列的数据类型进行排序和比较的，因此，整数值无法直接匹配到字符串类型的索引，所以无法使用该索引进行快速查找。在这种情况下，MySQL可能会选择全表扫描的方式来查找满足条件的行。</p></blockquote><blockquote><p>然后我又突发奇想，问了一下另外一种情况：</p><p>Q：那如果查询条件对应的列是 int 类型，但是我加了引号，比如 age &#x3D; ‘1’，这样会走索引吗</p><p>A：当查询条件对应的列是整数类型（如<code>int</code>），但是你将查询条件的值用引号括起来（如<code>age = &#39;1&#39;</code>），MySQL 会进行类型转换以匹配索引列的数据类型。在这种情况下，MySQL 通常会尝试将字符串类型的查询条件转换为整数类型，并尝试使用索引来进行匹配。</p><p>因此，在你提到的情况下，如果索引 <code>idx_name_age</code> 的列 <code>age</code> 是整数类型，MySQL 会尝试将查询条件中的字符串 <code>&#39;1&#39;</code> 转换为整数，并使用该索引进行匹配。如果转换成功，MySQL 将能够使用索引来加速查询。</p><p>需要注意的是，类型转换可能会带来一些性能开销，并且在某些情况下可能会导致索引失效。所以，最佳实践是确保查询条件的值与索引列的数据类型相匹配，这样可以更好地利用索引的优势。</p></blockquote><h2 id="3-不符合最左匹配原则但还是走了索引"><a href="#3-不符合最左匹配原则但还是走了索引" class="headerlink" title="3. 不符合最左匹配原则但还是走了索引"></a>3. 不符合最左匹配原则但还是走了索引</h2><p>再来看一种情况：<br>此时执行 (name, score, age)，看看结果如何：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-keyword">and</span> score <span class="hljs-operator">=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>         <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra       <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">208</span>     <span class="hljs-operator">|</span> const,const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>    <span class="hljs-number">10.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------------+</span><br></code></pre></td></tr></table></figure><p>这里明明不符合最左前缀原则，为什么 <code>type</code> 会是  <code>ref</code>？</p><blockquote><p>来自 ChatGPT：</p><p>在你提供的查询语句 <code>select * from stu_join_index where name = &#39;aa&#39; and score = 90 and age = 12;</code> 中，尽管不符合最左前缀原则，但是 MySQL 优化器可能会选择使用索引进行查询。</p><p>这是因为索引的选择并不仅仅依赖于最左前缀原则，MySQL 优化器会根据多个因素进行选择，包括索引的选择性、数据分布情况、查询的复杂度等。在某些情况下，MySQL 可能会选择使用较长的索引前缀或者联合索引的一部分来进行查询，而不仅仅局限于最左前缀。</p><p>在你的查询中，如果联合索引 <code>idx_name_age</code> 的前缀列 <code>name</code> 在数据分布上非常选择性高，且其他列的选择性也足够高，MySQL 可能会选择使用该索引进行查询，并且 <code>type</code> 字段显示为 <code>ref</code>。这表示使用了非唯一性索引，并且通过索引进行了范围查找。</p><p>需要注意的是，优化器的行为受多个因素影响，包括数据库的统计信息、查询的复杂度、索引的选择性等等。因此，虽然某些情况下 MySQL 可能会选择使用不符合最左前缀原则的索引，但并不是绝对的，具体的选择还是取决于优化器的判断和算法。</p></blockquote><h2 id="4-index-和-ref-的区别，以及二者各自触发的场景"><a href="#4-index-和-ref-的区别，以及二者各自触发的场景" class="headerlink" title="4. index 和 ref 的区别，以及二者各自触发的场景"></a>4. index 和 ref 的区别，以及二者各自触发的场景</h2><p>再次执行下面的语句（在文章一开始还没有添加 score 字段时，执行过该语句）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> stu_join_index <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-keyword">and</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;aa&#x27;</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>          <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key          <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>         <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> stu_join_index <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> idx_name_age  <span class="hljs-operator">|</span> idx_name_age <span class="hljs-operator">|</span> <span class="hljs-number">208</span>     <span class="hljs-operator">|</span> const,const <span class="hljs-operator">|</span>    <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+----------------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+</span><br></code></pre></td></tr></table></figure><p>为什么加了 <code>score</code> 字段后， <code>type</code> 从 <code>index</code> 变为了 <code>ref</code>？</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信的方式</title>
    <link href="/2021/08/06/jin-cheng-jian-tong-xin-de-fang-shi/"/>
    <url>/2021/08/06/jin-cheng-jian-tong-xin-de-fang-shi/</url>
    
    <content type="html"><![CDATA[<p>这是一道面试高频题</p><h1 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h1><p>无名管道只能用于父子进程之间的通信，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/3/5.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lib/apue.h&quot;</span></span><br><br><span class="hljs-comment">// 无名管道：只能在父子进程之间通信</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pipe_t</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fp[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// pipe()：创建一个管道，经由参数 fd 返回两个文件描述符，fp[0] 为读打开，fp[1] 为写打开</span><br>    <span class="hljs-type">int</span> err = pipe(fp);<br>    <span class="hljs-comment">// 成功返回 0，失败返回 -1</span><br>    err == <span class="hljs-number">0</span> ? <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok&quot;</span>) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create pipe error&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过管道，从父进程传输数据到子进程</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">parent_to_child_pipe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> line[MAXLINE];<br><br>    <span class="hljs-keyword">if</span> (pipe(fd) &lt; <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">// 由父进程创建一个管道，子进程会继承父进程所创建的管道</span><br>        err_sys(<span class="hljs-string">&quot;pipe error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( (pid = fork()) &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// fork 创建一个子进程</span><br>        err_sys(<span class="hljs-string">&quot;fork error&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 父进程</span><br>        close(fd[<span class="hljs-number">0</span>]);    <span class="hljs-comment">// 因为是 父 -&gt; 子，所以关闭父进程的读端 fd[0]</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程发送数据...\n&quot;</span>);<br>        write(fd[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-comment">// 该子进程会继承父进程所创建的管道</span><br>        close(fd[<span class="hljs-number">1</span>]);   <span class="hljs-comment">// 因为是 父 -&gt; 子，所以关闭子进程的写端 fd[1]</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程读取数据...\n&quot;</span>);<br>        n = read(fd[<span class="hljs-number">0</span>], line, <span class="hljs-keyword">sizeof</span>(line));<br>        write(STDOUT_FILENO, line, n);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    parent_to_child_pipe();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ./pipe<br>父进程发送数据...<br>子进程读取数据...<br>hello world<br></code></pre></td></tr></table></figure><h1 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h1><p>命名管道（FIFO）可以用于任意两个进程之间的通信。要想使用，首先需要创建一个 FIFO 文件，之后可以通过对其的读写来完成通信操作。</p><p>为了体现出 <strong>任意两个进程</strong> 这一特点，会创建两个 c 文件，一个是 <code>fifo_write.c</code>，它负责创建一个 FIFO 文件并向其中写入 “Hello, World!”，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lib/apue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIFO_NAME <span class="hljs-string">&quot;/tmp/my_fifo&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果文件不存在，则创建一个管道</span><br>    <span class="hljs-keyword">if</span> (access(FIFO_NAME, F_OK) == <span class="hljs-number">-1</span>) &#123;<br>        res = mkfifo(FIFO_NAME, <span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mkfifo error: %s \n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 以只写方式打开管道</span><br>    <span class="hljs-type">int</span> pipe_fd = open(FIFO_NAME, O_WRONLY);<br>    <span class="hljs-keyword">if</span> (pipe_fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">memset</span>(&amp;buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-built_in">strcpy</span>(buf, <span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>    <span class="hljs-comment">// 向 fifo 中写入数据</span><br>    <span class="hljs-type">int</span> n = write(pipe_fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data to fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d write %d bytes to fifo \n&quot;</span>, getpid(), n);<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个文件时 <code>fifo_read.c</code>，它负责从 FIFO 管道中读取数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/8/6.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../lib/apue.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FIFO_NAME <span class="hljs-string">&quot;/tmp/my_fifo&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只读方式打开管道</span><br>    <span class="hljs-type">int</span> pipe_fd = open(FIFO_NAME, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (pipe_fd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">memset</span>(&amp;buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-comment">// 从管道中读取数据</span><br>    <span class="hljs-type">int</span> n = read(pipe_fd, buf, <span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data from fifo error: %s \n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;process %d read from fifo: %s \n&quot;</span>, getpid(), buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面的代码创建的是 <strong>阻塞</strong> 命名管道，运行结果如下：</p><p>先运行 <code>fifo_write.c</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译 fifo_write.c</span><br>➜  gcc -o fw fifo_write.c ../lib/apue.c<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>./fw<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行后，发现整个程序阻塞了，没有任何反应</span><br></code></pre></td></tr></table></figure><p>再创建一个 terminal，运行 <code>fifo_read.c</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>➜  gcc -o fr fifo_read.c ../lib/apue.c<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>./fr<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出结果</span><br>process 7601 read from fifo: Hello, World! <br></code></pre></td></tr></table></figure><p>此时再看 <code>fifo_write</code> 的 terminal，发现已经停止阻塞了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">process 7517 write 1024 bytes to fifo <br></code></pre></td></tr></table></figure><p>是不是发现实名管道和 Go 中的无缓冲 channel 非常相似呢？当向 channel 写入数据时，整个 goroutine 会进入阻塞状态，直到有另外一个 goroutine 从该 channel 中取出数据，才会停止阻塞。从 channel 中读取数据也是一样的，只有 channel 中存在数据才能读取，否则就会进入阻塞。</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>（内容来自 <a href="https://blog.csdn.net/ljianhui/article/details/10287879%EF%BC%89">https://blog.csdn.net/ljianhui/article/details/10287879）</a></p><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。  每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p><code>Linux</code> 用宏 <code>MSGMAX</code> 和 <code>MSGMNB</code> 来限制一条消息的最大长度和一个队列的最大长度。</p><h2 id="消息队列的-API"><a href="#消息队列的-API" class="headerlink" title="消息队列的 API"></a>消息队列的 API</h2><h3 id="msgget-函数"><a href="#msgget-函数" class="headerlink" title="msgget 函数"></a>msgget 函数</h3><p>该函数用来创建和访问一个消息队列。它的原型为：<br><code>int msgget(key_t key, int msgflg);</code><br>与其他的 IPC 机制一样，程序必须提供一个键来命名某个特定的消息队列。<code>msgflg</code> 是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。<code>msgflg</code> 可以与 <code>IPC_CREAT</code> 做或操作，表示当 <code>key</code> 所命名的消息队列不存在时创建一个消息队列，如果 <code>key</code> 所命名的消息队列存在时，<code>IPC_CREAT</code> 标志会被忽略，而只返回一个标识符。</p><p>它返回一个以 <code>key</code> 命名的消息队列的标识符（非零整数），失败时返回-1.</p><h3 id="msgsnd-函数"><a href="#msgsnd-函数" class="headerlink" title="msgsnd 函数"></a>msgsnd 函数</h3><p>该函数用来把消息添加到消息队列中。它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">msgsend</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *msg_ptr, <span class="hljs-type">size_t</span> msg_sz, <span class="hljs-type">int</span> msgflg)</span>;<br></code></pre></td></tr></table></figure><p><code>msgid</code> 是由 <code>msgget</code> 函数返回的消息队列标识符。</p><p><code>msg_ptr</code> 是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针 <code>msg_ptr</code> 所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。所以消息结构要定义成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_message</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> message_type;<br>    <span class="hljs-comment">/* The data you wish to transfer*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>msg_sz</code> 是 <code>msg_ptr</code> 指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说<code>msg_sz</code> 是不包括长整型消息类型成员变量的长度。</p><p><code>msgflg</code> 用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。</p><p>如果调用成功，消息数据的一分副本将被放到消息队列中，并返回 0，失败时返回 -1.</p><h3 id="msgrcv-函数"><a href="#msgrcv-函数" class="headerlink" title="msgrcv 函数"></a>msgrcv 函数</h3><p>该函数用来从一个消息队列获取消息，它的原型为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">void</span> *msg_ptr, <span class="hljs-type">size_t</span> msg_st, <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype, <span class="hljs-type">int</span> msgflg)</span>;<br></code></pre></td></tr></table></figure><p><code>msgid, msg_ptr, msg_s</code>t 的作用也函数 <code>msgsnd</code> 函数的一样。</p><p><code>msgtype</code> 可以实现一种简单的接收优先级。如果 <code>msgtype</code> 为 0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于 <code>msgtype</code> 的绝对值的第一个消息。（ps: ？？？这里没太看懂）</p><p><code>msgflg</code> 用于控制当队列中没有相应类型的消息可以接收时将发生的事情。</p><p>调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由 <code>msg_ptr</code> 指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回 -1.</p><h3 id="msgctl函数"><a href="#msgctl函数" class="headerlink" title="msgctl函数"></a>msgctl函数</h3><p>该函数用来控制消息队列，它与共享内存的 <code>shmctl</code> 函数相似，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msgid, <span class="hljs-type">int</span> command, <span class="hljs-keyword">struct</span> msgid_ds *buf)</span>;<br></code></pre></td></tr></table></figure><p><code>command</code> 是将要采取的动作，它可以取3个值，<br>    <strong>IPC_STAT</strong>：把 <code>msgid_ds</code> 结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖 <code>msgid_ds</code> 的值。<br>    <strong>IPC_SET</strong>：如果进程有足够的权限，就把消息列队的当前关联值设置为 <code>msgid_ds</code> 结构中给出的值<br>    <strong>IPC_RMID</strong>：删除消息队列</p><p><code>buf</code> 是指向 <code>msgid_ds</code> 结构的指针，它指向消息队列模式和访问权限的结构。<code>msgid_ds</code> 结构至少包括以下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uid_t</span> shm_perm.uid;<br>    <span class="hljs-type">uid_t</span> shm_perm.gid;<br>    <span class="hljs-type">mode_t</span> shm_perm.mode;<br>&#125;;<br></code></pre></td></tr></table></figure><p>成功时返回 0，失败时返回 -1.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是 <code>mq_recv</code> 的代码，负责从消息队列中取出消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/8/6.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> msg_type;<br>    <span class="hljs-type">char</span> text[BUFSIZ];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> running = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> msgid = <span class="hljs-number">-1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">data</span>;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype = <span class="hljs-number">0</span>; <span class="hljs-comment">//注意1</span><br><br>    <span class="hljs-comment">// 建立消息队列</span><br>    msgid = msgget((<span class="hljs-type">key_t</span>) <span class="hljs-number">1234</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgget failed with error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-comment">// 从队列中获取消息，直到遇到 end 消息为止</span><br>    <span class="hljs-keyword">while</span> (running) &#123;<br>        <span class="hljs-keyword">if</span> (msgrcv(msgid, (<span class="hljs-type">void</span> *) &amp;data, BUFSIZ, msgtype, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgrcv failed with errno: %d\n&quot;</span>, errno);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You wrote: %s\n&quot;</span>, data.text);<br>        <span class="hljs-comment">// 遇到end结束</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(data.text, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>            running = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 删除消息队列</span><br>    <span class="hljs-keyword">if</span> (msgctl(msgid, IPC_RMID, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgctl(IPC_RMID) failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是 <code>mq_send</code> 的代码，负责发送消息到消息队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by zz on 2021/8/6.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TEXT 512</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> msg_type;<br>    <span class="hljs-type">char</span> text[MAX_TEXT];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> running = <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msg_st</span> <span class="hljs-title">data</span>;</span><br>    <span class="hljs-type">char</span> buffer[BUFSIZ];<br>    <span class="hljs-type">int</span> msgid = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 建立消息队列</span><br>    msgid = msgget((<span class="hljs-type">key_t</span>) <span class="hljs-number">1234</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br>    <span class="hljs-keyword">if</span> (msgid == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgget failed with error: %d\n&quot;</span>, errno);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 向消息队列中写消息，直到写入 end</span><br>    <span class="hljs-keyword">while</span> (running) &#123;<br>        <span class="hljs-comment">//输入数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter some text: &quot;</span>);<br>        fgets(buffer, BUFSIZ, <span class="hljs-built_in">stdin</span>);<br>        data.msg_type = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 注意2</span><br>        <span class="hljs-built_in">strcpy</span>(data.text, buffer);<br>        <span class="hljs-comment">// 向队列发送数据</span><br>        <span class="hljs-keyword">if</span> (msgsnd(msgid, (<span class="hljs-type">void</span> *) &amp;data, MAX_TEXT, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;msgsnd failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>        <span class="hljs-comment">// 输入 end 结束输入</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(buffer, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>)<br>            running = <span class="hljs-number">0</span>;<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>为了验证消息队列可以避免命名管道的同步和阻塞问题，这里先运行 <code>mq_send</code>，向消息队列中发送 3 条消息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜   ./mq_send<br>Enter some text: 123<br>Enter some text: 456<br>Enter some text: 789<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送了 3 条消息</span><br></code></pre></td></tr></table></figure><p>再开启一个 terminal 运行 <code>mq_recv</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜   ./mq_recv<br>You wrote: 123<br><br>You wrote: 456<br><br>You wrote: 789<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从消息队列中取出了消息</span><br></code></pre></td></tr></table></figure><p>如果先运行 <code>mq_recv</code>，则程序会阻塞，直到消息队列中有数据。</p><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p>（ps: 这部分先不实践了）</p><p>这里主要说明一下消息类型是怎么一回事，注意 <code>msgreceive.</code>c 文件 <code>main</code> 函数中定义的变量 <code>msgtype</code>（注释为注意1），它作为 <code>msgrcv</code> 函数的接收信息类型参数的值，其值为 0，表示获取队列中第一个可用的消息。再来看看 <code>msgsend.c</code> 文件中 while 循环中的语句 <code>data.msg_type = 1</code>（注释为注意2），它用来设置发送的信息的信息类型，即其发送的信息的类型为 1 。所以程序 <code>msgreceive</code> 能够接收到程序 <code>msgsend</code> 发送的信息。</p><p>如果把注意1，即 <code>msgreceive.c</code> 文件 <code>main</code> 函数中的语句由 <code>long int msgtype = 0;</code> 改变为 <code>l ong int msgtype = 2;</code> 会发生什么情况，<code>msgreceive</code> 将不能接收到程序 <code>msgsend</code> 发送的信息。因为在调用 <code>msgrcv</code> 函数时，如果 <code>msgtype</code>（第四个参数）大于零，则将只获取具有相同消息类型的第一个消息，修改后获取的消息类型为2，而 <code>msgsend</code> 发送的消息类型为 1 ，所以不能被 <code>msgreceive</code> 程序接收。重新编译 <code>msgreceive.c</code> 文件并再次执行，其结果如下：</p><h2 id="消息队列与命名管道的比较"><a href="#消息队列与命名管道的比较" class="headerlink" title="消息队列与命名管道的比较"></a>消息队列与命名管道的比较</h2><p>消息队列跟命名管道有不少的相同之处，通过与命名管道一样，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用 <code>write</code> ，接收数据用<code>read</code>，则在消息队列中，发送数据用 <code>msgsnd</code>，接收数据用 <code>msgrcv</code>。而且它们对每个数据都有一个最大长度的限制。</p><p>与命名管道相比，消息队列的优势在于，1、消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难。2、同时通过发送消息还可以避免命名管道的同步和阻塞问题，不需要由进程自己来提供同步方法。3、接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。</p><h2 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h2><p>一是通信不及时，二是附件也有大小限制，这同样也是消息队列通信不足的点。</p><p>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>如果 <code>socket</code> 类型为 <code>TCP</code> 和 <code>UDP</code> ，那么可以在不同主机的进程间进行通信。<br>如果 <code>socket</code> 类型为 <code>UNIX</code>，可以在同一主机下的进程间通信。<br><code>TCP</code> 和 <code>UDP</code> 比较熟悉了，这里主要介绍一下 <code>UNIX</code>，代码示例采用 <code>Go</code>：</p><p><code>unxi_write</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filename := <span class="hljs-string">&quot;/tmp/gounix.sock&quot;</span><br>l, err := net.Listen(<span class="hljs-string">&quot;unix&quot;</span>, filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;listen error: &quot;</span>, err)<br>os.Remove(filename)<span class="hljs-comment">// 出现错误一般是因为文件已存在，所以需要删除</span><br><span class="hljs-keyword">return</span><br>&#125;<br>log.Println(<span class="hljs-string">&quot;创建 UNIX Domain Socket 成功&quot;</span>)<br><span class="hljs-keyword">defer</span> l.Close()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := l.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;accept error: &quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 向 unix 文件中写入数据</span><br>conn.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>))<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>unix_read</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>filename := <span class="hljs-string">&quot;/tmp/gounix.sock&quot;</span><br>conn, err := net.Dial(<span class="hljs-string">&quot;unix&quot;</span>, filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;dial error: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>_, err = conn.Read(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;read error: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;b: %v\n&quot;</span>, <span class="hljs-type">string</span>(b))<br>&#125;<br></code></pre></td></tr></table></figure><p>怎么感觉 <code>unix socket</code> 和 命名管道是一样的。。。</p><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>发送进程调用 <code>kill</code> 向接收进程发送一个信号，接收进程使用 <code>signal</code>  对该信号进行注册监听，当捕获到该信号时，可以进行相应的处理。<br>演示代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// handler 用来处理接收到的信号</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[parent] receive a SIGINT signal, finish the process!\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pid;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// child</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[child] process id: %d, parent id: %d \n&quot;</span>, getpid(), getppid());<br>        sleep(<span class="hljs-number">5</span>);   <span class="hljs-comment">// 睡眠 5 秒</span><br>        <span class="hljs-comment">// 使用 kill 函数向指定的进程发送一个信号</span><br>        <span class="hljs-comment">// 这里向父进程发送一个 SIGINT 信号</span><br>        kill(getppid(), SIGINT);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[child] send a SIGINT signal\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// parent</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[parent] process id: %d \n&quot;</span>, getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[parent] wait signal... \n&quot;</span>);<br>        <span class="hljs-comment">// 注册一个信号处理函数，当捕获到 SIGINT 时，调用 handler 函数进行处理</span><br>        (<span class="hljs-type">void</span>) signal(SIGINT, handler);<br>    &#125;<br>    sleep(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 等待父子进程执行完毕</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 153. 寻找旋转排序数组中的最小值</title>
    <link href="/2021/08/06/leetcode-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/"/>
    <url>/2021/08/06/leetcode-153-xun-zhao-xuan-zhuan-pai-xu-shu-zu-zhong-de-zui-xiao-zhi/</url>
    
    <content type="html"><![CDATA[<blockquote><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><p>示例 1：</p><p>输入：nums &#x3D; [3,4,5,1,2]<br>输出：1<br>解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2]<br>输出：0<br>解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。<br>示例 3：</p><p>输入：nums &#x3D; [11,13,15,17]<br>输出：11<br>解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 5000<br>-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000<br>nums 中的所有整数 互不相同<br>nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转</p></blockquote><h1 id="方法-1-二分法"><a href="#方法-1-二分法" class="headerlink" title="方法 1 二分法"></a>方法 1 二分法</h1><p>和基本二分一样，初始变量 <code>l</code> 置于第一个元素，<code>r</code> 置于最后一个元素，<code>m</code> 取 (l + r) &gt;&gt; 1，通过判断 <code>nums[m]</code> 和 <code>nums[l]</code>、<code>nums[r]</code> 的大小关系，来判断哪部分是有序的。</p><p>比如 [3, 4, 5, 1, 2]，<code>m</code> &#x3D; 5，<code>l</code> &#x3D; 3，<code>r</code> &#x3D; 2，m &gt; l，所以 [l, m] 这部分有序。<br>又比如 [7, 0, 1, 2, 3, 4, 5]，<code>m</code> &#x3D; 2，<code>l</code> &#x3D; 7，<code>r</code> &#x3D; 5，m &lt; r，所以 [m, r] 这部分有序。<br>还有一种特殊情况：[0, 1, 2, 4, 5, 6, 7] 旋转 7 次后，依然是原数组 [0, 1, 2, 4, 5, 6, 7]，这种情况在后面会说。</p><p>首先我们假设当前数组是一个常规的旋转数组，比如 [3, 4, 5, 1, 2]，这种旋转数组有一个特点：整个数组被划分为两个有序子数组，大的子数组在前面，小的在后面。题目要找的是最小值，该值只可能是较小子数组的第一个，所以可以推断出以下策略：</p><ol><li><p>如果 <strong>nums[m] &lt; nums[r]<strong>，则代表 [m, r] 这部分有序，既然有序，那么这部分中最小的便是 m，举个例子：<br>[7, 0, 1, 2, 3, 4, 5, 6]，<code>l</code> &#x3D; 7，<code>m</code> &#x3D; 2，<code>r</code> &#x3D; 6，代表 [m, r] 这部分有序，即 [2, 3, 4, 5, 6] 这部分，其中最小的是 m &#x3D; 2。<br>但是 m 仅仅是这部分中的最小值，未必是整个数组中的最小值，它的前面仍然可能存在更小的值。比如上面的例子中，整个数组中最小的是 <code>0</code>。<br>所以此时的下一步做法是：</strong>将 r 移动到 m</strong>，这里为什么不能移动到 m - 1 呢？因为 m 也可能是最小的数，比如 [3, 4, 0, 1, 2] 这个例子，如果 r 移动到 m - 1，移动到了 4，这样就已经错过正确答案了。</p></li><li><p>如果 **nums[m] &gt; nums[l]**，则代表 [l, m] 这部分有序，它们在数组的左边（常规旋转数组），这意味着它们是数组中较大的那部分，比如：<br>[3, 4, 5, 1, 2]，<code>l</code> &#x3D; 3，<code>r</code> &#x3D; 2，<code>m</code> &#x3D; 5，[l, r] 这部分有序，即 [3, 4, 5] 这部分，它们在数组中是较大的部分，由于最小值只可能是较小子数组的第一个，所以这部分必然没有最小值，将 <strong><code>l</code> 移动到 m + 1 处</strong>（这里和 nums[m] &lt; nums[r] 的策略不同了）。</p></li><li><p>特殊情况：[0, 1, 2, 3, 4, 5, 6, 7]，此时处理也很简单，只要先判断 <strong>nums[m] &lt; nums[r]</strong> 关系即可，这样 <code>r</code> 就会从 7 移动到 3，忽略了右边那些较大元素。</p></li><li><p>解决了 <code>l</code> 和 <code>r</code> 移动的策略，剩下的就是问题就是何时返回何值，通过几个例子分析出结论：<br>[7, 0, 1, 2, 3, 4, 5]，在 n 次循环后，<code>l</code>，<code>r</code>，<code>m</code> 都处于元素 0 处。<br>[6, 7, 0, 1, 2, 3, 4, 5]，在 n 次循环后，<code>l</code>，<code>m</code> 处于元素 0 处，<code>r</code> 在元素 1 处。<br>[5, 6, 7, 0, 1, 2, 3, 4,]，在 n 次循环后，<code>l</code>，<code>r</code>，<code>m</code> 都处于元素 0 处。<br>[0, 1, 2, 3, 4, 5, 6, 7]，在 n 次循环后，<code>l</code>，<code>m</code> 处于元素 0 处，<code>r</code> 此时在下标 [-1]      处。</p><p>观察发现，最终都是 <code>l</code> 指向最小元素，且此时 <code>l</code> 和 <code>r</code> 的关系是 <strong>l &gt;&#x3D; r</strong> ，所以可以得出结论：循环推出条件为 <strong>l &gt;&#x3D; r</strong>，最终结果返回为 <code>nums[l]</code>。</p></li></ol><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> l &lt; r &#123;<br>        m := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt; nums[r] &#123;<br>            r = m<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[m] &gt;= nums[l] &#123;<br>            l = m + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[l]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多级页表为什么节省内存</title>
    <link href="/2021/08/05/duo-ji-ye-biao/"/>
    <url>/2021/08/05/duo-ji-ye-biao/</url>
    
    <content type="html"><![CDATA[<h1 id="首先明确几个概念"><a href="#首先明确几个概念" class="headerlink" title="首先明确几个概念"></a>首先明确几个概念</h1><p><strong>逻辑地址</strong>：是程序编译后，生成的目标模块进行编址时都是从0号单元开始编址，称之为目标模块的相对地址，即为逻辑地址。</p><p><strong>页</strong>：将虚拟内存划分的块，对应的大小就叫页面大小。</p><p><strong>页框</strong>：将物理内存划分的块。</p><p>页和页框二者一一对应，一个页放入一个页框，（理论上）页的大小和页框的大小相等。</p><p><strong>页表</strong>：就是一个页和页框一一对应的关系表。【存放在内存中】 关系表只是起到一个索引的作用，说白了就是能根据关系表能查到某一个页面和哪一个页框所对应。</p><h1 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h1><p><img src="https://youseebiggirl.github.io/post-images/1628171493242.png"></p><p>操作系统中，一页一般为 <code>4 KB</code>，所以在 4 GB （32 位系统）下一共有 4 GB &#x2F; 4 KB &#x3D; 4 GB * 1024 (4096 MB)  * 1024(4194304KB) &#x2F; 4KB &#x3D; <code>1048576</code> 个页，每个页需要一个 PTE 来保存映射信息，所以需要和页同等数量的 1048576 个 PTE，每个 PTE 占 4 byte，一共需要 <code>4 MB</code> 的内存。</p><p>每个进程都有自己的虚拟地址空间，也就是说每个进程都有自己的页表，如果当前有 100 个进程，那么仅仅是页表就占用了 <code>400 MB</code> 的内存，这还是在 32 位下的情况，在 64 位系统中会占用更多。</p><p>此外，一个进程一般而言不会占用这么多的内存（4 GB，整整占满），所以其页表中会有一些页表项并未映射物理内存，但是却依然占用了内存，这显然也是一种浪费。</p><h1 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h1><p><img src="https://youseebiggirl.github.io/post-images/1628172136856.png"><br>图片来源：<a href="https://www.cnblogs.com/xiaolincoding/p/13213699.html">https://www.cnblogs.com/xiaolincoding/p/13213699.html</a></p><p>在一级页表中我们知道，在 <code>32 位</code>和页大小 <code>4KB </code>的环境下，一个进程的页表需要装下 1048576 （1024 * 1024）个页表项，我们可以把这单个页表项拆分为二级页表，第一级页表有 1024 个页表项，每个页表项指向一个二级页表，每个二级页表项包含了 1024 个页表项，算下来也是 1024 * 1024 个页表项。</p><p>那么二级页表是如何解决一级页表存在的内存占用问题的呢？在二级页表中，第一级页表有 <code>1024</code> 个页表项，共占用 <code>4 KB</code> 内存，如果当前页表项有被映射，那么就继续创建其对应的二级页表，同样的，如果当前页表项没有被映射，就不创建二级页表，相应的内存就省下了。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; 0.804MB，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p><p>再来看看 <strong>深入理解计算机系统</strong> 中的 第 9.6.3 节 <strong>多级页表</strong> 中是如何描述的：<br><img src="https://youseebiggirl.github.io/post-images/1657525690938.png"></p><p>在上图中，片 2 到 7 是未被分配的。然而，如果在片 i 中至少有一个页是分配了的，那么一级 PTE i 就指向 一个二级页表的基址。例如，在上图中，片<code>0、 1 和 8</code>的 所有或者部分已被分配，所以它们的一级 PTE 就指向二级页表。</p><p>这种方法从两个方面减少了内存要求。第一 ，<strong>如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在</strong>。这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB 的虚拟地址空间的大部分都会是未分配的。第二，<strong>只有一级页表才需要总是在主存中</strong>；<strong>虚拟内存系统可以在需要时创建、页面调入或调出二级页表</strong>，这就减少了主存的压力；<strong>只有最经常使用的二级页表才需要缓存在主存中</strong> 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 225. 用队列实现栈</title>
    <link href="/2021/08/04/leetcode-225-yong-dui-lie-shi-xian-zhan/"/>
    <url>/2021/08/04/leetcode-225-yong-dui-lie-shi-xian-zhan/</url>
    
    <content type="html"><![CDATA[<blockquote><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False</p><p>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p><p>进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。</p></blockquote><h1 id="方法-1-两个队列"><a href="#方法-1-两个队列" class="headerlink" title="方法 1 两个队列"></a>方法 1 两个队列</h1><p><img src="https://zengh1.github.io/post-images/1628083312198.png"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    q1 *list.List<br>    q2 *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br>    <span class="hljs-keyword">return</span> MyStack&#123;<br>        q1: list.New(),<br>        q2: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Push element x onto stack. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Push(x <span class="hljs-type">int</span>)  &#123;<br>    m.q2.PushBack(x)<br>    <span class="hljs-keyword">for</span> m.q1.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        pop := m.q1.Remove(m.q1.Front()).(<span class="hljs-type">int</span>)<br>        m.q2.PushBack(pop)<br>    &#125;<br><br>    m.q1, m.q2 = m.q2, m.q1<br>&#125;<br><br><br><span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.q1.Remove(m.q1.Front()).(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">/** Get the top element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.q1.Front().Value.(<span class="hljs-type">int</span>)<br>&#125;  <br><br><br><span class="hljs-comment">/** Returns whether the stack is empty. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.q1.Len() == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="方法-2-一个队列"><a href="#方法-2-一个队列" class="headerlink" title="方法 2  一个队列"></a>方法 2  一个队列</h1><p>其实用两个队列有些多余，反而使程序逻辑变复杂了，只要一个队列即可。</p><p><img src="https://zengh1.github.io/post-images/1628084445226.png"></p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    queue *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br>    <span class="hljs-keyword">return</span> MyStack&#123;<br>        queue: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Push element x onto stack. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Push(x <span class="hljs-type">int</span>)  &#123;<br>    queueLen := m.queue.Len()<br>    m.queue.PushBack(x)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; queueLen; i++ &#123;<br>        pop := m.queue.Remove(m.queue.Front()).(<span class="hljs-type">int</span>)<br>        m.queue.PushBack(pop)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    pop := m.queue.Remove(m.queue.Front()).(<span class="hljs-type">int</span>) <br>    <span class="hljs-keyword">return</span> pop<br>&#125;<br><br><br><span class="hljs-comment">/** Get the top element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.queue.Front().Value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">/** Returns whether the stack is empty. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> m.queue.Len() == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 155. 最小栈</title>
    <link href="/2021/08/04/leetcode-155-zui-xiao-zhan/"/>
    <url>/2021/08/04/leetcode-155-zui-xiao-zhan/</url>
    
    <content type="html"><![CDATA[<blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul><p>示例:</p><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><p>提示：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p></blockquote><h1 id="方法-两个栈"><a href="#方法-两个栈" class="headerlink" title="方法 两个栈"></a>方法 两个栈</h1><p><img src="https://zengh1.github.io/post-images/1628052697775.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    s1, s2 *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        s1: list.New(),<br>        s2: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    m.s1.PushBack(val)<br>    <span class="hljs-keyword">if</span> m.s2.Len() == <span class="hljs-number">0</span> &#123;<br>        m.s2.PushBack(val)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m.s2.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; val &lt;= m.s2.Back().Value.(<span class="hljs-type">int</span>) &#123;<br>        m.s2.PushBack(val)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> Pop()  &#123;<br>    <span class="hljs-keyword">if</span> m.s1.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> m.s1.Back().Value.(<span class="hljs-type">int</span>) == m.s2.Back().Value.(<span class="hljs-type">int</span>) &#123;<br>            m.s2.Remove(m.s2.Back())<br>        &#125;<br>        m.s1.Remove(m.s1.Back())<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> m.s1.Back().Value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> m.s2.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> m.s2.Back().Value.(<span class="hljs-type">int</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[牛客][腾讯2020笔试题] 第二题. 逛街</title>
    <link href="/2021/08/03/niu-ke-teng-xun-2020-bi-shi-ti-di-er-ti-guang-jie/"/>
    <url>/2021/08/03/niu-ke-teng-xun-2020-bi-shi-ti-di-er-ti-guang-jie/</url>
    
    <content type="html"><![CDATA[<blockquote><p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。<br>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住） </p><p>输入例子1:<br>[5,3,8,3,2,5]</p><p>输出例子1:<br>[3,3,5,4,4,4]</p><p>例子说明1:<br>当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。</p></blockquote><p>对例子的进一步说明：上面所说的位置序号是从 1 开始的，所以位置 3 的楼高为 8。</p><p>从 8 的左边看，可以看到高度为 5，3 的这两栋楼（5 在左边，3 在右边，所以先看到 3 再看到 5，如果是 [3, 5, 8]，那么就只能看到 5 而看不到 3 了，因为被挡住了）。</p><p>从 8 的右边看，可以看到高度为 3，5 的这两栋楼，注意，在 3，5 之间的 2 是看不到的，因为被 3 挡住了。</p><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p>看评论里的，一开始没想到最小栈的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;container/list&quot;</span><br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param heights int整型一维数组 </span><br><span class="hljs-comment"> * @return int整型一维数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBuilding</span><span class="hljs-params">( heights []<span class="hljs-type">int</span> )</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">var</span> (<br>        res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights))<br>        stack = list.New()    <span class="hljs-comment">// min stack</span><br>        <span class="hljs-comment">//rs := list.New()    // stack</span><br>        l = <span class="hljs-built_in">len</span>(heights)<br>    )<br>    <br>    <span class="hljs-comment">// 每个位置都能看见自己，所以初值都为 1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(res); i++ &#123;<br>        res[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 每栋楼左边能看到的数量</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; l<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.Back().Value.(<span class="hljs-type">int</span>) &lt;= heights[i] &#123;<br>            stack.Remove(stack.Back())<br>        &#125;<br>        stack.PushBack(heights[i])<br>        res[i+<span class="hljs-number">1</span>] += stack.Len()<br>    &#125;<br>    <br>    stack.Init()    <span class="hljs-comment">// clear stack</span><br>    <br>    <span class="hljs-comment">// 每栋楼右边能看到的数量</span><br>    <span class="hljs-keyword">for</span> i := l<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> stack.Len() &gt; <span class="hljs-number">0</span> &amp;&amp; stack.Back().Value.(<span class="hljs-type">int</span>) &lt;= heights[i] &#123;<br>            stack.Remove(stack.Back())<br>        &#125;<br>        stack.PushBack(heights[i])<br>        res[i<span class="hljs-number">-1</span>] += stack.Len()<br>    &#125; <br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h1><p>自己写的，运行超时，5&#x2F;10 组用例通过，仅做保留记录，无参考价值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param heights int整型一维数组 </span><br><span class="hljs-comment"> * @return int整型一维数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findBuilding</span><span class="hljs-params">( heights []<span class="hljs-type">int</span> )</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    <span class="hljs-keyword">var</span> (<br>        <span class="hljs-comment">//isSelf bool</span><br>        res = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights))<br>    )<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(heights); i++ &#123;<br>        <span class="hljs-keyword">var</span> curMaxHeight = <span class="hljs-number">-1</span>    <span class="hljs-comment">// </span><br>        <span class="hljs-comment">// 当前位置一共可以看见几栋楼，因为可以看见自己所在的楼，所以初值为 1</span><br>        <span class="hljs-keyword">var</span> total = <span class="hljs-number">1</span> <br>        <br>        <span class="hljs-comment">// 当前位置的左边可以看见几栋楼</span><br>        <span class="hljs-keyword">for</span> j := i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> heights[j] &lt; curMaxHeight &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            curMaxHeight = max(heights[j], curMaxHeight)<br>            total++<br>        &#125;<br>        <br>        curMaxHeight = <span class="hljs-number">-1</span>    <span class="hljs-comment">// 重置</span><br>        <br>        <span class="hljs-comment">// 当前位置的右边一共可以看见几栋楼</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(heights); j++ &#123;<br>            <span class="hljs-keyword">if</span> heights[j] &lt; curMaxHeight &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            curMaxHeight = max(heights[j], curMaxHeight)<br>            total++<br>        &#125;<br>        <br>        res[i] = total<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>笔试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[牛客][腾讯2020笔试题] 第一题. 压缩算法</title>
    <link href="/2021/08/03/teng-xun-2020-bi-shi-ti-ya-suo-suan-fa/"/>
    <url>/2021/08/03/teng-xun-2020-bi-shi-ti-ya-suo-suan-fa/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说明：该题出自牛客 —— 腾讯2020校园招聘-后台</p></blockquote><blockquote><p>时间限制：C&#x2F;C++ 1秒，其他语言2秒</p><p>空间限制：C&#x2F;C++ 256M，其他语言512M</p><p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字<br>符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且<br>1&lt;&#x3D;m&lt;&#x3D;100)，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符<br>串，你能帮助他进行解压缩么？ </p><p>输入例子1:<br>“HG[3|B[2|CA]]F”</p><p>输出例子1:<br>“HGBCACABCACABCACAF”</p><p>例子说明1:<br>HG[3|B[2|CA]]F −&gt; HG[3|BCACA]F −&gt; HGBCACABCACABCACAF</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这道题和 <code>leetcode 394. 字符串解码</code> 基本相似，只是多了一个 “|” 符号，只要添加 “|” 对应的逻辑即可，观察发现 “|” 是在数字之后出现的，所以遍历到 “|” 时需要将当前数字变量添加到数字栈，同时将当前数字变量置 0。<br>同时也需要更改遇到 “[” 时的逻辑，此时只需要添加当前字符串变量到字符串栈，并清空当前字符串变量。可以参考 lc394 的思路： <code>https://zengh1.github.io/post/leetcode-394-zi-fu-chuan-jie-ma/</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;container/list&quot;</span><br>    <span class="hljs-string">&quot;unicode&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param str string字符串 </span><br><span class="hljs-comment"> * @return string字符串</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compress</span><span class="hljs-params">( str <span class="hljs-type">string</span> )</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// write code here</span><br>    mulstack := list.New()    <span class="hljs-comment">// 保存数字的栈</span><br>    letstack := list.New()    <span class="hljs-comment">// 保存字母的栈</span><br>    <br>    <span class="hljs-keyword">var</span> (<br>        mul <span class="hljs-type">int</span><br>        res strings.Builder<br>    )<br>    <br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> str &#123;<br>        <span class="hljs-keyword">if</span> unicode.IsLetter(c) &#123;<br>            res.WriteRune(c)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> unicode.IsNumber(c) &#123;<br>            mul = mul*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            letstack.PushBack(res.String())<br>            res.Reset()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;|&#x27;</span> &#123;<br>            mulstack.PushBack(mul)<br>            mul = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;]&#x27;</span> &#123;<br>            popmul := mulstack.Remove(mulstack.Back()).(<span class="hljs-type">int</span>)<br>            <span class="hljs-keyword">var</span> temp <span class="hljs-type">string</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; popmul; i++ &#123;<br>                temp += res.String()<br>            &#125;<br>            <br>            popchar := letstack.Remove(letstack.Back()).(<span class="hljs-type">string</span>)<br>            <br>            res.Reset()<br>            res.WriteString(popchar + temp)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res.String()<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>笔试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 持久化之 AOF 与 RDB</title>
    <link href="/2021/08/02/redis-chi-jiu-hua-zhi-aof-yu-rdb/"/>
    <url>/2021/08/02/redis-chi-jiu-hua-zhi-aof-yu-rdb/</url>
    
    <content type="html"><![CDATA[<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p><code>RDB</code> 可以将某个时间点上的数据库状态保存到一个 <code>RDB</code> 文件中（该文件的文件名可以在 redis.conf 中的 <code>dbfilename</code> 进行配置，默认为 <code>dump.rdb</code>），该文件是一个经过压缩的二进制文件，里面保存了数据库中的键值对，通过该文件可以还原生成 <code>RDB</code> 文件的数据库状态。 </p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用 <code>SAVE</code> 或者 <code>BGSAVE</code> 来生成 RDB 文件，二者的区别是 <code>SAVE</code> 会阻塞进程直到 <code>RDB</code> 文件创建完毕为止，阻塞期间不能处理任何请求，而 <code>BGSAVE</code> 会 <code>fork</code> 一个子进程取创建 <code>RDB</code>，不会阻塞主进程。</p><h2 id="RDB-的坑"><a href="#RDB-的坑" class="headerlink" title="RDB 的坑"></a>RDB 的坑</h2><h3 id="1-生成的-dump-rdb-所在位置"><a href="#1-生成的-dump-rdb-所在位置" class="headerlink" title="1. 生成的 dump.rdb 所在位置"></a>1. 生成的 dump.rdb 所在位置</h3><blockquote><p>在 <code>redis.conf</code> 中指明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">The working directory.</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># The DB will be written inside this directory, with the filename specified</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># The Append Only File will also be created inside this directory.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># Note that you must specify a directory here, not a file name.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">dir</span> /usr/local/var/db/redis/</span><br></code></pre></td></tr></table></figure><p>一些博客中说的是在 <code>redis-cli</code> 中使用 <code>config get dir</code> 查看，但是</p></blockquote><h3 id="2-客户端执行-shutdown-或者-直接-ctrl-c-退出服务端，会自动-save"><a href="#2-客户端执行-shutdown-或者-直接-ctrl-c-退出服务端，会自动-save" class="headerlink" title="2. 客户端执行 shutdown 或者 直接 ctrl+c 退出服务端，会自动 save"></a>2. 客户端执行 shutdown 或者 直接 ctrl+c 退出服务端，会自动 save</h3><p>当时我想做一个测试：先 <code>set</code> 几条数据，然后执行 <code>save</code> 对这几条将数据持久化，再执行 <code>flushdb</code> 清空数据库，当再次启动 <code>redis-server</code> 时，会读取 <code>dump.rdb</code> ，将 <code>set</code> 的那几条数据恢复过来。</p><blockquote><p>tips: <code>flushdb</code> 清空数据库后不会执行 save，而 <code>flushall</code> 清空后会执行 save </p></blockquote><p>然而当我实践时却事与愿违，<code>redis-server</code> 的启动日志上显示了读取 <code>rdb</code>，但使用 <code>keys *</code> 却显示 empty，起初以为是自己对 <code>rdb</code> 工作机制不够了解，找了半天资料，最后才发现是因为退出会自动执行 <code>save</code>，当退出时，<code>redis-server</code> 输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">56163:M 02 Aug 2021 16:20:34.361 # User requested shutdown...<br>56163:M 02 Aug 2021 16:20:34.361 * Saving the final RDB snapshot before exiting.<br>56163:M 02 Aug 2021 16:20:34.362 * DB saved on disk<br>56163:M 02 Aug 2021 16:20:34.362 # Redis is now ready to exit, bye bye...<br></code></pre></td></tr></table></figure><p>所以出现上面情况的原因在于，<code>redis-server</code> 退出时自动执行 save，将当前执行过 <code>flushdb</code> 命令的数据库又持久化了一份，并覆盖掉了之前的 RDB 文件。</p><p>解决方法：让 <code>redis-server</code> 非正常退出即可，比如使用 <code>kill -9</code> （ <code>kill</code> 是无效的）。</p><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>与 <code>RDB</code> 持久化通过保存数据库中的键值对来记录数据库状态不同，<code>AOF</code> 持久化是通过保存 <code>Redis</code> 服务器所执行的<strong>写命令</strong>来记录数据库状态的。</p><p><code>AOF</code> 默认关闭，要想开启需要修改 <code>redis.conf</code> 中的 <code>appendonly</code> 为 <code>yes</code>。和 <code>RDB</code> 一样，当 Redis 退出时，会自动进行持久化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">56925:M 02 Aug 2021 17:21:03.892 # User requested shutdown...<br>56925:M 02 Aug 2021 17:21:03.892 * Calling fsync() on the AOF file.<br>56925:M 02 Aug 2021 17:21:03.892 * Saving the final RDB snapshot before exiting.<br>56925:M 02 Aug 2021 17:21:03.892 * DB saved on disk<br>56925:M 02 Aug 2021 17:21:03.892 * Removing the pid file.<br>56925:M 02 Aug 2021 17:21:03.893 # Redis is now ready to exit, bye bye...<br></code></pre></td></tr></table></figure><p><code>AOF</code> 生成的默认文件名为 <code>appendonly.aof</code>，其中保存的是协议化后的写命令，是文本文件，所以可以使用 <code>cat</code> 打印查看，该 <code>db</code> 存储了两个<code>key</code>：a:b 和 b:b，其对应的 AOF 文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">*2<br><span class="hljs-meta prompt_">$</span><span class="language-bash">6</span><br>SELECT<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>0<br>*3<br><span class="hljs-meta prompt_">$</span><span class="language-bash">3</span><br>set<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>a<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>a<br>*3<br><span class="hljs-meta prompt_">$</span><span class="language-bash">3</span><br>set<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>b<br><span class="hljs-meta prompt_">$</span><span class="language-bash">1</span><br>b<br></code></pre></td></tr></table></figure><h2 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h2><p>通过 <code>BGREWRITEAOF </code> 命令进行持久化。</p><h2 id="AOF-持久化的实现"><a href="#AOF-持久化的实现" class="headerlink" title="AOF 持久化的实现"></a>AOF 持久化的实现</h2><p><code>AOF</code> 持久化功能的实现可以分为 <strong>命令追加（append）</strong>、<strong>文件写入</strong>，<strong>文件同步（sync）</strong> 三个步骤。</p><ol><li>命令追加：服务器在执行完一个写命令后，会以协议格式追加到 <code>aof_buf</code> 缓冲区的末尾。</li><li>文件写入：此时不会把数据直接写入到 <code>AOF</code> 文件，而是先将 <code>aof_buf</code> 中的数据保存到一个内存缓冲区。</li><li>文件同步：将内存缓冲区的数据写入到 <code>AOF</code> 文件中。</li></ol><p>这里要注意写入和同步的区别</p><h3 id="写入和同步的区别"><a href="#写入和同步的区别" class="headerlink" title="写入和同步的区别"></a>写入和同步的区别</h3><p>在现代 OS 中，为了提高文件的写入操作，当用户调用到 <code>write</code> 函数将数据写入文件时，<code>os</code> 先将数据写入到一个内存缓冲区里，正常是等到缓冲区满了或是规定时间到了，才真正地将缓冲区里的数据写入磁盘，这时才是持久化完成。</p><p>类似你用记事本写东西一样，写完之后你会 Ctrl+v（保存），但是在没执行 Ctrl+v 的时候你也能看到自己写的，这时因为保存在内存缓冲区里了，然后你保存了，这才保存到磁盘了，所以我们可以把你写东西当做是对 <code>aof</code> 文件的写入，你执行 Ctrl+v 才是同步到磁盘操作。</p><p>这样虽然大大提高了效率，但是很不安全，在你写了好多字时，卡，忽然电脑停机了，写的东西全没了，就问你气不气？</p><p>所以 <code>appendfsync</code> 的选项值中的 <code>always</code>、<code>everysec</code> 都可以强制让 OS 立即将缓冲区里的数据写入硬盘。<code>always</code> 是写到缓冲区了立马就同步到磁盘，<code>everysec</code> 是写到缓冲区的数据每秒就同步一次，丢失了也就丢失了上一秒内的数据，也不是很气。</p><p>写入同步的策略取决于配置文件中的 <code>appendfsync</code> 选项，在 <strong>Redis 设计与实现</strong> 中有详细说明，这里就不介绍了。</p><h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>TODO</p><h3 id="一个问题：子进程在重写过程中，父进程依然可以写入新的-kv，此时会怎么处理？"><a href="#一个问题：子进程在重写过程中，父进程依然可以写入新的-kv，此时会怎么处理？" class="headerlink" title="一个问题：子进程在重写过程中，父进程依然可以写入新的 kv，此时会怎么处理？"></a>一个问题：子进程在重写过程中，父进程依然可以写入新的 kv，此时会怎么处理？</h3><p><strong>重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可靠传输的实现机制 —— 停止-等待协议SW（Stop-and-Wait）</title>
    <link href="/2021/07/30/ke-kao-chuan-shu-de-shi-xian-ji-zhi-ting-zhi-deng-dai-xie-yi-swstop-and-wait/"/>
    <url>/2021/07/30/ke-kao-chuan-shu-de-shi-xian-ji-zhi-ting-zhi-deng-dai-xie-yi-swstop-and-wait/</url>
    
    <content type="html"><![CDATA[<h1 id="何为停等协议"><a href="#何为停等协议" class="headerlink" title="何为停等协议"></a>何为停等协议</h1><p>首先假设有这样一个简单的可靠传输协议，<code>主机 A</code> 发送数据分组给 <code>主机 B</code>，由于网络传输过程中可能会出现数据损坏，所以<code>主机 B</code>会进行校验和检测，如果数据完整则发送 <code>ACK</code>，否则发送 <code>NAK</code>，如果收到 <code>ACK</code>，则可以继续发送下一个数据分组（如果有），收到 <code>NAK</code> 则重新发送当前数据分组。</p><p>在收到 <code>主机 B</code> 的回复之前，<code>主机 A</code> 不会进行任何操作，这便是停等协议，类似于串行操作。</p><p><img src="https://zengh1.github.io/post-images/1627643333323.jpg"></p><h1 id="存在的问题及解决方法"><a href="#存在的问题及解决方法" class="headerlink" title="存在的问题及解决方法"></a>存在的问题及解决方法</h1><h2 id="1-长时间得不到回应"><a href="#1-长时间得不到回应" class="headerlink" title="1. 长时间得不到回应"></a>1. 长时间得不到回应</h2><p><img src="https://zengh1.github.io/post-images/1627643411856.jpg"></p><p>解决方法：<br><img src="https://zengh1.github.io/post-images/1627643674456.jpg"></p><h2 id="2-ACK、NAK-丢失"><a href="#2-ACK、NAK-丢失" class="headerlink" title="2. ACK、NAK 丢失"></a>2. ACK、NAK 丢失</h2><p>既然是网络传输，那么不仅报文会丢失，ACK、NAK 同样也有丢失的可能，如果丢失会产生什么问题呢？看如下场景：<br><img src="https://zengh1.github.io/post-images/1627643890538.jpg"></p><p>在上图中，因为 ACK 的丢失，触发超时重传，又发送了一次数据给对端，但是对端已经接收到了这个数据，属于冗余数据，无需再次接收。那么可以丢弃吗？答案是不可以，因为对端并不知道它的 ACK 是否丢失，所以也无法分辨这次接收到的是冗余重传还是新的报文，冗余重传可以丢弃，但是新报文不能。</p><p>解决方法：给每个分组带上序号，由于停等协议每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，所以一次用一个<code>比特</code>（0 或 1）来编号就够了，01不断循环，这次发送编号为 0，下次发送则编号为 1，再下次为 0，如此往复。</p><p><img src="https://zengh1.github.io/post-images/1627645085797.jpg"></p><p>如上图所示，当接收到重传分组 data0 时，便可根据编号判断出这是一个冗余数据，便可以丢弃了。这里注意数据可以丢弃，但是依然要回复一个 ACK，告诉对方我已经收到了你的数据，下次不用再发了。</p><h2 id="3-另一种情况"><a href="#3-另一种情况" class="headerlink" title="3. 另一种情况"></a>3. 另一种情况</h2><p>仅仅给分组带上序号就可以了吗？看如下情况：<br><img src="https://zengh1.github.io/post-images/1627645491169.jpg"></p><p>DATA0 的 ACK 延迟了，这导致 DATA0 重传，再发起重传后不久，延迟的 ACK 到达了，于是继续发送下一个数据 DATA1，之后又收到了重传 DATA0 返回的 ACK，那么问题来了：接收端如何辨别这次的 ACK 是 DATA0 返回的还是 DATA1 返回的？</p><p>解决方法：给 ACK 也加上序号<br><img src="https://zengh1.github.io/post-images/1627646445947.jpg"></p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p>计算机网络微课堂——湖科大教书匠，<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=25%EF%BC%8C%E5%9B%BE%E7%89%87%E5%8F%8A%E5%86%85%E5%AE%B9%E7%9A%86%E6%9D%A5%E8%87%AA%E4%BA%8E%E6%AD%A4">https://www.bilibili.com/video/BV1c4411d7jb?p=25，图片及内容皆来自于此</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go map源码阅读</title>
    <link href="/2021/07/29/go-map-yuan-ma-yue-du/"/>
    <url>/2021/07/29/go-map-yuan-ma-yue-du/</url>
    
    <content type="html"><![CDATA[<p>看看 map 这个重要数据结构在 go 中是如何实现的</p><span id="more"></span><h1 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h1><p>map 的结构体 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// count 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><br><span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>count <span class="hljs-type">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span><br>flags <span class="hljs-type">uint8</span><br><br><span class="hljs-comment">// B 桶的数目是 2 的 B 次幂，因为选择桶使用的是与运算的方法</span><br>B <span class="hljs-type">uint8</span> <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br><br><span class="hljs-comment">// 使用的溢出桶的数量</span><br>noverflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// approximate number of overflow buckets; see incrnoverflow for details</span><br><br><span class="hljs-comment">// hash0 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，</span><br><span class="hljs-comment">// 并在调用哈希函数时作为参数传入</span><br>hash0 <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash seed</span><br><br><span class="hljs-comment">// buckets 桶的位置，实际类型为 []bmap</span><br>buckets unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span><br><br><span class="hljs-comment">// oldbuckets 用于在扩容阶段保存旧桶的位置</span><br><span class="hljs-comment">// 如果 oldbuckets == nil，则代表以及迁移完成</span><br><span class="hljs-comment">// 判断函数为 growing()</span><br>oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span><br><br><span class="hljs-comment">// 记录渐进式扩容阶段下一个要迁移的旧桶编号</span><br><span class="hljs-comment">// 何为渐进式？</span><br><span class="hljs-comment">// 如果触发扩容，此时不会一次性把 kv 全部从旧桶迁移到新桶，而是当执行插入（包括修改）、删除操作时，</span><br><span class="hljs-comment">// 对一部分 kv 进行迁移，这样就可以把迁移的时间分摊到多次 map 操作中，防止瞬间性能抖动</span><br><span class="hljs-comment">// ps: 每次最多只会搬迁 2 个 bucket，迁移是否完成的判断依据是 oldbuckets 字段是否为空</span><br>nevacuate <span class="hljs-type">uintptr</span> <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span><br><br><span class="hljs-comment">// 指向一个 mapextra，mapextra 里面记录的是溢出桶的相关信息</span><br>extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bmap"><a href="#bmap" class="headerlink" title="bmap"></a>bmap</h1><p><code>bmap</code> 是一个桶，编译期间会动态地创建一个新的结构：</p><blockquote><p> 来自 Go 语言设计与实现：<br> runtime.bmap 中的其他字段在运行时也都是通过计算内存地址的方式访问的，<br> 所以它的定义中就不包含这些字段，不过我们能根据编译期间的 cmd&#x2F;compile&#x2F;internal&#x2F;gc.bmap<br> 函数重建它的结构 </p></blockquote><p> 但是在 go 1.16 中没有找到这个函数，所以在其他博客找了这个结构体，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-type">uintptr</span><br>    overflow <span class="hljs-type">uintptr</span><br>&#125;<br></code></pre></td></tr></table></figure><p>桶中存放 kv 的方式如下：</p><p>计算出的<code>hash 值</code>的高八位为 <code>tophash</code>，用于在一个独立的桶中区别出键，低位用于选择桶，<br>例如下面是一个计算出来的 <code> hash</code>：</p><blockquote><p>高 8 位 <strong>66883387</strong>    391851     <strong>01010</strong>  低 5 位                   </p></blockquote><p>当 <code>B</code> 等于 5 时，那么我们选择的哈希值低位也是 5 位，即 01010，它的十进制值为 10，代表 10 号桶。<br>再用哈希值的高 8 位，找到此 <code>key</code> 在桶中的位置。</p><p>桶里面会最多装 8 个 <code>key/value</code>，这些 <code> key</code> 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果的 低B位是相同的，而多个 key 装入一个桶就是 go 用来处理  <strong>hash 冲突</strong> 的方式。在桶内，会根据 <code>key</code> 的 <code>hash</code> 值的高 8 位作为 <code>tophash</code>，<code>tophash</code> 的作用是在一个独立的桶中区别出键，可以在查找 <code>key</code> 时进行快速判断，快速的原因在于：</p><blockquote><p>在某个 <code>bmap</code> 里快速判等<code> key</code> 时使用，若 hash 高八位不相等就不用进一步比较 <code>key</code> 是否相等了，判断<code> key</code> 是否相等会根据 <code>key</code> 的类型找到对应的<code>equal</code> 函数，然后调用函数拿到判等结果；而判断 <code>tophash</code> 就没那么复杂了。来源：<a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ%EF%BC%8C%E3%80%90Golang%E3%80%91Map%E9%95%BF%E5%95%A5%E6%A0%B7%E5%84%BF%EF%BC%9F%E9%87%8C%E7%9A%84%E8%AF%84%E8%AE%BA">https://www.bilibili.com/video/BV1Sp4y1U7dJ，【Golang】Map长啥样儿？里的评论</a></p></blockquote><p> 计算 tophash 的函数是：func tophash(hash uintptr) uint8</p><p>  bmap 的结构图示：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627563904668.webp"></p><p>在8个键值对数据后面有一个overflow指针，因为桶中最多只能装 8 个键值对，如果有多余的键值对落到了当前桶，那么就需要再构建一个桶（称为溢出桶），通过 overflow 指针链接起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// tophash generally contains the top byte of the hash value</span><br><span class="hljs-comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="hljs-comment">// tophash[0] is a bucket evacuation state instead.</span><br>tophash [bucketCnt]<span class="hljs-type">uint8</span><br><span class="hljs-comment">// Followed by bucketCnt keys and then bucketCnt elems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span><br><span class="hljs-comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="hljs-comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="hljs-comment">// Followed by an overflow pointer.</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 初始化的流程：</span><br><span class="hljs-comment">// 1. 入参校验，判断 key 的类型是否合法，必须为可比较类型</span><br><span class="hljs-comment">// 2. 底层调用 makemap 函数，计算得到合适的 B，map 容量最多可容纳 6.5 * 2^B 个元素，</span><br><span class="hljs-comment">//   6.5 为装载因子阈值常量。</span><br><span class="hljs-comment">// 装载因子的计算公式是：装载因子 = 填入表中的元素个数/散列表的长度，装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降</span><br><br><span class="hljs-comment">// makemap implements Go map creation for make(map[k]v, hint).</span><br><span class="hljs-comment">// If the compiler has determined that the map or the first bucket</span><br><span class="hljs-comment">// can be created on the stack, h and/or bucket may be non-nil.</span><br><span class="hljs-comment">// If h != nil, the map can be created directly in h.</span><br><span class="hljs-comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-type">int</span>, h *hmap)</span></span> *hmap &#123;<br><span class="hljs-comment">//println(&quot;[make map] start...&quot;)</span><br><span class="hljs-comment">// 1. 计算哈希占用的内存是否溢出或者超出能分配的最大值</span><br>mem, overflow := math.MulUintptr(<span class="hljs-type">uintptr</span>(hint), t.bucket.size)<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc &#123;<br>hint = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//println(&quot;[make map] cap: &quot;, hint, &quot;, use mem: &quot;, mem)</span><br><span class="hljs-comment">//log.Printf(&quot;[make map] cap: %d, use mem: %d \n&quot;, hint, mem)</span><br><br><span class="hljs-comment">// initialize Hmap</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>h = <span class="hljs-built_in">new</span>(hmap)<br>&#125;<br><span class="hljs-comment">// 2. 调用 runtime.fastrand 获取一个随机的哈希种子</span><br>h.hash0 = fastrand()<br><br><span class="hljs-comment">// Find the size parameter B which will hold the requested # of elements.</span><br><span class="hljs-comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span><br>B := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 3. 根据传入的 hint 计算出需要的最小需要的桶的数量</span><br><span class="hljs-keyword">for</span> overLoadFactor(hint, B) &#123;<br>B++<br>&#125;<br><span class="hljs-comment">//println(&quot;B is &quot;, B)</span><br><span class="hljs-comment">//log.Printf(&quot;B is %d, that mean the total bocket number is 2^B = %v \n&quot;, B, math2.Pow(2, float64(B)))</span><br>h.B = B<br><br><span class="hljs-comment">// 分配初始哈希表</span><br><span class="hljs-comment">// 如果 B 为 0，那么 buckets 字段后续会在 mapassign（map 的添加函数） 方法中 lazily 分配</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// allocate initial hash table</span><br><span class="hljs-comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span><br><span class="hljs-comment">// If hint is large zeroing this memory could take a while.</span><br><span class="hljs-keyword">if</span> h.B != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> nextOverflow *bmap<br><span class="hljs-comment">// 4. 使用 runtime.makeBucketArray 创建用于保存桶的数组</span><br><span class="hljs-comment">// runtime.makeBucketArray 会根据传入的 B 计算出的需要创建的桶数量</span><br><span class="hljs-comment">// 并在内存中分配一片连续的空间用于存储数据</span><br>h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>h.extra.nextOverflow = nextOverflow<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建保存桶的数组"><a href="#创建保存桶的数组" class="headerlink" title="创建保存桶的数组"></a>创建保存桶的数组</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeBucket 为 map 创建用于保存 buckets 的数组。</span><br><span class="hljs-comment">// 当桶的数量小于 24 时，由于数据较少、使用溢出桶的可能性较低，会省略创建的过程以减少额外开销；</span><br><span class="hljs-comment">// 当桶的数量多于 24 时，会额外创建 2^B − 4 个溢出桶；</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// makeBucketArray initializes a backing array for map buckets.</span><br><span class="hljs-comment">// 1&lt;&lt;b is the minimum number of buckets to allocate.</span><br><span class="hljs-comment">// dirtyalloc should either be nil or a bucket array previously</span><br><span class="hljs-comment">// allocated by makeBucketArray with the same t and b parameters.</span><br><span class="hljs-comment">// If dirtyalloc is nil a new backing array will be alloced and</span><br><span class="hljs-comment">// otherwise dirtyalloc will be cleared and reused as backing array.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBucketArray</span><span class="hljs-params">(t *maptype, b <span class="hljs-type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;<br>base := bucketShift(b)<br>nbuckets := base<br><span class="hljs-comment">// 对于小的 b 值（小于4），即桶的数量小于 16 时，使用溢出桶的可能性很小。</span><br><span class="hljs-comment">// 对于此情况，就避免计算开销。</span><br><span class="hljs-comment">// For small b, overflow buckets are unlikely.</span><br><span class="hljs-comment">// Avoid the overhead of the calculation.</span><br><span class="hljs-keyword">if</span> b &gt;= <span class="hljs-number">4</span> &#123;<br><span class="hljs-comment">// 当桶的数量大于等于 16 个时，正常情况下就会额外创建 2^(b-4) 个溢出桶</span><br><span class="hljs-comment">// Add on the estimated number of overflow buckets</span><br><span class="hljs-comment">// required to insert the median number of elements</span><br><span class="hljs-comment">// used with this value of b.</span><br>nbuckets += bucketShift(b - <span class="hljs-number">4</span>)<br>sz := t.bucket.size * nbuckets<br>up := roundupsize(sz)<br><span class="hljs-keyword">if</span> up != sz &#123;<br>nbuckets = up / t.bucket.size<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 这里，dirtyalloc 分两种情况。如果它为 nil，则会分配一个新的底层数组。</span><br><span class="hljs-comment">// 如果它不为 nil，则它指向的是曾经分配过的底层数组，该底层数组是由之前同</span><br><span class="hljs-comment">// 样的 t 和 b 参数通过 makeBucketArray 分配的，如果数组不为空，需要把</span><br><span class="hljs-comment">// 该数组之前的数据清空并复用。</span><br><span class="hljs-keyword">if</span> dirtyalloc == <span class="hljs-literal">nil</span> &#123;<br>buckets = newarray(t.bucket, <span class="hljs-type">int</span>(nbuckets))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// dirtyalloc was previously generated by</span><br><span class="hljs-comment">// the above newarray(t.bucket, int(nbuckets))</span><br><span class="hljs-comment">// but may not be empty.</span><br>buckets = dirtyalloc<br>size := t.bucket.size * nbuckets<br><span class="hljs-keyword">if</span> t.bucket.ptrdata != <span class="hljs-number">0</span> &#123;<br>memclrHasPointers(buckets, size)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>memclrNoHeapPointers(buckets, size)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 即 b 大于等于 4 的情况下，会预分配一些溢出桶。</span><br><span class="hljs-comment">// 为了把跟踪这些溢出桶的开销降至最低，使用了以下约定：</span><br><span class="hljs-comment">// 如果预分配的溢出桶的 overflow 指针为 nil，那么可以通过指针碰撞（bumping the pointer）获得更多可用桶。</span><br><span class="hljs-comment">//（关于指针碰撞：假设内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为</span><br><span class="hljs-comment">// 分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”）</span><br><span class="hljs-comment">// 对于最后一个溢出桶，需要一个安全的非 nil 指针指向它。</span><br><span class="hljs-keyword">if</span> base != nbuckets &#123;<br><span class="hljs-comment">// We preallocated some overflow buckets.</span><br><span class="hljs-comment">// To keep the overhead of tracking these overflow buckets to a minimum,</span><br><span class="hljs-comment">// we use the convention that if a preallocated overflow bucket&#x27;s overflow</span><br><span class="hljs-comment">// pointer is nil, then there are more available by bumping the pointer.</span><br><span class="hljs-comment">// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span><br>nextOverflow = (*bmap)(add(buckets, base*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>last := (*bmap)(add(buckets, (nbuckets<span class="hljs-number">-1</span>)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>last.setoverflow(t, (*bmap)(buckets))<br>&#125;<br><span class="hljs-keyword">return</span> buckets, nextOverflow<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找有两个函数，<code>mapaccess1</code> 对应 <code>h[key]</code> 这种形式，<code>mapaccess2</code> 对应 <code>v, ok := h[key]</code> ，ok 表示该 key 是否存在。</p><h2 id="mapaccess1"><a href="#mapaccess1" class="headerlink" title="mapaccess1"></a>mapaccess1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 查找 key</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span><br><span class="hljs-comment">// it will return a reference to the zero object for the elem type if</span><br><span class="hljs-comment">// the key is not in the map.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The returned pointer may keep the whole map live, so don&#x27;t</span><br><span class="hljs-comment">// hold onto it for very long.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br><span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapaccess1)<br>racereadpc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>msanread(key, t.key.size)<br>&#125;<br><br><span class="hljs-comment">// 如果 map 为空或者元素个数为 0，返回零值</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br><br><span class="hljs-comment">// 写和读冲突，即并发操作</span><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map read and map write&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 计算哈希值，并且加入 hash0 引入随机性</span><br><span class="hljs-comment">// 不同类型的 key，会使用不同的 hash 算法</span><br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br>m := bucketMask(h.B)<br><br><span class="hljs-comment">// b 就是 bucket 的地址</span><br>b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-comment">// 如果 oldbuckets 不为空，那么证明 map 发生了扩容</span><br><span class="hljs-comment">// 如果有扩容发生，老的 buckets 中的数据可能还未搬迁至新的 buckets 里</span><br><span class="hljs-comment">// 所以需要先在老的 buckets 中找</span><br><span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br><span class="hljs-comment">// There used to be half as many buckets; mask down one more power of two.</span><br>m &gt;&gt;= <span class="hljs-number">1</span><br>&#125;<br>oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-keyword">if</span> !evacuated(oldb) &#123;<br>b = oldb<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 计算出当前 key 的高 8 位的 hash，也就是 tophash</span><br>top := tophash(hash)<br>bucketloop:<br><span class="hljs-comment">// 双重循环遍历：外层循环是从桶到溢出桶遍历；内层是桶中的 cell 遍历</span><br><span class="hljs-comment">// 跳出循环的条件有三种：</span><br><span class="hljs-comment">// 第一种是已经找到 key 值；</span><br><span class="hljs-comment">// 第二种是当前桶再无溢出桶；</span><br><span class="hljs-comment">// 第三种是当前桶中有 cell 位的 tophash 值是 emptyRest</span><br><span class="hljs-comment">// 它代表此时的桶后面的 cell 还未利用，所以无需再继续遍历。</span><br><br><span class="hljs-comment">// 前面已经通过 hash 值的低位确定是几号桶了，但是桶可能还连接着溢出桶，所以使用 for 循序</span><br><span class="hljs-comment">// 来遍历该桶以及其连接的溢出桶</span><br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-comment">// 每个桶内最多存放 8 个 key/value，每个 kv 对应一个 tophash，所以</span><br><span class="hljs-comment">// 遍历这 8 个 tophash 来查找 key</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-comment">// tophash 不匹配</span><br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-comment">// 如果是 emptyRest，代表此时的桶后面的 cell 还未利用，所以无需再继续遍历</span><br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-comment">// 继续查找</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 到这里说明找到了 key，得到 key 的地址</span><br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k = *((*unsafe.Pointer)(k))<br>&#125;<br><span class="hljs-comment">// tophash 相同还需要判断 key 是否相等</span><br><span class="hljs-comment">// 如果 key 也相同则代表找到了，返回</span><br><span class="hljs-comment">// 如果 key 不相同，则进入下轮循环</span><br><span class="hljs-keyword">if</span> t.key.equal(key, k) &#123;<br>e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>e = *((*unsafe.Pointer)(e))<br>&#125;<br><span class="hljs-keyword">return</span> e<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 所有的 bucket 都未找到，则返回零值</span><br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mapaccess2"><a href="#mapaccess2" class="headerlink" title="mapaccess2"></a>mapaccess2</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapaccess2)<br>racereadpc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>msanread(key, t.key.size)<br>&#125;<br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map read and map write&quot;</span>)<br>&#125;<br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br>m := bucketMask(h.B)<br>b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br><span class="hljs-comment">// There used to be half as many buckets; mask down one more power of two.</span><br>m &gt;&gt;= <span class="hljs-number">1</span><br>&#125;<br>oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-keyword">if</span> !evacuated(oldb) &#123;<br>b = oldb<br>&#125;<br>&#125;<br>top := tophash(hash)<br>bucketloop:<br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k = *((*unsafe.Pointer)(k))<br>&#125;<br><span class="hljs-keyword">if</span> t.key.equal(key, k) &#123;<br>e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>e = *((*unsafe.Pointer)(e))<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// map 的添加函数</span><br><span class="hljs-comment">// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br><span class="hljs-comment">//println(&quot;insert key into map...&quot;)</span><br><span class="hljs-comment">// 如果 h 是空指针，赋值会引起 panic</span><br><span class="hljs-comment">// 例如以下语句</span><br><span class="hljs-comment">// var m map[string]int</span><br><span class="hljs-comment">// m[&quot;k&quot;] = 1</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;assignment to entry in nil map&quot;</span>))<br>&#125;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapassign)<br>racewritepc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br>msanread(key, t.key.size)<br>&#125;<br><br><span class="hljs-comment">// 有其他 goroutine 正在往 map 中写 key，会抛出以下错误</span><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 通过 key 和哈希种子，算出对应哈希值</span><br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br><span class="hljs-comment">//println(&quot;this key hash is &quot;, hash)</span><br><br><span class="hljs-comment">// 将 flags 的值与 hashWriting 做按位或运算</span><br><span class="hljs-comment">// 因为在当前 goroutine 可能还未完成 key 的写入，再次调用 t.hasher 会发生 panic。</span><br><span class="hljs-comment">// Set hashWriting after calling t.hasher, since t.hasher may panic,</span><br><span class="hljs-comment">// in which case we have not actually done a write.</span><br>h.flags ^= hashWriting<br><br><span class="hljs-keyword">if</span> h.buckets == <span class="hljs-literal">nil</span> &#123;<br>h.buckets = newobject(t.bucket) <span class="hljs-comment">// newarray(t.bucket, 1)</span><br>&#125;<br><br>again:<br><span class="hljs-comment">// bucketMask 返回值是 2 的 B 次方减 1</span><br><span class="hljs-comment">// 因此，通过 hash 值与 bucketMask 返回值做按位与操作，</span><br><span class="hljs-comment">// 返回的在 buckets 数组中的第几号桶</span><br>bucket := hash &amp; bucketMask(h.B)<br><span class="hljs-comment">//println(&quot;this key will store in bucket &quot;, bucket)</span><br><span class="hljs-comment">// 如果 map 正在搬迁（即 h.oldbuckets != nil）中,则同时进行搬迁工作</span><br><span class="hljs-comment">// 这里涉及到了渐进式扩容这一概念，即扩容不是一次性迁移所有键，而是在其他</span><br><span class="hljs-comment">// 操作中进行小部分迁移</span><br><span class="hljs-keyword">if</span> h.growing() &#123;<br><span class="hljs-comment">//println(&quot;the map is growing!&quot;)</span><br>growWork(t, h, bucket)<br>&#125;<br><span class="hljs-comment">// 计算出上面求出的第几号 bucket 的内存位置</span><br>b := (*bmap)(add(h.buckets, bucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br><span class="hljs-comment">// 计算出 tophash</span><br>top := tophash(hash)<br><span class="hljs-comment">//println(&quot;this key&#x27;s tophash is: &quot;, top)</span><br><br><span class="hljs-comment">// 是否当前 key 是否已经添加成功了，如果为 nil 则表示未成功</span><br><span class="hljs-keyword">var</span> inserti *<span class="hljs-type">uint8</span><br><span class="hljs-keyword">var</span> insertk unsafe.Pointer <span class="hljs-comment">// key 的地址</span><br><span class="hljs-keyword">var</span> elem unsafe.Pointer    <span class="hljs-comment">// value 的地址</span><br>bucketloop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 遍历桶中的 8 个 cell，找到一个空位插入</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-comment">//println(&quot;cur bucket tophash is &quot;, b.tophash[i])</span><br><span class="hljs-comment">// 如果当前 cell 的 tophash 不等于当前 key 的 tophash</span><br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-comment">//println(&quot;b.tophash[i] != top&quot;)</span><br><span class="hljs-comment">// 如果 cell 位为空，那么就可以在对应位置进行插入</span><br><span class="hljs-keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="hljs-literal">nil</span> &#123;<br>inserti = &amp;b.tophash[i] <span class="hljs-comment">// 更新 inserti，表示已经添加成功</span><br>insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br>elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br>&#125;<br><span class="hljs-comment">// emptyRest 表示当前 cell 及之后都为空，此时已经找到空位了，</span><br><span class="hljs-comment">// 所以没必要再遍历了</span><br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> bucketloop<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 第二种情况是 cell 位的 tophash 值和当前的 tophash 值相等</span><br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k = *((*unsafe.Pointer)(k))<br>&#125;<br><span class="hljs-comment">// 即使当前 cell 位的 tophash 值相等，不一定它对应的 key 也是相等的，</span><br><span class="hljs-comment">// 所以还要做一个 key 值判断，key 值不同则 continue 继续寻找空位</span><br><span class="hljs-keyword">if</span> !t.key.equal(key, k) &#123;<br><span class="hljs-comment">//println(&quot;tophash equal but key not equal&quot;)</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 如果已经有该 key 了，就更新它</span><br><span class="hljs-comment">// already have a mapping for key. Update it.</span><br><span class="hljs-keyword">if</span> t.needkeyupdate() &#123;<br><span class="hljs-comment">//println(&quot;tophash equal and key equal, update the value&quot;)</span><br>typedmemmove(t.key, k, key)<br>&#125;<br><span class="hljs-comment">// 这里获取到了要插入 key 对应的 value 的内存地址</span><br>elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-comment">// 如果顺利到这，就直接跳到 done 的结束逻辑中去</span><br><span class="hljs-keyword">goto</span> done<br>&#125;<br><span class="hljs-comment">//println(&quot;range this bucket over, not find empty cell to insert key, continue range overflow buckets&quot;)</span><br><span class="hljs-comment">// 如果桶中的 8 个 cell 遍历完，还未找到对应的空 cell 或覆盖 cell，</span><br><span class="hljs-comment">// 那么就进入它的溢出桶中去遍历</span><br>ovf := b.overflow(t)<br><span class="hljs-comment">// 如果连溢出桶中都没有找到合适的 cell，跳出循环</span><br><span class="hljs-keyword">if</span> ovf == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//println(&quot;overflow buckets not find empty cell, need grow&quot;)</span><br><span class="hljs-keyword">break</span><br>&#125;<br>b = ovf<br>&#125;<br><br><span class="hljs-comment">// 在已有的桶和溢出桶中都未找到合适的 cell 供 key 写入，那么有可能会触发以下两种情况</span><br><span class="hljs-comment">// 情况一：</span><br><span class="hljs-comment">// 判断当前 map 的装载因子是否达到设定的 6.5 阈值，或者当前 map 的溢出桶数量是否过多。</span><br><span class="hljs-comment">// 如果存在这两种情况之一，则进行扩容操作。</span><br><span class="hljs-comment">// hashGrow() 实际并未完成扩容，对哈希表数据的搬迁（复制）操作是通过 growWork() 来完成的。</span><br><span class="hljs-comment">// 重新跳入 again 逻辑，在进行完 growWork() 操作后，再次遍历新的桶。</span><br><br><span class="hljs-comment">// Did not find mapping for key. Allocate new cell &amp; add entry.</span><br><br><span class="hljs-comment">// If we hit the max load factor or we have too many overflow buckets,</span><br><span class="hljs-comment">// and we&#x27;re not already in the middle of growing, start growing.</span><br><span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>hashGrow(t, h)<br><span class="hljs-keyword">goto</span> again <span class="hljs-comment">// Growing the table invalidates everything, so try again</span><br>&#125;<br><br><span class="hljs-comment">// 情况二：</span><br><span class="hljs-comment">// 在不满足情况一的条件下，会为当前桶再新建溢出桶，并将 tophash，</span><br><span class="hljs-comment">// key 插入到新建溢出桶的对应内存的 0 号位置</span><br><span class="hljs-keyword">if</span> inserti == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// The current bucket and all the overflow buckets connected to it are full, allocate a new one.</span><br>newb := h.newoverflow(t, b)<br>inserti = &amp;newb.tophash[<span class="hljs-number">0</span>]<br>insertk = add(unsafe.Pointer(newb), dataOffset)<br>elem = add(insertk, bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize))<br>&#125;<br><br><span class="hljs-comment">// 在插入位置存入新的 key 和 value</span><br><span class="hljs-comment">// store new key/elem at insert position</span><br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>kmem := newobject(t.key)<br>*(*unsafe.Pointer)(insertk) = kmem<br>insertk = kmem<br>&#125;<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>vmem := newobject(t.elem)<br>*(*unsafe.Pointer)(elem) = vmem<br>&#125;<br>typedmemmove(t.key, insertk, key)<br>*inserti = top<br><span class="hljs-comment">// map 中的 key 数量 + 1</span><br>h.count++<br><br>done:<br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br>h.flags &amp;^= hashWriting<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>elem = *((*unsafe.Pointer)(elem))<br>&#125;<br><span class="hljs-keyword">return</span> elem<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapdelete</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>callerpc := getcallerpc()<br>pc := funcPC(mapdelete)<br>racewritepc(unsafe.Pointer(h), callerpc, pc)<br>raceReadObjectPC(t.key, key, callerpc, pc)<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>msanread(key, t.key.size)<br>&#125;<br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> t.hashMightPanic() &#123;<br>t.hasher(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br><br>hash := t.hasher(key, <span class="hljs-type">uintptr</span>(h.hash0))<br><br><span class="hljs-comment">// Set hashWriting after calling t.hasher, since t.hasher may panic,</span><br><span class="hljs-comment">// in which case we have not actually done a write (delete).</span><br>h.flags ^= hashWriting<br><br>bucket := hash &amp; bucketMask(h.B)<br><span class="hljs-keyword">if</span> h.growing() &#123;<br>growWork(t, h, bucket)<br>&#125;<br>b := (*bmap)(add(h.buckets, bucket*<span class="hljs-type">uintptr</span>(t.bucketsize)))<br>bOrig := b<br>top := tophash(hash)<br>search:<br><span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br><span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br><span class="hljs-keyword">break</span> search<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-type">uintptr</span>(t.keysize))<br>k2 := k<br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>k2 = *((*unsafe.Pointer)(k2))<br>&#125;<br><span class="hljs-keyword">if</span> !t.key.equal(key, k2) &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Only clear key if there are pointers in it.</span><br><span class="hljs-keyword">if</span> t.indirectkey() &#123;<br>*(*unsafe.Pointer)(k) = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.key.ptrdata != <span class="hljs-number">0</span> &#123;<br>memclrHasPointers(k, t.key.size)<br>&#125;<br>e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-type">uintptr</span>(t.keysize)+i*<span class="hljs-type">uintptr</span>(t.elemsize))<br><span class="hljs-keyword">if</span> t.indirectelem() &#123;<br>*(*unsafe.Pointer)(e) = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.elem.ptrdata != <span class="hljs-number">0</span> &#123;<br>memclrHasPointers(e, t.elem.size)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>memclrNoHeapPointers(e, t.elem.size)<br>&#125;<br>b.tophash[i] = emptyOne<br><span class="hljs-comment">// If the bucket now ends in a bunch of emptyOne states,</span><br><span class="hljs-comment">// change those to emptyRest states.</span><br><span class="hljs-comment">// It would be nice to make this a separate function, but</span><br><span class="hljs-comment">// for loops are not currently inlineable.</span><br><span class="hljs-keyword">if</span> i == bucketCnt<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">if</span> b.overflow(t) != <span class="hljs-literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="hljs-number">0</span>] != emptyRest &#123;<br><span class="hljs-keyword">goto</span> notLast<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> b.tophash[i+<span class="hljs-number">1</span>] != emptyRest &#123;<br><span class="hljs-keyword">goto</span> notLast<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>b.tophash[i] = emptyRest<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> b == bOrig &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// beginning of initial bucket, we&#x27;re done.</span><br>&#125;<br><span class="hljs-comment">// Find previous bucket, continue at its last entry.</span><br>c := b<br><span class="hljs-keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;<br>&#125;<br>i = bucketCnt - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i--<br>&#125;<br><span class="hljs-keyword">if</span> b.tophash[i] != emptyOne &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>notLast:<br>h.count--<br><span class="hljs-comment">// Reset the hash seed to make it more difficult for attackers to</span><br><span class="hljs-comment">// repeatedly trigger hash collisions. See issue 25237.</span><br><span class="hljs-keyword">if</span> h.count == <span class="hljs-number">0</span> &#123;<br>h.hash0 = fastrand()<br>&#125;<br><span class="hljs-keyword">break</span> search<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;concurrent map writes&quot;</span>)<br>&#125;<br>h.flags &amp;^= hashWriting<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p> 扩容策略分以下两种情况：</p><ol><li><p>判断已经达到装载因子的临界点，即元素个数 &gt;&#x3D; 桶（bucket）总数 * 6.5，这时候说明大部分的桶可能都快满了（即平均每个桶存储的键值对达到6.5个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上，判断<br>函数为 <code>overLoadFactor</code></p></li><li><p>判断溢出桶是否太多，当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，<br>则认为溢出桶过多。当桶总数 &gt;&#x3D; 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出<br>桶总数 &gt;&#x3D; 2 ^ 15 时，即认为溢出桶太多了，判断函数：<code>tooManyOverflowBuckets</code></p><p>在某些场景下，比如不断的增删，这样会造成 overflow 的 bucket 数量增多，但负载因子<br>又不高，未达不到第 1 点的临界值，就不能触发扩容来缓解这种情况。这样会造成桶的使用率不高，<br>值存储得比较稀疏，查找插入效率会变得非常低，因此有了第 2 点判断指标。这就像是一座空城，房<br>子很多，但是住户很少，都分散了，找起人来很困难</p><p>两种情况官方采用了不同的解决方案</p><p> 针对 1，将 B + 1（桶数量为 2 ^ B，B+1 则代表翻倍），新建一个 buckets 数组，<br> 新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。该方法我们称之为增量扩容。</p><p>针对 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对<br>重新排列一次，把在 overflow bucket 中的 key 移动到 bucket 中来以使 bucket 的使用率<br> 更高，进而保证更快的存取。该方法我们称之为等量扩容。</p></li></ol><h2 id="判断扩容条件函数"><a href="#判断扩容条件函数" class="headerlink" title="判断扩容条件函数"></a>判断扩容条件函数</h2><h3 id="tooManyOverflowBuckets"><a href="#tooManyOverflowBuckets" class="headerlink" title="tooManyOverflowBuckets"></a>tooManyOverflowBuckets</h3><p>判断溢出桶是否太多，当桶总数 &lt; 2 ^ 15 时，如果溢出桶总数 &gt;&#x3D; 桶总数，则认为溢出桶过多。当桶总数 &gt;&#x3D; 2 ^ 15 时，直接与 2 ^ 15 比较，当溢出桶总数 &gt;&#x3D; 2 ^ 15 时，即认为溢出桶太多了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span><br><span class="hljs-comment">// Note that most of these overflow buckets must be in sparse use;</span><br><span class="hljs-comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tooManyOverflowBuckets</span><span class="hljs-params">(noverflow <span class="hljs-type">uint16</span>, B <span class="hljs-type">uint8</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// If the threshold is too low, we do extraneous work.</span><br><span class="hljs-comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span><br><span class="hljs-comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span><br><span class="hljs-comment">// See incrnoverflow for more details.</span><br><span class="hljs-keyword">if</span> B &gt; <span class="hljs-number">15</span> &#123;<br>B = <span class="hljs-number">15</span><br>&#125;<br><span class="hljs-comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span><br><span class="hljs-keyword">return</span> noverflow &gt;= <span class="hljs-type">uint16</span>(<span class="hljs-number">1</span>)&lt;&lt;(B&amp;<span class="hljs-number">15</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="overLoadFactor"><a href="#overLoadFactor" class="headerlink" title="overLoadFactor"></a>overLoadFactor</h3><p>判断已经达到装载因子的临界点，即元素个数 &gt;&#x3D; 桶（bucket）总数 * 6.5，这时候说明大部分的桶可能都快满了<br>（即平均每个桶存储的键值对达到 6.5 个），如果插入新元素，有大概率需要挂在溢出桶（overflow bucket）上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">overLoadFactor</span><span class="hljs-params">(count <span class="hljs-type">int</span>, B <span class="hljs-type">uint8</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="hljs-type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩容函数"><a href="#扩容函数" class="headerlink" title="扩容函数"></a>扩容函数</h2><h3 id="hashGrow"><a href="#hashGrow" class="headerlink" title="hashGrow"></a>hashGrow</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets</span><br><span class="hljs-comment">// 挂到了 hmap.oldbuckets 字段上。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hashGrow</span><span class="hljs-params">(t *maptype, h *hmap)</span></span> &#123;<br><span class="hljs-comment">// If we&#x27;ve hit the load factor, get bigger.</span><br><span class="hljs-comment">// Otherwise, there are too many overflow buckets,</span><br><span class="hljs-comment">// so keep the same number of buckets and &quot;grow&quot; laterally.</span><br>bigger := <span class="hljs-type">uint8</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 如果没有达到负载因子临界点，则设置为等量扩容</span><br><span class="hljs-keyword">if</span> !overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) &#123;<br>bigger = <span class="hljs-number">0</span> <span class="hljs-comment">// bigger 设置为 0</span><br>h.flags |= sameSizeGrow<br>&#125;<br><span class="hljs-comment">// 记录老 buckets 的位置</span><br>oldbuckets := h.buckets<br><span class="hljs-comment">// 分配一个新的数组用来存放新桶</span><br>newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="hljs-literal">nil</span>)<br><br>flags := h.flags &amp;^ (iterator | oldIterator)<br><span class="hljs-keyword">if</span> h.flags&amp;iterator != <span class="hljs-number">0</span> &#123;<br>flags |= oldIterator<br>&#125;<br><span class="hljs-comment">// commit the grow (atomic wrt gc)</span><br>h.B += bigger<br>h.flags = flags<br>h.oldbuckets = oldbuckets<br>h.buckets = newbuckets<br>h.nevacuate = <span class="hljs-number">0</span><br>h.noverflow = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &amp;&amp; h.extra.overflow != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Promote current overflow buckets to the old generation.</span><br><span class="hljs-keyword">if</span> h.extra.oldoverflow != <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;oldoverflow is not nil&quot;</span>)<br>&#125;<br>h.extra.oldoverflow = h.extra.overflow<br>h.extra.overflow = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> h.extra == <span class="hljs-literal">nil</span> &#123;<br>h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>&#125;<br>h.extra.nextOverflow = nextOverflow<br>&#125;<br><br><span class="hljs-comment">// the actual copying of the hash table data is done incrementally</span><br><span class="hljs-comment">// by growWork() and evacuate().</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="growWork"><a href="#growWork" class="headerlink" title="growWork"></a>growWork</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在</span><br><span class="hljs-comment">// mapassign() 和 mapdelete() 函数中。也就是插入（包括修改）、删除 key 的时候，都</span><br><span class="hljs-comment">// 会尝试进行搬迁 buckets 的工作。它们会先检查 oldbuckets 是否搬迁完毕（检查 oldbuckets</span><br><span class="hljs-comment">// 是否为 nil），再决定是否进行搬迁工作。</span><br><span class="hljs-comment">// growWork 会搬迁 0~2 个桶</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growWork</span><span class="hljs-params">(t *maptype, h *hmap, bucket <span class="hljs-type">uintptr</span>)</span></span> &#123;<br><span class="hljs-comment">// make sure we evacuate the oldbucket corresponding</span><br><span class="hljs-comment">// to the bucket we&#x27;re about to use</span><br>evacuate(t, h, bucket&amp;h.oldbucketmask())<br><br><span class="hljs-comment">// evacuate one more oldbucket to make progress on growing</span><br><span class="hljs-keyword">if</span> h.growing() &#123; <span class="hljs-comment">// 再多搬迁一个桶</span><br>evacuate(t, h, h.nevacuate)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li>如果两个 key 落入同一个桶，且恰巧它们的 <code>tophash</code> 也相同，此时的<code>添加</code>和<code>查找</code>流程会怎样？</li></ol><blockquote><p>对于 <code>查找</code> 而言，如果 <code>tophash</code> 相同还会进一步判断 <code>key</code> 是否相同，如果 <code>key</code> 相同则返回，不同则继续查找。</p><p><code>添加</code> 也是类似的，如果 <code>tophash</code> 和 <code>key</code> 都相同，说明该 <code>key</code> 已经存在，会执行更新操作，否则继续寻找空位，也就是说，在一个桶中可能出现相同相同的 <code>tophash</code>。</p></blockquote><ol start="2"><li>go map 的负载因子是多少？</li></ol><blockquote><p>负载因子是 <code>6.5</code>，在源码中表现为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Maximum average load of a bucket that triggers growth is 6.5.</span><br><span class="hljs-comment">// Represent as loadFactorNum/loadFactorDen, to allow integer math.</span><br>loadFactorNum = <span class="hljs-number">13</span><br>loadFactorDen = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Go是如何设计Map的 — 机器铃砍菜刀，<a href="https://mp.weixin.qq.com/s/q3qyc5uf3IMVt4KQD12IKQ">https://mp.weixin.qq.com/s/q3qyc5uf3IMVt4KQD12IKQ</a></p><p>【Golang】Map长啥样儿？— 幼麟实验室，<a href="https://www.bilibili.com/video/BV1Sp4y1U7dJ">https://www.bilibili.com/video/BV1Sp4y1U7dJ</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 25. K 个一组翻转链表</title>
    <link href="/2021/07/29/leetcode-25-k-ge-yi-zu-fan-zhuan-lian-biao/"/>
    <url>/2021/07/29/leetcode-25-k-ge-yi-zu-fan-zhuan-lian-biao/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：</p><p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]</p><p>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]</p><p>示例 3：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1<br>输出：[1,2,3,4,5]</p><p>示例 4：</p><p>输入：head &#x3D; [1], k &#x3D; 1<br>输出：[1]</p><p>提示：</p><p>列表中节点的数量在范围 sz 内<br>1 &lt;&#x3D; sz &lt;&#x3D; 5000<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>1 &lt;&#x3D; k &lt;&#x3D; sz</p></blockquote><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>这里借用 leetcode 题解的 <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/">流程图</a>，比较直观，只要照着图上的流程，基本就可以编写出代码了。</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627527292593.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    s := &amp;ListNode&#123;Next: head&#125;<br><br>    <span class="hljs-keyword">var</span> (<br>        pre   = s           <span class="hljs-comment">// start 的前继节点</span><br>        next  = pre       <span class="hljs-comment">// end 的后继节点</span><br>        start *ListNode <span class="hljs-comment">// 要翻转的第一个节点</span><br>        end   = pre       <span class="hljs-comment">// 要翻转的最后一个节点</span><br>    )<br><br>    <span class="hljs-keyword">for</span> pre != <span class="hljs-literal">nil</span> &#123;<br>        start = pre.Next<br>        <span class="hljs-comment">// end 移动到要翻转的最后一个节点</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>            end = end.Next<br>            <span class="hljs-keyword">if</span> end == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s.Next<br>&#125;<br>        &#125;<br>        next = end.Next<br>        end.Next = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 断链</span><br><br>        rh, rt := reverse(start) <span class="hljs-comment">// 反转 start - end</span><br>         <br>        <span class="hljs-comment">// 重新连接链表</span><br>        pre.Next = rh<br>        rt.Next = next<br><br>        pre = rt<br>        end = rt<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> s.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span></span> (rhead, rtail *ListNode) &#123;<br>    <span class="hljs-keyword">var</span> (<br>        cur = head<br>        prev, next *ListNode<br>    )<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next = cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev, head<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程题]二叉树的下一个结点</title>
    <link href="/2021/07/28/bian-cheng-ti-er-cha-shu-de-xia-yi-ge-jie-dian/"/>
    <url>/2021/07/28/bian-cheng-ti-er-cha-shu-de-xia-yi-ge-jie-dian/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。</p><p>注意，树中的结点不仅包含左右子结点，而且包含指向父结点的指针。</p><p>示例:<br>输入:{8,6,10,5,7,9,11},8<br>返回:9<br>解析:这个组装传入的子树根节点，其实就是整颗树，中序遍历{5,6,7,8,9,10,11}，根节点8的下一个节点就是9，应该返回{9,10,11}，后台只打印子树的下一个节点，所以只会打印9，如下图，其实都有指向左右孩子的指针，还有指向父节点的指针，下图没有画出来<br><img src="https://zengh1.github.io/post-images/1627470369081.png"></p><p>特别说明：leetcode 上没有这道题，测评请前往牛客，评测地址：<a href="https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e">https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e</a></p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>有如下情况：</p><ol><li><p>该节点有右子树，那么下一个节点是右子树的最左节点，比如上图中的 <code>8</code>，其右子树为 <code>10</code>，<code>10</code> 的最左节点为 <code>9</code>，所以 <code>8</code> 的下一个节点是 <code>9</code>。</p></li><li><p>该节点无右子树，那么又有以下两种情况：</p><ol><li><p>该节点为其父节点的左子节点，比如 <code>9</code> 就是其父节点 <code>10</code> 的左子节点，此时下一个节点就是父节点。</p></li><li><p>该节点为其父节点的右子节点，比如 <code>7</code> 就是其父节点 <code>6</code> 的右子节点，此时下一个节点是：左子节点是其父节点<br>的节点，说起来比较绕，就是左子节点为 <code>6</code>  的节点，在图中是 <code>8</code>。</p><p>再举一个例子：如果给定的节点为 <code>11</code> ，其父节点为 <code>10</code>，但是没有任何一个节点的左子节点为 <code>10</code>，此时只能继续向上找，看 <code>10</code> 的父节点 <code>8</code> 的情况，同样的，没有任何一个节点的左子节点为 <code>8</code>，继续向上，但此时 <code>8</code> 已经没有父节点了，所以返回 nil</p></li></ol></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">type TreeLinkNode struct &#123;</span><br><span class="hljs-comment">    Val int</span><br><span class="hljs-comment">    Left *TreeLinkNode</span><br><span class="hljs-comment">    Right *TreeLinkNode</span><br><span class="hljs-comment">    Next *TreeLinkNode</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(pNode *TreeLinkNode)</span></span> *TreeLinkNode &#123;<br>    <span class="hljs-comment">// 右子树不为空</span><br>    <span class="hljs-keyword">if</span> pNode.Right != <span class="hljs-literal">nil</span> &#123;<br>        p := pNode.Right<br>      <span class="hljs-comment">// 右子树中最左边的节点</span><br>        <span class="hljs-keyword">for</span> p.Left != <span class="hljs-literal">nil</span> &#123;<br>            p = p.Left<br>        &#125;<br>        <span class="hljs-keyword">return</span> p<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 右子树为空</span><br>      <span class="hljs-comment">// 如果 pNode 是其父节点的左子节点（注意父节点的非空判断）</span><br>        <span class="hljs-keyword">if</span> pNode.Next != <span class="hljs-literal">nil</span> &amp;&amp; pNode.Next.Left == pNode &#123;<br>            <span class="hljs-comment">// 则下一个节点是父节点</span><br>            <span class="hljs-keyword">return</span> pNode.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// pNode 是父节点的右子节点</span><br>            p := pNode.Next<span class="hljs-comment">// pNode 的父节点</span><br>     <br>            <span class="hljs-comment">// 不断向上查找，直到找到一个节点的左子节点为 p 或者 p == nil</span><br>            <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.Next != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 如果 p（父节点）的父节点的左子节点不是 p</span><br>                <span class="hljs-comment">// 则继续向上查找</span><br>                <span class="hljs-keyword">if</span> p.Next.Left != p &#123;<br>                    p = p.Next<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> p.Next<br>                &#125;   <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 面经汇总</title>
    <link href="/2021/07/25/mysql-mian-jing/"/>
    <url>/2021/07/25/mysql-mian-jing/</url>
    
    <content type="html"><![CDATA[<h1 id="1-char-和-varchar-的区别"><a href="#1-char-和-varchar-的区别" class="headerlink" title="1. char 和 varchar 的区别"></a>1. char 和 varchar 的区别</h1><p>char 是固定长度，varchar 长度可变，存储时，前者不管实际存储数据的长度，直接规定 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。</p><p>以char(32)和varchar(32)举例：（这里的 32 表示字符数）</p><table><thead><tr><th align="left"></th><th>char(32)</th><th>varchar(32)</th></tr></thead><tbody><tr><td align="left">占用空间</td><td>固定32字符（如果数据长度不够32将用空格补齐）</td><td>跟随实际存储内容长度，但不超过32</td></tr><tr><td align="left">空格处理</td><td>检索时会去掉尾部空格（数据本身有空白符也会被去掉）</td><td>不会对空格处理</td></tr><tr><td align="left">是否记录字段长度</td><td>否</td><td>是。额外拿出空间记录字段数据长度（字符数）</td></tr><tr><td align="left">适用场景</td><td>存储的数据长度基本一致，不需要空格，eg 手机号、UUID、密码加密后的密文</td><td>数据长度不一定，长度范围变化较大的场景</td></tr></tbody></table><p><em>小问题：char(1) 和 varchar(1) 的区别？两个都只能保存单个字符，但是 varchar 要多占一个或两个存储位置用来记录存储长度信息</em></p><h1 id="2-建立一个联合索引，问-select-a，b，c-和-select-a，c，b-有什么区别"><a href="#2-建立一个联合索引，问-select-a，b，c-和-select-a，c，b-有什么区别" class="headerlink" title="2. 建立一个联合索引，问 select a，b，c 和 select a，c，b 有什么区别"></a>2. 建立一个联合索引，问 select a，b，c 和 select a，c，b 有什么区别</h1><p>MySQL 的 最左前缀匹配原则</p><h1 id="3-varchar-类型，插入的数据超过设置的长度会怎样"><a href="#3-varchar-类型，插入的数据超过设置的长度会怎样" class="headerlink" title="3. varchar 类型，插入的数据超过设置的长度会怎样"></a>3. varchar 类型，插入的数据超过设置的长度会怎样</h1><p>来源： <a href="https://www.hegongshan.com/2020/04/22/mysql-varchar/">https://www.hegongshan.com/2020/04/22/mysql-varchar/</a></p><p>网上基本都说字符串会被自动截断，并报出一个 warning，但是，我在本机上测试时（MySQL 8.0.16），却报了如下错误：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>1406 (22001): Data too long for column &#x27;name&#x27; at row 1<br></code></pre></td></tr></table></figure><p>这是怎么回事呢？后来，我发现，这两种情况是由于SQL模式不同造成的。</p><p>在MySQL中，有如下三种最重要的SQL模式（官网称之为<code>The Most Important SQL Modes</code>）</p><ol><li><p>ANSI </p><blockquote><p>宽松模式</p><p>此模式更改语法和行为，使其更接近标准SQL</p></blockquote></li><li><p>STRICT_TRANS_TABLES</p><blockquote><p>严格模式</p><p>在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制</p></blockquote></li><li><p>TRADITIONAL</p><blockquote><p>在向列中插入错误值时，此模式“给出错误而不是警告”。</p><p>TRADITIONAL 是一个组合模式，它包含了 STRICT_TRANS_TABLES</p></blockquote></li></ol><p>使用 <code>select @@sql_mode</code> 查看当前的 sql_mode。</p><p><code>set @@sql_mode = &#39;traditional&#39;</code> 更改当前 sql_mode。</p><p><strong>总结</strong></p><p>当 varchar 超过限制长度时，</p><p>1.如果当前的 SQL 模式为宽松模式，那么将会按照从前往后的顺序，对字符串进行截断，并提示一个警告；</p><p>2.如果当前的 SQL 模式为严格模式，那么将会报出一个错误。</p><h1 id="MYSQL-事务的-ACID"><a href="#MYSQL-事务的-ACID" class="headerlink" title="MYSQL 事务的 ACID"></a>MYSQL 事务的 ACID</h1><ul><li>A：原子性，保证事务要不全部执行成功，要不全部失败</li><li>C：一致性：保证事务从一个正确的状态转换到另一个正确的状态</li><li>I：隔离性：事务和事务之间是隔离的，并且有不同的隔离级别</li><li>D：持久性，事务最终会保存到硬盘上，对数据库的更改是永久性的</li></ul><h1 id="MySQL-原子性怎么保证"><a href="#MySQL-原子性怎么保证" class="headerlink" title="MySQL 原子性怎么保证"></a>MySQL 原子性怎么保证</h1><p>通过 undo log（回滚日志），</p><h1 id="redolog-工作原理"><a href="#redolog-工作原理" class="headerlink" title="redolog 工作原理"></a>redolog 工作原理</h1><h1 id="宕机后如何保证数据不丢失？"><a href="#宕机后如何保证数据不丢失？" class="headerlink" title="宕机后如何保证数据不丢失？"></a>宕机后如何保证数据不丢失？</h1><h1 id="undolog-在宕机时怎么保证原子性"><a href="#undolog-在宕机时怎么保证原子性" class="headerlink" title="undolog 在宕机时怎么保证原子性"></a>undolog 在宕机时怎么保证原子性</h1><h1 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h1><p>不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了</p><p>幻读（Phantom Read）和不可重复读（Non-repeatable Read）都是并发环境下可能出现的数据读取问题，但它们的原因和表现方式有所不同。</p><ol><li>幻读（Phantom Read）： 幻读指的是在事务中多次执行相同的查询，但在两次查询之间有其他事务插入了新的数据，导致第二次查询返回的结果集中出现了新插入的数据，就好像产生了”幻影”一样。幻读通常与范围查询（Range Query）有关，例如使用了 WHERE 子句的查询。</li></ol><p>幻读的产生原因是由于并发事务之间的插入操作，可能导致事务在同样的查询条件下获取的结果集不一致，从而出现了额外的行数据。</p><ol><li>不可重复读（Non-repeatable Read）： 不可重复读指的是在事务中多次执行相同的查询，但在两次查询之间有其他事务对同一行数据进行了修改或删除，导致第二次查询返回的结果与第一次查询不一致。</li></ol><p>不可重复读的产生原因是由于并发事务之间的更新或删除操作，导致事务在多次读取同一行数据时，数据内容发生了变化，从而出现了不一致的情况。</p><p>区别：</p><ul><li>幻读与范围查询有关，主要涉及到新增数据，而不可重复读主要涉及到已有数据的更新或删除。</li><li>幻读是指查询同样的条件下结果集的行数发生了变化，而不可重复读是指查询同样的条件下结果集的行数据内容发生了变化。</li></ul><p>解决方法：</p><ul><li>幻读通常通过使用锁或多版本并发控制（MVCC）来解决。</li><li>不可重复读通常通过使用锁或使用行级别的读取锁（Read Lock）来解决。</li></ul><p>需要注意的是，幻读和不可重复读是数据库事务隔离级别中的现象。在不同的事务隔离级别下，这些问题的出现与解决方式也可能有所不同。</p><h1 id="介绍下乐观锁悲观锁，以及各自的使用场景"><a href="#介绍下乐观锁悲观锁，以及各自的使用场景" class="headerlink" title="介绍下乐观锁悲观锁，以及各自的使用场景"></a>介绍下乐观锁悲观锁，以及各自的使用场景</h1><p>乐观锁和悲观锁是并发控制中常见的两种策略，用于解决多个线程或进程并发访问共享资源时可能发生的数据一致性问题。</p><ol><li>悲观锁（Pessimistic Locking）： 悲观锁是一种保守的并发控制策略，它假设并发访问的操作会发生冲突，因此在访问共享资源之前，会先对资源进行加锁，确保其他线程无法同时修改该资源。悲观锁的典型应用是使用数据库的行级锁（如行锁、表锁）来保证数据的一致性。悲观锁的特点是阻塞其他线程的访问，可能导致线程等待和性能下降。</li></ol><p>适用场景：</p><ul><li>需要修改共享资源的概率较高。</li><li>并发访问频率较高。</li><li>并发冲突的概率较大。</li><li>数据库事务隔离级别为串行化（Serializable）。</li></ul><ol><li>乐观锁（Optimistic Locking）： 乐观锁是一种乐观的并发控制策略，它假设并发访问的操作不会发生冲突，因此在访问共享资源时，不会立即对资源加锁，而是在更新操作时检查资源是否被其他线程修改过。乐观锁通过使用版本号、时间戳等机制来判断资源是否被修改。如果检测到冲突，则需要进行回滚或重试操作。乐观锁的特点是不阻塞其他线程的访问，但可能存在冲突处理的开销。</li></ol><p>适用场景：</p><ul><li>读取操作远远大于写入操作。</li><li>并发访问冲突较少。</li><li>数据库事务隔离级别为读已提交（Read Committed）或更低。</li></ul><p>选择乐观锁还是悲观锁取决于具体的应用场景和需求。在高并发环境下，悲观锁可能导致性能下降和线程阻塞，而乐观锁可以提供更好的并发性能。但是，乐观锁需要额外的冲突检测和处理机制，适用于冲突较少的场景。在实际应用中，可以根据具体情况选择合适的并发控制策略。</p><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><ol><li>为频繁查询的字段建立索引</li></ol><h1 id="说一下-Mysql-二阶段提交"><a href="#说一下-Mysql-二阶段提交" class="headerlink" title="说一下 Mysql 二阶段提交"></a>说一下 Mysql 二阶段提交</h1><h1 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h1><p>在 MySQL 中，索引可能会失效的几种常见情况包括：</p><ol><li>不使用索引列或对索引列进行函数操作：当查询条件中对索引列进行函数操作、类型转换或计算时，索引可能无法被利用，导致失效。例如：<code>WHERE UPPER(name) = &#39;JOHN&#39;</code>。</li><li>使用 <code>OR</code> 进行条件判断：当查询条件中包含 <code>OR</code> 运算符时，如果其中一个条件无法使用索引，整个查询可能无法使用索引优化。例如：<code>WHERE name = &#39;John&#39; OR age = 25</code>。</li><li>使用 <code>NOT</code> 进行条件判断：<code>NOT</code> 运算符通常会导致索引失效，因为它会使索引无法直接匹配，需要全表扫描。例如：<code>WHERE NOT name = &#39;John&#39;</code>。</li><li>模糊匹配开头的查询：当查询条件使用通配符在索引列开头进行模糊匹配时，索引可能无法被利用。例如：<code>WHERE name LIKE &#39;John%&#39;</code>。</li><li>索引列参与运算：当查询条件中的索引列参与运算（如加减乘除）时，索引可能会失效。例如：<code>WHERE age + 5 = 30</code>。</li><li>隐式类型转换：当查询条件中使用的数据类型与索引列的数据类型不匹配时，MySQL 可能会进行隐式类型转换，导致索引失效。例如：索引列为整数类型，但查询条件中使用字符串进行比较。</li><li>数据量过小的情况：如果表中的数据量非常小，MySQL 可能认为全表扫描比使用索引更高效，因此选择不使用索引。</li><li>索引列的选择性不高：如果索引列的选择性非常低，即索引列的值重复率很高，MySQL 可能不会选择使用索引进行查询，而是进行全表扫描。</li></ol><p>需要注意的是，以上情况并不是绝对的，MySQL 的查询优化器会根据具体的情况和统计信息来选择合适的执行计划，有时即使符合上述情况，MySQL 仍然可能使用索引。因此，在实际使用中，需要结合具体情况进行分析和测试，确保索引的正确使用和性能优化。</p><h1 id="B-树和-B-树的区别？为什么-MySQL-用-B-树实现索引？3-层-B-树有多少个节点？"><a href="#B-树和-B-树的区别？为什么-MySQL-用-B-树实现索引？3-层-B-树有多少个节点？" class="headerlink" title="B 树和 B+ 树的区别？为什么 MySQL 用 B+ 树实现索引？3 层 B+ 树有多少个节点？"></a>B 树和 B+ 树的区别？为什么 MySQL 用 B+ 树实现索引？3 层 B+ 树有多少个节点？</h1><h1 id="执行一条-SQL-的流程"><a href="#执行一条-SQL-的流程" class="headerlink" title="执行一条 SQL 的流程"></a>执行一条 SQL 的流程</h1><p><img src="https://camo.githubusercontent.com/d318aaf4eefb0297e8d605f69c76d95094effe92bcb7bd98fb07e203b1930e95/68747470733a2f2f7374617469633030312e6765656b62616e672e6f72672f7265736f757263652f696d6167652f30642f64392f30643230373065386638346334383031616462666130336264613166393864392e706e67" alt="img"></p><ol><li><strong>连接器</strong></li></ol><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><ol start="2"><li><strong>查询缓存</strong></li></ol><p>​mysql 收到 sql 后，解析第一个字段，获取语句类型，如果是 <strong>查询语句</strong>，那么就会去缓存中查找，缓存以键值对形式保存，其中键是 sql 语句，值是对应的查询结果，如果查询的语句没有命中缓存，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>​ps：这个功能因为作用不大，在 8.0 版本被删除，因为如果表里的数据经常发生变动，缓存的命中率就会变得很低，只要一个表有更新操作，那么这个表的查询缓存就会被清空。</p><ol start="3"><li><strong>分析器</strong></li></ol><p>负责 <strong>词法分析</strong> 和 <strong>语法分析</strong></p><ul><li>词法分析</li></ul><p>​MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方面后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><ul><li>语法分析</li></ul><p>​根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><ol start="4"><li><strong>预处理器</strong></li></ol><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 select * 中的 * 符号，扩展为表上的所有列；</li></ul><ol start="5"><li><strong>优化器</strong></li></ol><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><ol start="6"><li><strong>执行器</strong></li></ol><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</p><h1 id="MySQL-死锁，什么情况下会触发死锁"><a href="#MySQL-死锁，什么情况下会触发死锁" class="headerlink" title="MySQL 死锁，什么情况下会触发死锁"></a>MySQL 死锁，什么情况下会触发死锁</h1>]]></content>
    
    
    
    <tags>
      
      <tag>面经</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll 的 LT 和 ET</title>
    <link href="/2021/07/23/epoll-de-lt-he-et/"/>
    <url>/2021/07/23/epoll-de-lt-he-et/</url>
    
    <content type="html"><![CDATA[<p>Linux epoll 的 <strong>条件触发</strong>( Level Trigger )和 <strong>边缘触发</strong> ( Edge Trigger ) 实践</p><h1 id="LT-效果演示"><a href="#LT-效果演示" class="headerlink" title="LT 效果演示"></a>LT 效果演示</h1><p>一个简单的小 demo，从标准输入 stdin 读入数据，并输出到标准输出 stdout，这里设置了每次读取的 BUF_SIZE 为 2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> epfd, nfds;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[5];</span><br>    epfd = epoll_create(<span class="hljs-number">1</span>);<br>    event.data.fd = STDIN_FILENO;<br>    event.events = EPOLLIN <span class="hljs-comment">/*| EPOLLET*/</span>;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//printf(&quot;%d events already\n&quot;, nfds);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trigger once!\n&quot;</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>                read(events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read content: %s\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序，输入一个长度为 6 的字符串，因为设置了每次读 2 字节，所以一次并不能读完：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627049775702.jpg"></p><p>运行结果如下：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627049789070.jpg"></p><p>可以看到，在 LT 模式下，只要缓冲区中还有数据，该事件就依然会触发（这里最后一次触发不是很明白，输出的内容也是空，可能读取的是换行符？）</p><h1 id="ET-效果演示"><a href="#ET-效果演示" class="headerlink" title="ET 效果演示"></a>ET 效果演示</h1><p>ET 的代码和 LT 基本一样，只需要在 events 处小小改动，加一个 EPOLLET 条件： <code>event.events = EPOLLIN | EPOLLET</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> epfd, nfds;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[5];</span><br>    epfd = epoll_create(<span class="hljs-number">1</span>);<br>    event.data.fd = STDIN_FILENO;<br>    event.events = EPOLLIN | EPOLLET;   <span class="hljs-comment">// set et</span><br>    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//printf(&quot;%d events already\n&quot;, nfds);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trigger once!\n&quot;</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>                read(events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read content: %s\n&quot;</span>, buf);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的输入，运行结果如下：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627049988168.jpg"></p><p>在 ET 模式下，整个事件只会触发一次，即便缓冲区中还有残余数据未被处理，要想再次触发，只有在终端中再次输入：<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1627050340406.jpg"></p><p>这里输入了 adaasdad ，使得事件得以再次触发。</p><p>这个 demo 说明了，如果使用 ET 模式，就一定要在一次事件中，一次性把 socket 上的数据收取干净才行，否则可能造成数据的遗漏。</p><h1 id="ET-的问题"><a href="#ET-的问题" class="headerlink" title="ET 的问题"></a>ET 的问题</h1><p>为了解决上面的问题，需要在一个死循环中不断调用 read，直到读完为止。修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> epfd, nfds;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[5];</span><br>    epfd = epoll_create(<span class="hljs-number">1</span>);<br>    event.data.fd = STDIN_FILENO;<br>    event.events = EPOLLIN | EPOLLET;   <span class="hljs-comment">// set et</span><br>    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &amp;event);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        nfds = epoll_wait(epfd, events, <span class="hljs-number">5</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//printf(&quot;%d events already\n&quot;, nfds);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == STDIN_FILENO) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;trigger once!\n&quot;</span>);<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>                <span class="hljs-comment">// 不断读取直到全部读完</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> n = read(events[i].data.fd, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read EOF\n&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read content: %s\n&quot;</span>, buf);<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ET-需要和-NONBLOCK-搭配使用"><a href="#ET-需要和-NONBLOCK-搭配使用" class="headerlink" title="ET 需要和 NONBLOCK 搭配使用"></a>ET 需要和 NONBLOCK 搭配使用</h1><p>上面的 demo 只是一个简单的演示，实际中 epoll 更多的应用在网络编程中，这将涉及到多个连接的并发问题，比如有如下一个使用 epoll ET 实现的 echo server：</p><blockquote><p>PS: 这段代码使用了我自己随便瞎写的一个库，也就是引用的  pkg&#x2F;net&#x2F;net.h，将 socket 的一些操作简单封装了下</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../pkg/net/net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 4  <span class="hljs-comment">// 将调用 read 函数时使用的缓冲大小缩减为 4 个字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 50</span><br><br><span class="hljs-comment">// g++ -o echo_et echo_et.cc ../pkg/net/net.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Server <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">Listen</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *events;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br><br>    events = (epoll_event*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event) * EPOLL_SIZE);<br>    event.data.fd = s.<span class="hljs-built_in">Sockfd</span>();<br>    event.events = EPOLLIN | EPOLLET;   <span class="hljs-comment">// ET</span><br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, s.<span class="hljs-built_in">Sockfd</span>(), &amp;event);<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-type">int</span> okcnt = <span class="hljs-built_in">epoll_wait</span>(epfd, events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;epoll wait error&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 插入验证 epoll_wait 函数调用次数的语句</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;trigger once!&quot;</span> &lt;&lt; endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; okcnt; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>                event.events = EPOLLIN | EPOLLET;<br>                event.data.fd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, conn-&gt;<span class="hljs-built_in">Connfd</span>(), &amp;event);<br>                cout &lt;&lt; <span class="hljs-string">&quot;connected client: &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">Connfd</span>() &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="hljs-literal">nullptr</span>);<br>                        <span class="hljs-built_in">close</span>(events[i].data.fd);<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, events[i].data.fd);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;  <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">write</span>(events[i].data.fd, buf, n);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序是不具备并发能力的，原因在于这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-built_in">close</span>(events[i].data.fd);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, events[i].data.fd);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;  <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">write</span>(events[i].data.fd, buf, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 ET 的特性，需要一次性将数据全部读完，所以需要在一个死循环中不断调用 read 来读取数据。</p><p>但是 socket 建立的连接默认是阻塞模式的，这将导致 read 函数在最后一次被阻塞，比如要读取数据 1234，每次读 2 个，第一次循环读取 12，第二次循环读取 34，读取完后进入第三次循环，但是因为此时已经无数据可读了，所以会阻塞在 read 处，除非对端主动关闭返回 0，否则将永远阻塞。而整个程序又是单线程的，这将导致其他连接无法被处理。</p><p>解决方法是将 socket 设置为非阻塞（NONBLOCK），当无数据可读时，会立马返回 EAGAIN 错误（ps：EAGAIN 和 EWOULDBLOCK 是一样的）而不是阻塞。只需要将 accpet 返回的 conn 设置为非阻塞即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (events[i].data.fd == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>        <span class="hljs-comment">// set conn nonblock</span><br>        util::<span class="hljs-built_in">SetNonBlock</span>(conn-&gt;<span class="hljs-built_in">Connfd</span>());<br>        event.events = EPOLLIN | EPOLLET;<br>        event.data.fd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, conn-&gt;<span class="hljs-built_in">Connfd</span>(), &amp;event);<br>        cout &lt;&lt; <span class="hljs-string">&quot;connected client: &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">Connfd</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">util::SetNonBlock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old_opt = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_opt = old_opt | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_opt);<br>    <span class="hljs-keyword">return</span> old_opt;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="为什么-LT-不需要设置非阻塞"><a href="#为什么-LT-不需要设置非阻塞" class="headerlink" title="为什么 LT 不需要设置非阻塞"></a>为什么 LT 不需要设置非阻塞</h1><p>LT 下的 echo 服务：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by root on 7/18/21.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../pkg/net/net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 4  <span class="hljs-comment">// 将调用 read 函数时使用的缓冲大小缩减为 4 个字节</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 50</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Server <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">Listen</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *events;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> event;<br><br>    events = (epoll_event*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event) * EPOLL_SIZE);<br>    event.data.fd = s.<span class="hljs-built_in">Sockfd</span>();<br>    event.events = EPOLLIN;<br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, s.<span class="hljs-built_in">Sockfd</span>(), &amp;event);<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-type">int</span> okcnt = <span class="hljs-built_in">epoll_wait</span>(epfd, events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;epoll wait error&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 插入验证 epoll_wait 函数调用次数的语句</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;trigger once!&quot;</span> &lt;&lt; endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; okcnt; i++) &#123;<br>            <span class="hljs-keyword">if</span> (events[i].data.fd == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>                event.events = EPOLLIN;<br>                event.data.fd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, conn-&gt;<span class="hljs-built_in">Connfd</span>(), &amp;event);<br>                cout &lt;&lt; <span class="hljs-string">&quot;connected client: &quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">Connfd</span>() &lt;&lt; endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(events[i].data.fd, buf, BUF_SIZE);<br>                <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, events[i].data.fd, <span class="hljs-literal">nullptr</span>);<br>                    <span class="hljs-built_in">close</span>(events[i].data.fd);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;closed client: %d\n&quot;</span>, events[i].data.fd);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">write</span>(events[i].data.fd, buf, n);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LT 模式下，只要缓冲区还有数据就会触发事件，所以不需要一次全部读取，每次触发事件只会 read 一次（触发事件即表示 read 可读），而不是像 ET 一样在死循环里一直 read，自然也就不会发生阻塞问题了。比如读取 1234，第一次读取 12 退出循环，因为还有数据，继续触发事件，读取剩余的 34。</p>]]></content>
    
    
    
    <tags>
      
      <tag>epoll</tag>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go container/heap 源码阅读</title>
    <link href="/2021/07/22/go-containerheap-yuan-ma-yue-du/"/>
    <url>/2021/07/22/go-containerheap-yuan-ma-yue-du/</url>
    
    <content type="html"><![CDATA[<p>heap（堆），是一个用数组表示的完全二叉树，常用于构建优先队列，排序和快速找出一个集合中的最小值（或者最大值）。在 go 标准库下的 container 包中提供了这种数据结构。</p><span id="more"></span><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>要想使用堆，需要实现 <code>Interface</code> 接口，这个接口中内嵌了一个 <code>sort.Interface</code> 接口，所以一共需要包含 5 个方法：Len() 用于返回长度，Swap() 用于交换两个值，Less() 用于定义比较两个值的规则，Push() 和 Pop() 分别代表添加到末尾和弹出末尾元素。通过 Less() 可以自定义堆为最大堆还是最小堆。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>sort.Interface<br>Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-comment">// 添加 x 到末尾</span><br>Pop() <span class="hljs-keyword">interface</span>&#123;&#125;   <span class="hljs-comment">// 弹出末尾元素并返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一开始我不是很明白为什么要实现 Push 和 Pop 两个方法，因为这两个方法的定义已经很明确了，后来看了 heap 包下的 example_pq_test.go 才明白了原因，主要在于一些操作还需要做一些额外的工作，比如优先级队列的实现，其实现的 Pop() 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>old := *pq<br>n := <span class="hljs-built_in">len</span>(old)<br>item := old[n<span class="hljs-number">-1</span>]<br>old[n<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span>  <span class="hljs-comment">// avoid memory leak</span><br>    <span class="hljs-comment">// 将 index 置为 -1 是为了标识该数据已经出了优先级队列了</span><br>item.index = <span class="hljs-number">-1</span> <br>*pq = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> item<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Push</span><span class="hljs-params">(h Interface, x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>h.Push(x)<br><span class="hljs-comment">// 从下到上堆化</span><br>up(h, h.Len()<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Push 会先执行自己实现的 h.Push 方法，将 x 添加到末尾，之后再执行 up 进行堆化。</p><h2 id="up"><a href="#up" class="headerlink" title="up"></a>up</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// up 代表上浮，从下到上堆化</span><br><span class="hljs-comment">// j 代表需要堆化的元素 index，up 会从该元素开始，不断向上调整堆</span><br><span class="hljs-comment">// 在 Push 中会调用 up</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">up</span><span class="hljs-params">(h Interface, j <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// j 的父节点</span><br>i := (j - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> <span class="hljs-comment">// parent</span><br><br><span class="hljs-comment">// i == j ：此时 i 是最后一个元素</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在解释 !h.Less(j, i) 之前，先来看看 Less(i, j int) 接口的定义：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// func (m myheap) Less(i, j int) bool &#123;</span><br><span class="hljs-comment">//return m[i] &lt; m[j]// 这代表实现的堆为最小堆</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// func (m myheap) Less(i, j int) bool &#123;</span><br><span class="hljs-comment">//return m[i] &gt; m[j]// 这代表实现的堆为最大堆</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 1. 最小堆，如果 j（子节点）大于 i（父节点），情况如下图：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//3i</span><br><span class="hljs-comment">//  \</span><br><span class="hljs-comment">//   5  j</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 此时便不需要交换 i 和 j，!h.Less(j, i) 对应 !m[j] &lt; m[i]，即 m[j] &gt; m[i]</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 最大堆同理</span><br><span class="hljs-keyword">if</span> i == j || !h.Less(j, i) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// 否则需要进行交换，还是以最小堆为例：</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//5i</span><br><span class="hljs-comment">//  \</span><br><span class="hljs-comment">//   3  j</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 此时不满足 !h.Less(j, i)，此时 i（父节点）大于 j（子节点），</span><br><span class="hljs-comment">// 不满足最小堆的定义，所以需要进行交换</span><br>h.Swap(i, j)<br><br><span class="hljs-comment">// up 代表上浮，所以更新 j 为其父节点 i</span><br>j = i<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Push-的流程图示"><a href="#Push-的流程图示" class="headerlink" title="Push 的流程图示"></a>Push 的流程图示</h2><p>执行以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myheap []<span class="hljs-type">int</span>   <span class="hljs-comment">// myheap 是一个最小堆</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHeapPushPop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>h := <span class="hljs-built_in">new</span>(myheap)<br>heap.Push(h, <span class="hljs-number">5</span>)<br>heap.Push(h, <span class="hljs-number">10</span>)<br>heap.Push(h, <span class="hljs-number">2</span>)<br>heap.Push(h, <span class="hljs-number">99</span>)<br>heap.Push(h, <span class="hljs-number">3</span>)<br>heap.Push(h, <span class="hljs-number">233</span>)<br>heap.Push(h, <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://autsu.github.io/post-images/1626964254407.png"></p><h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pop</span><span class="hljs-params">(h Interface)</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>n := h.Len() - <span class="hljs-number">1</span><br><span class="hljs-comment">// 堆顶是最小（或最大）元素，将其交换到末尾，pop 会移除该元素</span><br>h.Swap(<span class="hljs-number">0</span>, n)<br><span class="hljs-comment">// FIXME down 的作用不确定，以下为猜测</span><br><span class="hljs-comment">// down 会将第二小（或大）的元素移动到堆顶，便于下次操作</span><br>down(h, <span class="hljs-number">0</span>, n)<br><span class="hljs-keyword">return</span> h.Pop()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="down"><a href="#down" class="headerlink" title="down"></a>down</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">down</span><span class="hljs-params">(h Interface, i0, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>i := i0<br><span class="hljs-keyword">for</span> &#123;<br>j1 := <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>          <span class="hljs-comment">// j1 是 i 的左子节点</span><br><span class="hljs-comment">// j1 &gt; n 代表子节点不存在</span><br><span class="hljs-comment">// j1 == n 代表子节点是堆中最后一个节点，down 操作会忽略最后一个元素</span><br><span class="hljs-keyword">if</span> j1 &gt;= n || j1 &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// j1 &lt; 0 after int overflow</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// j 用来保存子节点中较小（大）的那个，默认为左子节点</span><br>j := j1 <span class="hljs-comment">// left child</span><br><br><span class="hljs-comment">// j2 := j1 + 1，这表示 j2 是 i 的右子节点</span><br><span class="hljs-comment">// 这里是 j2 &lt; n 而不是 j2 &lt;= n，因为 down 操作会忽略最后一个元素</span><br><span class="hljs-comment">// 如果是最小堆，则选出 j1（左子节点）和 j2（右子节点）中较小的那个</span><br><span class="hljs-comment">// 如果是最大堆，则选出 j1（左子节点）和 j2（右子节点）中较大的那个</span><br><span class="hljs-keyword">if</span> j2 := j1 + <span class="hljs-number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;<br><span class="hljs-comment">// 满足条件，则更新 j 为右子节点</span><br>j = j2 <span class="hljs-comment">// = 2*i + 2  // right child</span><br>&#125;<br><br><span class="hljs-comment">// 判断 j（子节点） 和 i（父节点）的关系</span><br><span class="hljs-comment">// 如果是最小堆，!h.Less(j, i) 代表 j &gt; i，即父节点小于较小的子节点，</span><br><span class="hljs-comment">// 此时已经满足最小堆的特性了，直接 break</span><br><span class="hljs-comment">// 如果是最大堆，!h.Less(j, i) 代表 j &lt; i，与上面同理</span><br><span class="hljs-keyword">if</span> !h.Less(j, i) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 到这里说明 j（子节点） 和 i（父节点）不满足堆的特性，</span><br><span class="hljs-comment">// 如果是最小堆，说明此时 i &gt; j，需要交换</span><br><span class="hljs-comment">// 如果是最大堆，说明此时 i &lt; j，需要交换</span><br>h.Swap(i, j)<br><br><span class="hljs-comment">// down 代表下沉，更新 i 为其子节点 j，进行下一轮循环</span><br>i = j<br>&#125;<br><br><span class="hljs-comment">// 如果没有执行过 i = j，则不满足 i &gt; i0 条件，</span><br><span class="hljs-comment">// 这代表没有进行 down 操作</span><br><span class="hljs-keyword">return</span> i &gt; i0<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Pop-的流程如下图："><a href="#Pop-的流程如下图：" class="headerlink" title="Pop 的流程如下图："></a>Pop 的流程如下图：</h2><p><img src="https://github.com/autsu/diagrams/blob/master/img/%E5%A0%86%E7%9A%84pop%E6%93%8D%E4%BD%9C.png?raw=true"> </p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面只对 <code>heap</code> 包中的核心函数进行了分析，剩余还有 <code>Init</code>，<code>Remove</code>，<code>Fix()</code> 函数，但是其内部也是调用了 <code>up</code> 和 <code>down</code> 这两个函数，所以就不一一分析了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
      <tag>数据结构</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 40. 最小的 k 个数</title>
    <link href="/2021/07/21/jian-zhi-offer-40-zui-xiao-de-k-ge-shu/"/>
    <url>/2021/07/21/jian-zhi-offer-40-zui-xiao-de-k-ge-shu/</url>
    
    <content type="html"><![CDATA[<p>输入整数数组 arr ，找出其中最小的 k 个数</p><span id="more"></span><blockquote><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8 这 8 个数字，则最小的 4 个数字是 1、2、3、4。</p><p>示例 1：</p><p>输入：arr &#x3D; [3,2,1], k &#x3D; 2<br>输出：[1,2] 或者 [2,1]</p><p>示例 2：</p><p>输入：arr &#x3D; [0,1,2,1], k &#x3D; 1<br>输出：[0]</p></blockquote><h1 id="方法1-排序"><a href="#方法1-排序" class="headerlink" title="方法1 排序"></a>方法1 排序</h1><p>使用任意一种排序算法进行排序，排序后取前 k 个即可，这里使用快排：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    quickSort(arr)<br>    <span class="hljs-keyword">return</span> arr[:k]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> &#123;<br>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>q := arr[<span class="hljs-number">0</span>]<br>l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> l &lt; r &#123;<br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[r] &gt; q &#123;<br>r--<br>&#125;<br>arr[l] = arr[r]<br><br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[l] &lt;= q &#123;<br>l++<br>&#125;<br>arr[r] = arr[l]<br>&#125;<br><br>arr[l] = q<br><br>quickSort(arr[:r])<br>quickSort(arr[r+<span class="hljs-number">1</span>:])<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法2-优化快排"><a href="#方法2-优化快排" class="headerlink" title="方法2 优化快排"></a>方法2 优化快排</h1><p>题目只是要求找出 top k，但是方法 1 却对整个数组进行了排序，显然是不必要的。这里可以利用快排的性质做一些优化，快排的核心是，每轮都会选出一个基准点，以该点为分隔线，将比它小的都放在左边，比它大的放在右边，可以利用这个特性对 topk 进行优化。</p><p>当挑选出基准点 p 时，将其与 k 进行比对，有以下几种情况：</p><ol><li><p>p &lt; k</p><p>比如：-1, 1, <strong>2</strong>, 5, 3, 5, 9，k &#x3D; 5，第一轮求得 p &#x3D; [2] &#x3D; 2</p><p>此时 2 作为基准点，其左边元素都比它小，右边元素都比它大，题目要求的是求前 5 个最小元素，现在已经确定了 -1，1，2 三个元素，还差 5 - 3 &#x3D; 2 个，且这两个元素一定在 2 的右边，所以可以再对右边部分 [5, 3, 5, 9] 进行快排，同时 k 需要更改为 k - p - 1 &#x3D; 5 - 2 - 1 &#x3D; 2。</p><p>上面的结果：5, 3, 5, 9，k &#x3D; 2，p &#x3D; [2] &#x3D; 5，此时 k &#x3D; p，结束（k &#x3D; p 的情况在后面会说明）。至此，数组排序为 -1, 1, 2, 5, 3, 5, 9，可以看到并没有对整个数组进行排序。最后只需要返回排序后数组的前 k 个元素即可，即 -1, 1, 2, 5, 3（前 k 个元素不需要有序）</p></li><li><p>p &gt; k</p><p>比如：-1, 2, 3, 4, 1, <strong>5</strong>, 8, 9,  k &#x3D; 3，第一轮求得 p &#x3D; [5] &#x3D; 5</p><p>p 的左边都是小于 p 的，而此时 p &gt; k，代表我们只需要 3 个元素，但是 p 之前却包含了 5 个元素，这超过了我们的所需数量，所以需要再从这 5 个元素找出最小的 3 个，即再对 p 的左边部分进行快排。</p></li><li><p>p &#x3D; k</p><p>比如：-1, 1, <strong>2</strong>, 5, 3, 5, 9，k &#x3D; 2，第一轮求得 p &#x3D; [2] &#x3D; 2</p><p>此时 p &#x3D; k，这代表着：p 左边的元素数量刚好等于所需的数量 k，此时数组的 [0:k-1] 部分已经是所需了，无需任何操作，直接返回即可，</p></li></ol><p>通过上诉操作可以避免对整个数组进行排序，提示了效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    quickSort(arr, k)<br>    <span class="hljs-keyword">return</span> arr[:k]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>q := arr[<span class="hljs-number">0</span>]<br>l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> l &lt; r &#123;<br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[r] &gt; q &#123;<br>r--<br>&#125;<br>arr[l] = arr[r]<br><br><span class="hljs-keyword">for</span> r &gt; l &amp;&amp; arr[l] &lt;= q &#123;<br>l++<br>&#125;<br>arr[r] = arr[l]<br>&#125;<br><br>arr[l] = q<br>    <br>    <span class="hljs-keyword">if</span> l &gt; k &#123;<br>        quickSort(arr[:l], k)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> l &lt; k &#123;<br>        quickSort(arr[l+<span class="hljs-number">1</span>:], k-l<span class="hljs-number">-1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法-3-堆"><a href="#方法-3-堆" class="headerlink" title="方法 3 堆"></a>方法 3 堆</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>h[i], h[j] = h[j], h[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> h[i] &gt; h[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *myHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *myHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>p := (*h)[<span class="hljs-built_in">len</span>(*h)<span class="hljs-number">-1</span>]<br>*h = (*h)[:<span class="hljs-built_in">len</span>(*h)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h myHeap)</span></span> Top() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> h[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    h := <span class="hljs-built_in">new</span>(myHeap)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br><span class="hljs-keyword">if</span> h.Len() &lt; k &#123;<br>            heap.Push(h, arr[i])<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> h.Top() &gt; arr[i] &#123;<br>heap.Pop(h)<br>heap.Push(h, arr[i])<br>&#125;<br>&#125;<br>        <br>&#125;<br><br><span class="hljs-keyword">return</span> *h<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>堆</tag>
      
      <tag>topK</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 92. 反转链表 II</title>
    <link href="/2021/07/20/leetcode-92-fan-zhuan-lian-biao-ii/"/>
    <url>/2021/07/20/leetcode-92-fan-zhuan-lian-biao-ii/</url>
    
    <content type="html"><![CDATA[<p>反转链表的指定部分</p><span id="more"></span><blockquote><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表 。</p><p>示例1：</p><p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5反转前</p><p>1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5反转后</p><p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]</p><p>说明：反转第二个元素到第四个元素这部分（从 1 开始）</p><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p></blockquote><h1 id="方法1-断链，反转，再拼接"><a href="#方法1-断链，反转，再拼接" class="headerlink" title="方法1 断链，反转，再拼接"></a>方法1 断链，反转，再拼接</h1><p>这是一个比较直观，容易想到的方法，首先找到 left 和 right 对应的节点，在上面的例子中，left 对应节点为 2，right 对应节点为 4，然后将 right 断链，即 right.Next &#x3D; nil，此时链表变为：1 -&gt; 2 -&gt; 3 -&gt; 4。同时还要记录 left 的前一个节点和 right 的后一个节点，用于之后恢复链表。</p><p>再定义一个反转链表函数，和 <code>lc206 反转链表</code> 一样，传入参数为 left 节点，函数会把 left 到 right 这部分反转（right 已经断链了，所以不会影响 right 后面的部分），反转过后 2 -&gt; 3 -&gt; 4 变为  4 -&gt; 3 -&gt; 2，但是这时 1 依然还指向 2，所以这里需要更新 1 的指向，将 1 指向反转后的链表头，此时链表为 1 -&gt; 4 -&gt; 3 -&gt; 2，然后再将链表尾指向先前保存的 right 的后一个节点，1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5，大功告成。</p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> (<br>        leftPrev, leftNode *ListNode<br>        rightNext, rightNode *ListNode<br>        count = <span class="hljs-number">1</span><br>    ) <br><br>    h := head<br>    <span class="hljs-keyword">for</span> h != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 找到 left 对应的节点及该节点的 prev 节点</span><br>        <span class="hljs-keyword">if</span> count != left &amp;&amp; leftNode == <span class="hljs-literal">nil</span> &#123;<br>            leftPrev = h<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> count == left &#123;<br>            leftNode = h<br>        &#125;<br>        <br>        <span class="hljs-comment">// 找到 right 对应的节点及该节点的 next 节点</span><br>        <span class="hljs-keyword">if</span> count == right &amp;&amp; rightNode == <span class="hljs-literal">nil</span> &#123;<br>            rightNode = h<br>            rightNext = h.Next<br>        &#125;<br><br>        h = h.Next<br>        count++<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> rightNode != <span class="hljs-literal">nil</span> &#123;<br>        rightNode.Next = <span class="hljs-literal">nil</span>    <span class="hljs-comment">// 断链</span><br>    &#125;<br>    <br><br>    <span class="hljs-comment">// 把 leftNode 到 rightNode 这部分反转</span><br>    reverse(leftNode)<br>    <span class="hljs-comment">//fmt.Println(leftPrev, leftNode, rightNode, rightNext)</span><br>    <span class="hljs-comment">//printList(rightNode)</span><br>    <br>    <span class="hljs-comment">// 反转之后，rightNode 成了头节点，leftNode 成了最后一个节点</span><br>    <span class="hljs-comment">// 此时再将 leftPrev 接上 rightNode，leftNode 接上 rightNext</span><br>    <span class="hljs-keyword">if</span> leftPrev != <span class="hljs-literal">nil</span> &#123;<br>        leftPrev.Next = rightNode<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 leftPrev 为 nil</span><br>        leftNode.Next = rightNext<br>        <span class="hljs-keyword">return</span> rightNode<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> leftNode != <span class="hljs-literal">nil</span> &#123;<br>        leftNode.Next = rightNext<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>        cur = head<br>        next *ListNode<br>        prev *ListNode    <br>    )<br><br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next = cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = next<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调试函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printList</span><span class="hljs-params">(head *ListNode)</span></span> &#123;<br>    h := head<br>    <span class="hljs-keyword">for</span> h != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Print(h.Val, <span class="hljs-string">&quot; -&gt; &quot;</span>)<br>        h = h.Next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码有不少的边界判断，导致略显冗余杂乱，可能更好的解决方法是设置一个<strong>哨兵节点</strong>，这样就可以应对 一些边界情况了，比如 left 是第一个元素，这时 prev 将是 nil，当 leftPrev.Next 时就会报错，但设置了哨兵节点后，prev 是哨兵节点，这样 leftPrev.Next 就不会产生错误了，但是这里我还没有实践，因为还有一种更好的方法。</p><h1 id="方法2-一次遍历"><a href="#方法2-一次遍历" class="headerlink" title="方法2 一次遍历"></a>方法2 一次遍历</h1><p>方法 1 虽然可以 ac，但是不满足题目的进阶要求：只遍历链表一次。在参考了题解后，了解了另一种方法，但是该方法略微有些繁琐，文字难以描述，直接上图更好理解：</p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1626763188487.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> (<br>        s = &amp;ListNode&#123;Next: head&#125;<br>        prev = s<br>        cur, next *ListNode<br>    )<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>        prev = prev.Next<br>    &#125;<br>    cur = prev.Next<br>    next = cur.Next<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; right-left; i++ &#123;<br>        cur.Next = next.Next<br>        next.Next = prev.Next<br>        prev.Next = next<br>        next = cur.Next<br>    &#125; <br><br>    <span class="hljs-keyword">return</span> s.Next<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux select 的错误使用案例</title>
    <link href="/2021/07/18/linux-select-de-cuo-wu-shi-yong-an-li/"/>
    <url>/2021/07/18/linux-select-de-cuo-wu-shi-yong-an-li/</url>
    
    <content type="html"><![CDATA[<p>select 错误使用记录，加深对 select 的理解</p><span id="more"></span><h1 id="错误的代码"><a href="#错误的代码" class="headerlink" title="错误的代码"></a>错误的代码</h1><p>有如下一个使用多路复用 select 实现的 echo（回响）服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>  <span class="hljs-comment">// 简单封装了一下 socket 的创建流程</span><br>    Server <span class="hljs-title function_">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span>;<br>    s.Listen(<span class="hljs-number">1024</span>);<br><br>    fd_set readfds;<br>    <span class="hljs-comment">// 监听服务端socket，当有客户连接时会触发事件</span><br>    FD_ZERO(&amp;readfds);<br>    FD_SET(s.Sockfd(), &amp;readfds);<br><br>    <span class="hljs-type">int</span> maxfd = s.Sockfd();<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-type">int</span> okcnt = select(maxfd+<span class="hljs-number">1</span>, &amp;readfds, nullptr, nullptr, nullptr);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select error\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历 select 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxfd+<span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-comment">// 找到所有值为 1 的 fd，这表示该 fd 已经准备就绪了</span><br>            <span class="hljs-keyword">if</span> (FD_ISSET(i, &amp;readfds)) &#123;<br>                <span class="hljs-comment">// 如果就绪的 fd 为 server,说明有新的连接请求</span><br>                <span class="hljs-keyword">if</span> (i == s.Sockfd()) &#123;<br>                    <span class="hljs-comment">// 调用 accept 接收客户端的连接请求</span><br>                    <span class="hljs-keyword">auto</span> conn = s.Accept();<br>                    <span class="hljs-type">int</span> connfd = conn-&gt;Connfd();<br>                    <span class="hljs-comment">// 更新 maxfd</span><br>                    <span class="hljs-keyword">if</span> (connfd &gt; maxfd) &#123;<br>                        maxfd = connfd;<br>                    &#125;<br>                    <span class="hljs-comment">// 将 conn 的 fd 添加到 select 监听集合中</span><br>                    FD_SET(connfd, &amp;readfds);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected client: %d\n&quot;</span>, conn-&gt;Connfd());<br>                    <span class="hljs-comment">// 如果就绪的 fd 不是 server fd，则是 conn fd</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conn %d is already\n&quot;</span>, i);<br>                    <span class="hljs-comment">// 可以对这些准备就绪的 conn 进行 echo 处理了</span><br>                    <span class="hljs-type">int</span> n = read(i, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// EOF</span><br>                        <span class="hljs-comment">//</span><br>                        FD_CLR(i, &amp;readfds);<br>                        close(i);<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close conn: %d\n&quot;</span>, i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        write(i, buf, n);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    s.Close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>编译并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -o echo_server_wrong_example echo_server_wrong_example.cc<br>./echo_server_wrong_example<br></code></pre></td></tr></table></figure><p>新建一个终端并开启第一个客户端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br></code></pre></td></tr></table></figure><p>此时只连接到服务端，不发送任何数据，服务端的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">connected client: 4<br>conn 4 is already<br></code></pre></td></tr></table></figure><p>随后再新建一个终端并开启第二个客户端，并尝试发送数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br><br>1<br></code></pre></td></tr></table></figure><p>但是没有任何回应，查看服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">connected client: 4<br>conn 4 is already<br></code></pre></td></tr></table></figure><p>根本没有接收第二个服务端的连接！说明编写的这个程序是没有并发能力的，一定是某个地方写错了</p><p>再返回去看第一个客户端是否能正常收到响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br><br>1 // 发送的<br>1// 响应的<br></code></pre></td></tr></table></figure><p>第一个客户端是可以正常工作的</p><p>再将第一个服务端结束，服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">close conn: 4<br></code></pre></td></tr></table></figure><p>此时切换到第二个客户端，发现原来阻塞的请求得到了响应：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc localhost 8080<br><br>1<br>l<br></code></pre></td></tr></table></figure><p>服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 之前的<br>connected client: 4<br>conn 4 is already<br>close conn: 4<br><br>// 新的 <br>connected client: 4<br>conn 4 is already<br></code></pre></td></tr></table></figure><p>并且之后的所有请求都能够得到响应</p><p>此时再启动第一个客户端：</p><p>服务端日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">connected client: 5<br>conn 5 is already<br></code></pre></td></tr></table></figure><p>尝试发送数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">kk<br>kk<br>adasd<br>adasd<br></code></pre></td></tr></table></figure><p>全部能够得到响应</p><p>再切到第二个客户端，并发送数据，结果发现阻塞了，服务端日志没有任何变化</p><h1 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h1><p>修改为正确的程序：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by root on 7/17/21.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../pkg/net/net.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 100</span><br><br><span class="hljs-comment">// g++ -o echo_server echo_server.cc ../pkg/net/net.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[BUF_SIZE];<br>    <span class="hljs-function">Server <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">Listen</span>(<span class="hljs-number">1024</span>);<br><br>    fd_set readfds;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;readfds);<br>    <span class="hljs-comment">// 监听服务端socket，当有客户连接时会触发事件</span><br>    <span class="hljs-built_in">FD_SET</span>(s.<span class="hljs-built_in">Sockfd</span>(), &amp;readfds);<br><br>    <span class="hljs-type">int</span> maxfd = s.<span class="hljs-built_in">Sockfd</span>();<br><br>    <span class="hljs-keyword">for</span> (; ;) &#123;<br>        <span class="hljs-comment">// 这句话非常重要，否则会出现多条连接只有一条能正常工作，其他全部阻塞的 bug</span><br>        <span class="hljs-comment">// readfds 保存的是要监听的 fd 集合，但是每次调用 select 后，会将这些监</span><br>        <span class="hljs-comment">// 听 fd 中已经准备好的置 1，未准备好的置 0，如果使用这个已被更改的 fdset，</span><br>        <span class="hljs-comment">// 可能会导致一些异常情况发生，所以这里将 fdset 拷贝一份，调用 select 时传</span><br>        <span class="hljs-comment">// 入拷贝值，这样 select 的更改就不会影响到原 fdset</span><br>        fd_set cpyset = readfds;<br><br>        <span class="hljs-comment">// okcnt：准备就绪的 fd 数量</span><br>        <span class="hljs-type">int</span> okcnt = <span class="hljs-built_in">select</span>(maxfd+<span class="hljs-number">1</span>, &amp;cpyset, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select error\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (okcnt == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历 select 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxfd+<span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-comment">// 找到所有值为 1 的 fd，这表示该 fd 已经准备就绪了</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(i, &amp;cpyset)) &#123;<br>                <span class="hljs-comment">// 如果就绪的 fd 为 server,说明有新的连接请求</span><br>                <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">Sockfd</span>()) &#123;<br>                    <span class="hljs-comment">// 调用 accept 接收客户端的连接请求</span><br>                    <span class="hljs-keyword">auto</span> conn = s.<span class="hljs-built_in">Accept</span>();<br>                    <span class="hljs-type">int</span> connfd = conn-&gt;<span class="hljs-built_in">Connfd</span>();<br>                    <span class="hljs-comment">// 更新 maxfd</span><br>                    <span class="hljs-keyword">if</span> (connfd &gt; maxfd) &#123;<br>                        maxfd = connfd;<br>                    &#125;<br>                    <span class="hljs-comment">// 将 conn 的 fd 添加到 select 监听集合中</span><br>                    <span class="hljs-built_in">FD_SET</span>(connfd, &amp;readfds);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connected client: %d\n&quot;</span>, conn-&gt;<span class="hljs-built_in">Connfd</span>());<br>                <span class="hljs-comment">// 如果就绪的 fd 不是 server fd，则是 conn fd</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;conn %d is already\n&quot;</span>, i);<br>                    <span class="hljs-comment">// 可以对这些准备就绪的 conn 进行 echo 处理了</span><br>                    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(i, buf, BUF_SIZE);<br>                    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// EOF</span><br>                        <span class="hljs-comment">//</span><br>                        <span class="hljs-built_in">FD_CLR</span>(i, &amp;readfds);<br>                        <span class="hljs-built_in">close</span>(i);<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close conn: %d\n&quot;</span>, i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">write</span>(i, buf, n);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    s.<span class="hljs-built_in">Close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这段代码只更改了几个地方：</p><p>29 行的 <code>fd_set cpyset = readfds</code></p><p>32 行的 <code>select(maxfd+1, &amp;cpyset, nullptr, nullptr, nullptr)</code>，将第二个参数由 <code>readfds</code> 更改为 <code>cpyset</code></p><p>44 行的 <code>if (FD_ISSET(i, &amp;cpyset))</code>，之前为 <code>if (FD_ISSET(i, &amp;readfds))</code></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>简单说明下程序的流程：</p><p>先将服务端 socket 加入到 select 的监听集合，之后调用 select <code>int okcnt = select(maxfd+1, &amp;readfds, nullptr, nullptr, nullptr);</code> 这里会阻塞，直到有 fd 准备好。</p><p>当服务端 socket 准备好了以后，select 返回 1（因为只监听了一个 fd），继续向下执行 <code>for (int i = 0; i &lt; maxfd+1; ++i)</code>，继续执行 <code>if (FD_ISSET(i, &amp;readfds))</code>，这样会遍历 fdset 并找到准备就绪的 fd，此时只有服务端的 fd 准备好了，所以必然进入下面的语句<code>if (i == s.Sockfd())</code>，之后 <code>FD_SET(connfd, &amp;readfds)</code>并且更新 maxfd。</p><p><strong>问题来了</strong>，<code>FD_SET(connfd, &amp;readfds)</code>是希望将 connfd 添加到监听集合中，但是程序会错误的继续执行 <code>for (int i = 0; i &lt; maxfd+1; ++i)</code>，并找到 connfd，因为刚刚的 FD_SET 操作把其置于 1，导致程序错误的认为该 fd 已经准备就绪，又因为不满足 <code>if (i == s.Sockfd())</code>，所以进入 else 分支，进入 <code>read(i, buf, BUF_SIZE)</code> 操作，但是因为该 fd 根本没有准备好，所以整个程序会进入阻塞。</p><p>造成该问题的根本原因是 select 的机制问题：传入要监听的 fd 到 fdset 中，当其返回时，会将监听中已就绪的置1，未就绪的置 0，fdset 即充当了记录被监听 fd 的角色，又充当了记录已就绪 fd 的角色，这样会导致混乱的结果，在错误的程序中就是这样，<code>readfds</code> 充当了两个角色，导致了程序的不正确。</p><p>解决方法就是额外创建一个 fdset，一个用来记录要监听的 fd，一个记录已就绪 fd，在正确的代码中， <code>readfds</code>就是用来<strong>记录要监听的 fd</strong>，<code>cpyset</code> 是用来记录<strong>已就绪 fd</strong>。</p><p>每次 for 循环，<code>cpyset</code> 都会拷贝 <code>readfds</code>获得要监听的所有 fd，并传入 select，得到已就绪的 fd，之后的 FD_ISSET 也是基于cpyset，当要新记录 fd 时，执行语句<code>FD_SET(connfd, &amp;readfds)</code>，将 fd 添加到 readfds 中，删除 fd 时也是 <code>FD_CLR(i, &amp;readfds)</code>，这样二者各司其职，就可以保证程序的正常工作了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多路复用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 516. 最长回文子序列</title>
    <link href="/2021/07/01/leetcode-516-zui-chang-hui-wen-zi-xu-lie/"/>
    <url>/2021/07/01/leetcode-516-zui-chang-hui-wen-zi-xu-lie/</url>
    
    <content type="html"><![CDATA[<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度</p><span id="more"></span><blockquote><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为<br>1000 。</p><p>示例 1:<br>输入:<br>“bbbab”</p><p>输出:<br>4</p><p>一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2:<br>输入:<br>“cbbd”</p><p>输出:<br>2<br>一个可能的最长回文子序列为 “bb”。</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 只包含小写英文字母</p></blockquote><h1 id="方法1-动态规划"><a href="#方法1-动态规划" class="headerlink" title="方法1 动态规划"></a>方法1 动态规划</h1><p>这道题和 <code>LeetCode 5 最长回文子串</code> 类似，（<a href="https://zengh1.github.io/post/leetcode-5-zui-chang-hui-wen-zi-chuan/">https://zengh1.github.io/post/leetcode-5-zui-chang-hui-wen-zi-chuan/</a> ）</p><p><img src="https://zengh1.github.io/post-images/1625109230825.png"></p><p>代码如下：<br><code>cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len, <span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; len; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) &#123;<br>                    dp[i][j] = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>                <br>                maxlen = <span class="hljs-built_in">max</span>(maxlen, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxlen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5. 最长回文子串</title>
    <link href="/2021/06/29/leetcode-5-zui-chang-hui-wen-zi-chuan/"/>
    <url>/2021/06/29/leetcode-5-zui-chang-hui-wen-zi-chuan/</url>
    
    <content type="html"><![CDATA[<p>给你一个字符串 s，找到 s 中最长的回文子串。</p><span id="more"></span><blockquote><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><p>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p>示例 2：</p><p>输入：s &#x3D; “cbbd”<br>输出：”bb”</p><p>示例 3：</p><p>输入：s &#x3D; “a”<br>输出：”a”</p><p>示例 4：</p><p>输入：s &#x3D; “ac”<br>输出：”a”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母（大写和&#x2F;或小写）组成</p></blockquote><h1 id="方法1-动态规划"><a href="#方法1-动态规划" class="headerlink" title="方法1  动态规划"></a>方法1  动态规划</h1><p><img src="https://zengh1.github.io/post-images/1624979080690.png"></p><p>代码如下：</p><p><code>cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(s.<span class="hljs-built_in">size</span>()));<br>        string res;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>(); i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) &#123;   <br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j<span class="hljs-number">-1</span>) &#123;<br>                    dp[i][j] = s[i] == s[j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j-i &gt;= maxlen) &#123;<br>                        maxlen = j - i;<br>                        res = s.<span class="hljs-built_in">substr</span>(i, j-i+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 43. 字符串相乘</title>
    <link href="/2021/06/23/leetcode-43-zi-fu-chuan-xiang-cheng/"/>
    <url>/2021/06/23/leetcode-43-zi-fu-chuan-xiang-cheng/</url>
    
    <content type="html"><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><span id="more"></span><blockquote><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>示例 1:</p><p>输入: num1 &#x3D; “2”, num2 &#x3D; “3”<br>输出: “6”</p><p>示例 2:</p><p>输入: num1 &#x3D; “123”, num2 &#x3D; “456”<br>输出: “56088”</p><p>说明：</p><p>num1 和 num2 的长度小于110。<br>num1 和 num2 只包含数字 0-9。<br>num1 和 num2 均不以零开头，除非是数字 0 本身。<br>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</p></blockquote><h1 id="方法1-模拟数学"><a href="#方法1-模拟数学" class="headerlink" title="方法1 模拟数学"></a>方法1 模拟数学</h1><p>在草稿纸上写一下乘法的运算步骤，并将其改写为代码形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//  45</span><br><span class="hljs-comment">//*  123</span><br><span class="hljs-comment">// --------------</span><br><span class="hljs-comment">//     135</span><br><span class="hljs-comment">//  +  90        </span><br><span class="hljs-comment">//    45</span><br><span class="hljs-comment">// ---------------</span><br><span class="hljs-comment">//    5535</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> (<br>flag <span class="hljs-type">int</span>             <span class="hljs-comment">// 保存进位</span><br>res  <span class="hljs-type">string</span> <br>pown <span class="hljs-type">int</span>             <span class="hljs-comment">// 确定要补几个 0</span><br>)<br>    <br>    <span class="hljs-keyword">if</span> num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>    &#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">var</span> r strings.Builder<br>        <br><span class="hljs-keyword">for</span> j := <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>v1 := <span class="hljs-type">int</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>v2 := <span class="hljs-type">int</span>(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br><br>tmp := v1*v2 + flag<br>flag = tmp / <span class="hljs-number">10</span><br>tmp %= <span class="hljs-number">10</span><br><br>r.WriteByte(<span class="hljs-type">byte</span>(tmp + <span class="hljs-string">&#x27;0&#x27;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> flag != <span class="hljs-number">0</span> &#123;<br>r.WriteByte(<span class="hljs-type">byte</span>(flag) + <span class="hljs-string">&#x27;0&#x27;</span>)<br>flag = <span class="hljs-number">0</span><br>&#125;<br><br>rstr := reverseStr(r.String())<br><br><span class="hljs-comment">//  45</span><br><span class="hljs-comment">//*  123</span><br><span class="hljs-comment">// --------------每步后面补 n-1 个 0，n 为 位数</span><br><span class="hljs-comment">//     135135 补 0 个</span><br><span class="hljs-comment">//     90         =&gt;  900 补 1 个</span><br><span class="hljs-comment">//    45    4500  补 2 个</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; pown; i++ &#123;<br>rstr += <span class="hljs-string">&quot;0&quot;</span><br>&#125;<br>pown++<br><br>    <span class="hljs-comment">// 字符串相加</span><br>res = strAdd(res, rstr)<br>&#125;<br>    <br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseStr</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>b := []<span class="hljs-type">byte</span>(s)<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br>b[i], b[j] = b[j], b[i]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strAdd</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> (<br>flag <span class="hljs-type">int</span><br>res strings.Builder<br>)<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-built_in">len</span>(s1)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(s2)<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>; i, j = i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>v1 = <span class="hljs-type">int</span>(s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>v1 = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>v2 = <span class="hljs-type">int</span>(s2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>v2 = <span class="hljs-number">0</span><br>&#125;<br><br>sum := v1 + v2 + flag<br>flag = sum / <span class="hljs-number">10</span><br>sum %= <span class="hljs-number">10</span><br><br>res.WriteByte(<span class="hljs-type">byte</span>(sum) + <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> flag != <span class="hljs-number">0</span> &#123;<br>res.WriteByte(<span class="hljs-type">byte</span>(flag) + <span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br><br>str := reverseStr(res.String())<br><span class="hljs-keyword">return</span> str<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法2-优化"><a href="#方法2-优化" class="headerlink" title="方法2 优化"></a>方法2 优化</h1><p>方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。具体的方法如下：</p><p><img src="https://zengh1.github.io/post-images/1624428548462.png"></p><p>代码如下：</p><p><code>go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiply</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span><br>    &#125;<br>    <br>    n1l := <span class="hljs-built_in">len</span>(num1)<br>    n2l := <span class="hljs-built_in">len</span>(num2)<br>    <br>    n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n1l+n2l, n1l+n2l)<br>    <br>    <span class="hljs-keyword">for</span> i := n1l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        v1 := num1[i] - <span class="hljs-string">&#x27;0&#x27;</span><br>        <span class="hljs-keyword">for</span> j := n2l - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            v2 := num2[j] - <span class="hljs-string">&#x27;0&#x27;</span><br>            n[i+j+<span class="hljs-number">1</span>] += <span class="hljs-type">int</span>(v1) * <span class="hljs-type">int</span>(v2)<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> (<br>        flag  <span class="hljs-type">int</span><br>        res   strings.Builder<br>        start <span class="hljs-type">int</span><br>    )    <br>        <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(n) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        n[i] += flag<br>        flag = n[i] / <span class="hljs-number">10</span><br>        n[i] %= <span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//fmt.Println(n)</span><br>    <br>    <span class="hljs-keyword">if</span> n[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>        start = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> ; start &lt; <span class="hljs-built_in">len</span>(n); start++ &#123;<br>        s := strconv.Itoa(n[start])<br>        res.WriteString(s)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res.String()<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><code>cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num1 == <span class="hljs-string">&quot;0&quot;</span> || num2 == <span class="hljs-string">&quot;0&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n1l = num1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n2l = num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n1l + n2l)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n1l - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n2l - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                v[i+j+<span class="hljs-number">1</span>] += (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            v[i] += flag;<br>            flag = v[i] / <span class="hljs-number">10</span>;<br>            v[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// for (auto vv : v) &#123;</span><br>        <span class="hljs-comment">//     cout &lt;&lt; vv &lt;&lt; endl;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>        <span class="hljs-keyword">if</span> (v[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            start = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">for</span> (; start &lt; v.<span class="hljs-built_in">size</span>(); start++) &#123;<br>            res += <span class="hljs-built_in">char</span>(v[start]+<span class="hljs-string">&#x27;0&#x27;</span>);    <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 460. LFU 缓存</title>
    <link href="/2021/06/16/leetcode-460-lfu-huan-cun/"/>
    <url>/2021/06/16/leetcode-460-lfu-huan-cun/</url>
    
    <content type="html"><![CDATA[<p>最不经常使用（LFU）缓存算法</p><span id="more"></span><blockquote><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p><p>实现 LFUCache 类：</p><p>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象<br>int get(int key) - 如果键存在于缓存中，则获取键的值，否则返回 -1。<br>void put(int key, int value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。<br>注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</p><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p><p> </p><p>示例：</p><p>输入：<br>[“LFUCache”, “put”, “put”, “get”, “put”, “get”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]<br>输出：<br>[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</p><p>解释：<br>&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数<br>&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）<br>LFUCache lFUCache &#x3D; new LFUCache(2);<br>lFUCache.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1<br>lFUCache.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1<br>lFUCache.get(1);       &#x2F;&#x2F; 返回 1<br>                                  &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2<br>lFUCache.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小<br>                                  &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2<br>lFUCache.get(2);       &#x2F;&#x2F; 返回 -1（未找到）<br>lFUCache.get(3);       &#x2F;&#x2F; 返回 3<br>                                  &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2<br>lFUCache.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用<br>                                  &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2<br>lFUCache.get(1);      &#x2F;&#x2F; 返回 -1（未找到）<br>lFUCache.get(3);      &#x2F;&#x2F; 返回 3<br>                                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3<br>lFUCache.get(4);      &#x2F;&#x2F; 返回 4<br>                                &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</p><p>提示：</p><p>0 &lt;&#x3D; capacity, key, value &lt;&#x3D; 104<br>最多调用 105 次 get 和 put 方法</p><p>进阶：你可以为这两种操作设计时间复杂度为 O(1) 的实现吗？</p></blockquote><h2 id="方法1双哈希表-链表"><a href="#方法1双哈希表-链表" class="headerlink" title="方法1双哈希表+链表"></a>方法1双哈希表+链表</h2><p>哈希表1：</p><p>key 记录使用次数</p><p>value 为一条链表</p><p>因为可能有多个键使用次数相同，所以用链表将这些相同频次的键连接起来，此外，该链表也可以记录这些键的使用时间，链表头为最近使用过的，链表尾为<strong>最近最久未使用</strong>的。当需要淘汰键时，移除链表尾即可，当需要插入时，添加到链表头。</p><p>哈希表2：</p><p>key 与键相同，做快速映射</p><p>value  为链表中的一个节点</p><p>此外，还需要一个 min 值来保存全局最少使用次数，当需要淘汰时便。</p><h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>由题可知，当执行 get 和 put 操作时，都会使得键的使用次数增加，而使用次数增加后，就需要从当前链表移动到其他链表中，操作思路为：先获取到当前键的使用次数，通过 <strong>哈希表1</strong> 定位到所在链表，并从中移除，再通过<strong>哈希表1</strong> 获取 使用次数+1 处的链表，并将键添加到链表头，（这两步都需要注意映射的链表是否为 null，否则会导致空指针错误），此外还需要更新该 key 的使用次数。</p><p>get 首先从 <strong>哈希表2</strong> 中查找，如果找到了，则执行上面的移动操作，并返回值，未找到则返回 -1。</p><p>put 首先需要查找是否存在，如果存在则只更新 value，同时执行移动操作，返回。如果不存在，则需要先判断是否需要淘汰，淘汰可以通过全局最少使用次数 min 从 <strong>哈希表1</strong> 中定位到链表，并移除该链表的尾元素，同时也要从 <strong>哈希表2</strong> 中移除。如果不需要淘汰，则直接添加到两个哈希表即可，因为是新值，所以使用次数为 1，要将 min 置为 1。</p><p>这里还有一个问题，如何更新 min 的值呢？当需要移动时，检查一下移动后，该链表长度是否为 0，如果为空则更新 min。例如：</p><p>哈希表1 情况如下：</p><p>1 -&gt; [3, 3]<br>2 -&gt; [1, 1]<br>此时 min &#x3D; 1</p><p>当执行 get 3 操作时：<br>2 -&gt; [3, 3] -&gt; [1, 1]<br>此时应该更新 min &#x3D; 2</p><p>当 [3, 3] 从 1 移动到 2 后，1 对应的链表长度为 0，且 [3, 3] 的使用次数 &#x3D; min &#x3D; 1，所以需要将 min 更新为 2。</p><p><img src="https://zengh1.github.io/post-images/1623900640431.png"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lfu<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-keyword">type</span> LFUCache <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 记录出现次数，key 为次数，value 为链表，</span><br><span class="hljs-comment">// 因为同一个次数可能有多个值，按照规定，次数相同时按使用时间来比较，</span><br><span class="hljs-comment">// 所以用链表来记录顺序，新节点插入到链表头，当需要淘汰时，淘汰链表尾</span><br>cm <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.List<br><br><span class="hljs-comment">// 以键值 key 为索引，每个索引存放对应缓存在 cm 中链表里的内存地址</span><br>m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element<br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 全局最少使用次数，当需要执行淘汰操作时，通过该变量可以在 O(1) 内定位到 cm 的对应链表</span><br>min <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// node 链表中存储的值</span><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>key <span class="hljs-type">int</span><br>val <span class="hljs-type">int</span><br>cnt <span class="hljs-type">int</span> <span class="hljs-comment">// 使用次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LFUCache &#123;<br><span class="hljs-keyword">return</span> LFUCache&#123;<br>cm:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.List),<br>m:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element),<br><span class="hljs-built_in">cap</span>: capacity,<br>min: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LFUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> c.<span class="hljs-built_in">cap</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">if</span> e, ok := c.m[key]; ok &#123;<br>n := e.Value.(*node)<br><br><span class="hljs-comment">// 将 n 从旧的链表中移除，因为 get() 后其使用次数增加了</span><br><span class="hljs-keyword">if</span> c.cm[n.cnt] != <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt].Remove(e)<br>&#125;<br><br><span class="hljs-comment">// 如果移除后旧链表为空，则更新全局最小使用次数 min</span><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> || c.cm[n.cnt].Len() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 链表为空了，cm 保存也就没意义了，可以从 cm 中删除</span><br><span class="hljs-built_in">delete</span>(c.cm, n.cnt)<br><span class="hljs-keyword">if</span> c.min == n.cnt &#123;<br>c.min++<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 更新 n 的使用次数</span><br>n.cnt++<br><br><span class="hljs-comment">// 获取新的链表，并将 n 添加到头部</span><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt] = list.New()<br>&#125;<br>ele := c.cm[n.cnt].PushFront(n)<br><span class="hljs-comment">// 更新 m 中的信息</span><br>c.m[key] = ele<br><br><span class="hljs-keyword">return</span> e.Value.(*node).val<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LFUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 需要先判断是否存在，再判断容量是否溢出，例如</span><br><span class="hljs-comment">// LFU 容量为 2，现有如下数据：</span><br><span class="hljs-comment">// 1 -&gt; [1,5] -&gt; [2,6]     // 使用 1 次对应的链表</span><br><span class="hljs-comment">// 此时 push [1,2]，如果先判断容量溢出，则会触发移除操作，</span><br><span class="hljs-comment">// 将 [2,6] 移除，导致结果为 1 -&gt; [1,2] -&gt; [1,5]，</span><br><span class="hljs-comment">// 正确结果应该为：</span><br><span class="hljs-comment">// 1 -&gt; [2,6]</span><br><span class="hljs-comment">// 2 -&gt; [1,2]</span><br><br><span class="hljs-comment">// 如果该 key 已经存在</span><br><span class="hljs-keyword">if</span> no, ok := c.m[key]; ok &#123;<br>n := no.Value.(*node)<br><br><span class="hljs-keyword">if</span> c.cm[n.cnt] != <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt].Remove(no)<br>&#125;<br><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> || c.cm[n.cnt].Len() == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">delete</span>(c.cm, n.cnt)<br><span class="hljs-keyword">if</span> c.min == n.cnt &#123;<br>c.min++<br>&#125;<br>&#125;<br><br>n.cnt++       <span class="hljs-comment">// 使用次数 +1</span><br>n.val = value <span class="hljs-comment">// 更新 val</span><br><br><span class="hljs-keyword">if</span> c.cm[n.cnt] == <span class="hljs-literal">nil</span> &#123;<br>c.cm[n.cnt] = list.New()<br>&#125;<br>ele := c.cm[n.cnt].PushFront(n)<br>c.m[key] = ele<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 如果添加该节点后容量溢出，则需要淘汰使用次数最少的节点</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.m) == c.<span class="hljs-built_in">cap</span> &#123;<br><span class="hljs-comment">// 根据 min 字段，取出最小使用次数对应的链表</span><br>l := c.cm[c.min]<br><span class="hljs-keyword">if</span> l != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">//fmt.Println(l.Back())</span><br><span class="hljs-comment">// 该链表的最后一个即为最长时间未使用的节点，将其移除</span><br>rm := l.Remove(l.Back())<br><span class="hljs-comment">// 同时也从 m 中移除</span><br><span class="hljs-built_in">delete</span>(c.m, rm.(*node).key)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// key 不存在</span><br>n := &amp;node&#123;<br>key: key,<br>val: value,<br>cnt: <span class="hljs-number">1</span>,<br>&#125;<br><br><span class="hljs-keyword">if</span> _, ok := c.cm[<span class="hljs-number">1</span>]; !ok &#123;<br>c.cm[<span class="hljs-number">1</span>] = list.New()<br>&#125;<br><br>l := c.cm[<span class="hljs-number">1</span>]<br><span class="hljs-comment">// 添加到计数链表中</span><br>node := l.PushFront(n)<br><span class="hljs-comment">// 添加到 m 中</span><br>c.m[key] = node<br><span class="hljs-comment">// 更新全局最小使用次数 min 为 1</span><br>c.min = <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LFU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25匹马的角逐</title>
    <link href="/2021/06/15/25-pi-ma-de-jiao-zhu/"/>
    <url>/2021/06/15/25-pi-ma-de-jiao-zhu/</url>
    
    <content type="html"><![CDATA[<blockquote><p>25 匹马，5条跑道，每个跑道最多能有 1 匹马进行比赛，（就是说最多同时可以有 5 匹马一起比赛），<br>不能使用计时器，且每匹马的速度都很稳定（意思是在上一场比赛中 A 马比 B 马快，则下一场比赛中A马<br>依然比 B 马快），问最少比多少次能比出前3名和前5名？</p></blockquote><h1 id="前-3-名"><a href="#前-3-名" class="headerlink" title="前 3 名"></a>前 3 名</h1><p>首先将 25 匹马分成 5 组，每组 5 匹马。</p><p><strong>1 - 5 次</strong><br>每组分别进行比赛，选出每组的第一名，假设总体比赛情况为：</p><pre><code class="hljs">    A组：  [A1  A2  A3   A4  A5]    B组：  [B1  B2  B3   B4  B5]    C组：  [C1  C2  C3  C4  C5]    D组：  [D1  D2  D3  D4  D5]    E组：  [E1  E2  E3   E4  E5]</code></pre><p>每组第一名为 [A1, B1, C1, D1, E1]</p><p><strong>第 6 次</strong><br>再对这 5 个第一名进行比赛，这里面的第一名便是所有马中最快的，这里假设结果为 [A1, B1, C1, D1, E1]，第一名为 A1。</p><p>此时第一名已经确定了，还剩下二三名需要确定。</p><p><strong>第 7 次</strong><br>第二名可能是紧随 A1 其后的 A2，同时也可能是 B 组的第一名 B1，因为不能使用计时器，所以无法确定到底是哪个，解决办法就是让 A2 和 B1 进行一次比赛，决出第二名，但是跑道一共有 5 条，现在却只有两匹马参赛，空出来的 3 条跑道岂不是白白浪费了，这里可以利用起来，决出第三名。</p><p>可能出现的情况：</p><ol><li>第二名为 A2<br>那么第三名将从 A2 之后的 A3，以及 B 组的第一 B1 二者中确定。</li><li>第二名为 B1<br>第三名将从 A2，B2，以及 C 组的头榜 C1 中确定。</li></ol><p>第二三名的全部情况：<br>[A2, A3]<br>[A2, B1]<br>[B1, B2]<br>[B1, A2]<br>[B1, C1]</p><p>所以用上面的 5 匹马 [A2, A3, B1, B2, C1] 进行一次比赛即可确定第2，3名，其中的第1，2名则为全部马匹中的第2，3名。</p><p>综上，最少需要 7 次即可确定马匹中的前 3 名。</p><h1 id="前-5-名"><a href="#前-5-名" class="headerlink" title="前 5 名"></a>前 5 名</h1><p><strong>1-7 次</strong><br>和 <strong>前 3 名</strong> 一样，通过这 7 次可以确定出所有马匹中的 1，2，3名。全部情况为：<br>[A1, A2, A3]<br>[A1, A2, B1]<br>[A1, B1, B2]<br>[A1, B1, A2]<br>[A1, B1, C1]</p><p><strong>第 8 次</strong><br>第 8 次需要根据第7场的所有可能的比赛情况进行分析。</p><ol><li><p>第二名 &#x3D; A2，第三名 &#x3D; A3，那么第四名为 A4 或者 B1。</p><ol><li>如果第四名为 A4，那么第五名为 A5 或者 B1。</li><li>如果第四名为 B1，那么第五名为 A4、B2 或者 C1。</li></ol><p>所以用 [A4, B1, A5, B2, C1] 即可确定出第 4，5名，一共需要 8 次。</p></li><li><p>第二名 &#x3D; A2，第三名 &#x3D; B1，那么第四名为 A3 或者 B2 或者 C1。</p><ol><li>如果第四名为 A3，那么第五名为 A4 或者 B2。</li><li>如果第四名为 B2，那么第五名为 B3 或者 A3。  </li><li>如果第四名为 C1，那么第五名从 A3, B2, C2, D1 中产生。</li></ol><p>综上，用 [A3, B2, B3, C1, A4, C2, D1] 七匹马才可以确定4， 5名，而一次比赛最多只能有 5      匹马，所以需要比赛 2 次，一共需要 9 次。</p></li><li><p>第二名 &#x3D; B1，第三名 &#x3D; B2，那么第四名为 B3、A2 或者 C1。</p><ol><li>如果第四名为 B3，那么第五名为 B4、A2、C1。</li><li>如果第四名为 A2，那么第五名为 A3、B3，C1。</li><li>如果第四名为 C1，那么第五名为 A2、B3、C2、D1。</li></ol><p>综上，用 [A2, B3, B4, C1, A3, C2, D1] 七匹马才可以确定4， 5名，而一次比赛最多只能有 5      匹马，所以需要比赛 2 次，一共需要 9 次。</p></li><li><p>第2名&#x3D;B1，第3名&#x3D;A2，和情况 2 一样。</p></li><li><p>第2名&#x3D;B1，第3名&#x3D;C1。那么此种情况下第4名只能在A2、B2、C2、D1中产生。</p><ol><li><p>如果第4名&#x3D;A2，那么第5名只能在A3、B2、C2、D1中产生。</p></li><li><p>如果第4名&#x3D;B2，那么第5名只能在A2、B3、C2、D1中产生。</p></li><li><p>如果第4名&#x3D;C2，那么第5名只能在A2、B2、C3、D1中产生。</p></li><li><p>如果第4名&#x3D;D1，那么第5名只能在A2、B2、C2、D2、E2中产生。</p><p>那么，第4、5名需要在马匹[A2、B2、C2、D1、A3、B3、C3、D2、E1]九匹马中产生，因此也必须比赛两场，也就是到第 9 场决出胜负。</p></li></ol></li></ol><p>综上，确定前 5 名最少需要 8 或 9 次。</p><p>参考：<a href="https://www.iteye.com/blog/hxraid-662643%EF%BC%8C%E8%BF%99%E7%AF%87%E5%8D%9A%E6%96%87%E8%AE%B2%E8%A7%A3%E7%9A%84%E9%9D%9E%E5%B8%B8%E6%A3%92%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E5%B0%86%E5%85%B6%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%AF%9D%E5%86%8D%E5%8F%99%E8%BF%B0%E4%BA%86%E4%B8%80%E9%81%8D%EF%BC%8C%E4%BB%A5%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3%E3%80%82">https://www.iteye.com/blog/hxraid-662643，这篇博文讲解的非常棒，我这里只是将其用自己的话再叙述了一遍，以加深理解。</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>智力题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【两万字长文带你深入Go语言GC源码——腾讯技术工程】阅读笔记</title>
    <link href="/2021/06/04/liang-wan-zi-chang-wen-dai-ni-shen-ru-go-yu-yan-gc-yuan-ma-teng-xun-ji-zhu-gong-cheng-yue-du-bi-ji/"/>
    <url>/2021/06/04/liang-wan-zi-chang-wen-dai-ni-shen-ru-go-yu-yan-gc-yuan-ma-teng-xun-ji-zhu-gong-cheng-yue-du-bi-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：luozhiyun<br>博客：<a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a><br>本文使用的 Go 的源码1.15.7</p></blockquote><p>原文地址：<a href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p><h1 id="1-三色标记法"><a href="#1-三色标记法" class="headerlink" title="1. 三色标记法"></a>1. 三色标记法</h1><h2 id="1-1-三种颜色"><a href="#1-1-三种颜色" class="headerlink" title="1.1 三种颜色"></a>1.1 三种颜色</h2><ul><li><p>黑色：该对象已经被标记过了，且该对象下的属性【这里不是很明白，是指该对象引用的对象？？】也全部都被标记过了（程序所需要的对象）</p><blockquote><p>说明：仅是该对象下的属性，其之下的属性的下面的属性不考虑在内。</p><p>例如：A -&gt; B -&gt; C，当 A 已被标记，且 B 也被标记时，A 就会变成黑色，不需考虑 C 是否被标记，C 是否被标记影响的是 B 能否变成黑色，与 A 无关。</p></blockquote></li><li><p>灰色：该对象已经被标记过了，但该对象下的属性没有全被标记完（GC需要从此对象中去寻找垃圾）；</p></li><li><p>白色：该对象没有被标记过（对象垃圾）；</p></li></ul><p>在垃圾收集器开始工作时，从 GC Roots 开始进行遍历访问，访问步骤可以分为下面几步：</p><ol><li>GC Roots 根对象会被标记成灰色；</li><li>然后从灰色集合中获取对象，将其标记为黑色，将该对象引用到的对象标记为灰色；【只会标记一次，不会递归标记，即不会标记引用对象所引用的对象】</li><li>重复步骤2，直到没有灰色集合可以标记为止；</li><li>结束后，剩下的没有被标记的白色对象即为 GC Roots 不可达，可以进行回收。</li></ol><h2 id="1-2-三色标记存在的问题"><a href="#1-2-三色标记存在的问题" class="headerlink" title="1.2 三色标记存在的问题"></a>1.2 三色标记存在的问题</h2><h3 id="多标-浮动垃圾问题"><a href="#多标-浮动垃圾问题" class="headerlink" title="多标-浮动垃圾问题"></a>多标-浮动垃圾问题</h3><p>文章中已经说的比较清楚了，注意的是，因为一个引用对象被错误的标记为灰色，会导致继续遍历扫描，导致该对象所引用的对象都会被错误标记，最终导致的可能不仅仅是一个对象而是一批对象未被正确回收。</p><h3 id="漏标-悬挂指针问题"><a href="#漏标-悬挂指针问题" class="headerlink" title="漏标-悬挂指针问题"></a>漏标-悬挂指针问题</h3><p>文章中也比较清楚的说明了。</p><blockquote><p>疑问：</p><p>上面两个问题产生的原因在于：在垃圾回收中途，程序又改变了对象之间的引用。为什么允许程序和垃圾回收同时执行？</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>gc</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 78. 子集</title>
    <link href="/2021/06/03/leetcode-78-zi-ji/"/>
    <url>/2021/06/03/leetcode-78-zi-ji/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集不能包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><p>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[[],[0]]</p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p></blockquote><h2 id="方法1-回溯"><a href="#方法1-回溯" class="headerlink" title="方法1 回溯"></a>方法1 回溯</h2><p><img src="https://zengh1.github.io/post-images/1622713584434.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-built_in">backtrack</span>(nums, res, temp, <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, </span></span><br><span class="hljs-params"><span class="hljs-function">                   vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res, </span></span><br><span class="hljs-params"><span class="hljs-function">                   vector&lt;<span class="hljs-type">int</span>&gt; &amp;temp,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        res.<span class="hljs-built_in">emplace_back</span>(temp);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            temp.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>            <span class="hljs-comment">// i+1      ok</span><br>            <span class="hljs-comment">// start+1  !ok</span><br>            <span class="hljs-built_in">backtrack</span>(nums, res, temp, i+<span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux 高性能服务器编程】阅读笔记 第五章 -- Linux 网络编程基础 api</title>
    <link href="/2021/05/29/linux-gao-xing-neng-fu-wu-qi-bian-cheng-yue-du-bi-ji-di-wu-zhang-linux-wang-luo-bian-cheng-ji-chu-api/"/>
    <url>/2021/05/29/linux-gao-xing-neng-fu-wu-qi-bian-cheng-yue-du-bi-ji-di-wu-zhang-linux-wang-luo-bian-cheng-ji-chu-api/</url>
    
    <content type="html"><![CDATA[<h1 id="1-字节序"><a href="#1-字节序" class="headerlink" title="1. 字节序"></a>1. 字节序</h1><p><strong>字节序</strong>：内存中存储多个字节的方式。</p><p>例如一个 16 进制数，它由两个字节组成，内存中存储这两个字节有两种方式，分别为<strong>大端</strong>字节序和<strong>小端</strong> 字节序。</p><p><strong>大端</strong>：高位字节存放在低地址，低位字节存放在高地址。</p><p><strong>小端</strong>：高位字节存放在高地址，低位字节存放在低地址。</p><p>如何区分字节的高低位和地址的高低位？</p><p>0x12            0x34<br>高位字节     低位字节          ← 字节增长方向<br>低地址         高地址             → 内存增长方向</p><h2 id="1-1-网络字节序和主机字节序"><a href="#1-1-网络字节序和主机字节序" class="headerlink" title="1.1  网络字节序和主机字节序"></a>1.1  网络字节序和主机字节序</h2><p><strong>主机字节序</strong>：某个给定系统所用的字节序称为主机字节序。不同的操作系统采用的字节序不同，比如 macos 采用的是大端，而 linux 采用的是小端。</p><p><strong>网络字节序</strong>：为了在信息传输时，屏蔽掉不同硬件结构上的字节序的差异，TCP&#x2F;IP协议规定，所有在网络上传输的多字节整数都以大端序编码，所以大端序就是<code>网络字节序</code>。</p><p>字节序转换的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-comment">// 主机字节序转网络字节序，两个函数的区别在于长度不同</span><br><span class="hljs-comment">// 较短的函数可以用来转换端口号，较长的可以转换 ip 地址</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> host16bitvalue)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> host32bitvalue)</span>;<br><br><span class="hljs-comment">// 网络字节序转主机字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntonhs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> net16bitvalue)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntonhs</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> net32bitvalue)</span>;<br></code></pre></td></tr></table></figure><h1 id="2-socket-api"><a href="#2-socket-api" class="headerlink" title="2. socket api"></a>2. socket api</h1><h2 id="2-1-创建-socket"><a href="#2-1-创建-socket" class="headerlink" title="2.1 创建 socket"></a>2.1 创建 socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> family, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为非负描述符，出错则为 -1</span><br></code></pre></td></tr></table></figure><p>参数描述：</p><ol><li><p><strong>family</strong> 用来选择通信协议，参数主要有以下一些常用类型</p><ul><li><p><strong>AF_UNIX, AF_LOCAL</strong>：用于本地通信，Unix Domain Socket</p></li><li><p><strong>AF_INET</strong>：用于 IP4</p></li><li><p><strong>AF_INET6</strong>：用于 IP6</p></li></ul></li><li><p><strong>type</strong> 指明套接字类型</p><ul><li><p><strong>SOCK_STREAM</strong>      字节流套接字，即 tcp</p></li><li><p><strong>SOCK_DGRAM</strong>           数据包套接字，即 udp</p></li></ul><ul><li><strong>SOCK_NONBLOCK</strong>   将 socket 设置为非阻塞</li><li><strong>SOCK_CLOEXEC</strong>        fork 子进程中关闭该 socket</li></ul></li><li><p><strong>protocol</strong> 在前两个参数构成的协议集合下，再选择一个具体的协议，通常设置为 0 即可（代表默认协议）</p></li></ol><h2 id="2-2-命名-socket"><a href="#2-2-命名-socket" class="headerlink" title="2.2 命名 socket"></a>2.2 命名 socket</h2><p><strong>socket 命名</strong>：将一个 socket 和 socket 地址绑定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> *myaddr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><br><span class="hljs-comment">// 成功返回 0，出错返回 -1</span><br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">servaddr</span>;</span><br><br>bzero(&amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<span class="hljs-comment">// 初始化结构体</span><br><br>servaddr.sin_family = AF_INEF; <span class="hljs-comment">// ip4</span><br>servaddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="hljs-comment">// 指定 ip，并转换为网络序</span><br>servaddr.port = htons(<span class="hljs-number">13</span>);<span class="hljs-comment">// 指定端口号，并转换为网络序</span><br><br><span class="hljs-comment">// 第二个参数需要强转成 struct sockaddr，sockaddr 是一个通用的套接字地址结构</span><br>bind(&amp;servaddr, (<span class="hljs-keyword">struct</span> sockaddr*) &amp;servaddr, <span class="hljs-keyword">sizeof</span>(servaddr));<br></code></pre></td></tr></table></figure><h2 id="2-3-监听-socket"><a href="#2-3-监听-socket" class="headerlink" title="2.3 监听 socket"></a>2.3 监听 socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><br><span class="hljs-comment">// 成功返回 0，出错返回 -1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
    <link href="/2021/05/09/jian-zhi-offer-68-i-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/"/>
    <url>/2021/05/09/jian-zhi-offer-68-i-er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，<br>满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png"></p><p>示例 1:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><p>示例 2:</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br> &gt;</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>方法类似于 <strong>二叉树的最近公共祖先</strong>，但是因为是二叉搜索树，所以难度会降低很多，只要利用搜索树的性质即可。</p><h2 id="方法-1-找到-p-和-q-的路径"><a href="#方法-1-找到-p-和-q-的路径" class="headerlink" title="方法 1 找到 p 和 q 的路径"></a>方法 1 找到 p 和 q 的路径</h2><p>分别找出根节点到 p 的路径和根节点到 q 的路径，再求两条路径中的最后一个相同的节点即可，在普通二叉树中寻找路径需要通过全排列的方式，但是在搜索树中就非常简单了，利用好搜索树的性质即可。</p><p>代码如下（这道题不支持 go，所以用 c++ 实现）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(name) for (auto v : name) &#123;cout <span class="hljs-string">&lt;&lt; v-&gt;</span>val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;; cout &lt;&lt; endl;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt; pv, qv;<br>        <span class="hljs-built_in">get_path</span>(pv, root, p);<br>        <span class="hljs-built_in">get_path</span>(qv, root, q);<br><br>        <span class="hljs-comment">//print(pv);</span><br>        <span class="hljs-comment">//print(qv);</span><br>        TreeNode *res = <span class="hljs-built_in">find_last_same</span>(pv, qv);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_path</span><span class="hljs-params">(vector&lt;TreeNode*&gt; &amp;vec, TreeNode* root, TreeNode* need)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TreeNode *cur = root;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">//cout &lt;&lt; cur-&gt;val &lt;&lt; p-&gt;val &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (need-&gt;val &gt; cur-&gt;val) &#123;<br>                vec.<span class="hljs-built_in">emplace_back</span>(cur);<br>                cur = cur-&gt;right;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (need-&gt;val &lt; cur-&gt;val) &#123;<br>                vec.<span class="hljs-built_in">emplace_back</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                vec.<span class="hljs-built_in">emplace_back</span>(cur);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">find_last_same</span><span class="hljs-params">(vector&lt;TreeNode*&gt; &amp;v1, vector&lt;TreeNode*&gt; &amp;v2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>());<br>        TreeNode* res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">at</span>(i)-&gt;val == v2.<span class="hljs-built_in">at</span>(i)-&gt;val) &#123;<br>                res = v1.<span class="hljs-built_in">at</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方法虽然可以通过，但是较为繁琐，还有更简洁的写法。</p><h2 id="方法-2-迭代"><a href="#方法-2-迭代" class="headerlink" title="方法 2 迭代"></a>方法 2 迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;<br>                root = root-&gt;right;            <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;<br>                root = root-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方法就和 <strong>二叉树的最近公共祖先</strong> 类似了，通过判断 p 和 q 在同侧还是异侧，来决定父节点的值，具体可以参考<a href="https://zengh1.github.io/post/2021-4-3-offer-68-lowest-common-ancestor/">这篇文章</a></p><h2 id="方法3-递归"><a href="#方法3-递归" class="headerlink" title="方法3 递归"></a>方法3 递归</h2><p>方法和迭代一样，只是换成了递归的方式，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
    <link href="/2021/05/04/jian-zhi-offer-57-ii-he-wei-s-de-lian-xu-zheng-shu-xu-lie/"/>
    <url>/2021/05/04/jian-zhi-offer-57-ii-he-wei-s-de-lian-xu-zheng-shu-xu-lie/</url>
    
    <content type="html"><![CDATA[<blockquote><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p>示例 1：</p><p>输入：target &#x3D; 9<br>输出：[[2,3,4],[4,5]]</p><p>示例 2：</p><p>输入：target &#x3D; 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>限制：</p><p>1 &lt;&#x3D; target &lt;&#x3D; 10^5</p></blockquote><h2 id="方法-1-滑动窗口"><a href="#方法-1-滑动窗口" class="headerlink" title="方法 1 滑动窗口"></a>方法 1 滑动窗口</h2><p>通过双指针维护一个窗口，并根据窗口中的和值，来进行相应的移动处理，具体为下：</p><ol><li>和值小于所需的值，扩大窗口，操作为右指针 + 1</li><li>和值大于所需的值，缩小窗口，操作为左指针 + 1</li><li>和值等于所需的值，记录结果，左右指针同时 + 1</li></ol><p>流程如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1620101569463.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContinuousSequence</span><span class="hljs-params">(target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    <span class="hljs-comment">// 构建一个数组用于滑动窗口</span><br>n := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, (target&gt;&gt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(n); i++ &#123;<br>n[i] = i + <span class="hljs-number">1</span><br>&#125;<br><br>i, j := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>sum := n[i] + n[j]<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br><span class="hljs-keyword">if</span> sum &lt; target &#123;<br>j++<br>sum += n[j]<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &gt; target &#123;<br>sum -= n[i]<br>i++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == target &#123; <br><span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i1 := i; i1 &lt;= j; i1++ &#123;<br>temp = <span class="hljs-built_in">append</span>(temp, n[i1])<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, temp)<br>sum -= n[i]<br>i++<br>            <span class="hljs-comment">// j 不是最后一个元素时，才执行下面的操作，</span><br>            <span class="hljs-comment">// 否则 j++ 后会导致 n[j] 越界</span><br><span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span> &#123;<br>j++<br>sum += n[j]<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有以下几点需要注意：</p><ol><li><p>如果需要移动 j 指针，则更新和值操作需要在移动后进行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"> j++<br>sum += n[j]<br></code></pre></td></tr></table></figure></li><li><p>如果需要移动 i 指针，需要在移动前更新和值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sum -= n[i]<br>i++<br></code></pre></td></tr></table></figure></li><li><p>sum &#x3D;&#x3D; target 时 防止 j 越界</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// j 不是最后一个元素时，才执行下面的操作，</span><br><span class="hljs-comment">// 否则 j++ 后会导致 n[j] 越界</span><br><span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(n)<span class="hljs-number">-1</span> &#123;<br>j++<br>sum += n[j]<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="优化一下"><a href="#优化一下" class="headerlink" title="优化一下"></a>优化一下</h2><p>虽然结果是正确的，但是在参考了题解后，发现自己的代码还有一些可以优化的地方，首先是最开始的构建数组，这是完全没必要的，因为是连续正整数序列，所以可以直接把指针作为数字，而不是下标。</p><p>此外，对于 sum &#x3D;&#x3D; target 这种情况，我的处理逻辑是 i 和 j 都移动，但是实际上只需要移动 i 即可，这样可以省去越界判断，且可接减少移动次数。</p><p>减少移动次数示例：<br>i 和 j 都移动</p><ol><li>i &#x3D; 4, j &#x3D; 5, s &#x3D; 9 &#x3D;&#x3D; target  </li><li>i++ &#x3D; 5, j++ &#x3D; 6, sum&#x3D; 11 &gt; 9</li><li>i++ &#x3D; 6，i &#x3D;&#x3D; j ，break</li></ol><p>只移动 i</p><ol><li>i &#x3D; 4, j &#x3D; 5, s &#x3D; 9 &#x3D;&#x3D; target  </li><li>i &#x3D;5, j &#x3D; 5, i &#x3D;&#x3D; j ，break</li></ol><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findContinuousSequence</span><span class="hljs-params">(target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br><br>i, j, sum := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> i &lt; j &#123;<br><span class="hljs-keyword">if</span> sum &lt; target &#123;<br>j++<br>sum += j<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &gt; target &#123;<br>sum -= i<br>i++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum == target &#123; <br><span class="hljs-keyword">var</span> temp []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i1 := i; i1 &lt;= j; i1++ &#123;<br>temp = <span class="hljs-built_in">append</span>(temp, i1)<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, temp)<br>sum -= i<br>i++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 690. 员工的重要性</title>
    <link href="/2021/05/02/leetcode-690-yuan-gong-de-chong-yao-xing/"/>
    <url>/2021/05/02/leetcode-690-yuan-gong-de-chong-yao-xing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id</strong> ，<strong>重要度</strong> 和 <strong>直系下属的 id</strong></p><p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么<br>员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是<br>[3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在<br>员工 1 的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p><p>示例：</p><p>输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>输出：11<br>解释：<br>员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1<br>的总重要度是 5 + 3 + 3 &#x3D; 11 。</p><p>提示：</p><p>一个员工最多有一个 <strong>直系</strong> 领导，但是可以有多个 <strong>直系</strong> 下属<br>员工数量不超过 2000 。</p></blockquote><h2 id="方法1-普通递归"><a href="#方法1-普通递归" class="headerlink" title="方法1  普通递归"></a>方法1  普通递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * type Employee struct &#123;</span><br><span class="hljs-comment"> *     Id int</span><br><span class="hljs-comment"> *     Importance int</span><br><span class="hljs-comment"> *     Subordinates []int</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(employees []*Employee, id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>dfs(employees, id, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(emp []*Employee, id <span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> emp &#123;<br><span class="hljs-keyword">if</span> v.Id == id &#123;<br>*res += v.Importance<br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> v.Subordinates &#123;<br>dfs(emp, s, res)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">执行用时: <span class="hljs-number">8</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">内存消耗: 6</span>.<span class="hljs-number">6</span> MB<br></code></pre></td></tr></table></figure><h2 id="方法2-递归-哈希表"><a href="#方法2-递归-哈希表" class="headerlink" title="方法2  递归 + 哈希表"></a>方法2  递归 + 哈希表</h2><p>通过哈希表可以在 O(1) 内通过 id 查找到对象，而无需遍历数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * type Employee struct &#123;</span><br><span class="hljs-comment"> *     Id int</span><br><span class="hljs-comment"> *     Importance int</span><br><span class="hljs-comment"> *     Subordinates []int</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(employees []*Employee, id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Employee)<br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> employees &#123;<br>        m[v.Id] = v<br>    &#125;<br>    <br>    dfs(m, id, &amp;res)<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Employee, id <span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>    e := m[id]<br>    *res += e.Importance<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> e.Subordinates &#123;<br>        dfs(m, v, res)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">执行用时: <span class="hljs-number">16</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">内存消耗: 6</span>.<span class="hljs-number">8</span> MB<br></code></pre></td></tr></table></figure><p>为什么反而更慢了。。。</p><h2 id="方法3-迭代"><a href="#方法3-迭代" class="headerlink" title="方法3 迭代"></a>方法3 迭代</h2><p>通过队列 + 哈希表来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for Employee.</span><br><span class="hljs-comment"> * type Employee struct &#123;</span><br><span class="hljs-comment"> *     Id int</span><br><span class="hljs-comment"> *     Importance int</span><br><span class="hljs-comment"> *     Subordinates []int</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getImportance</span><span class="hljs-params">(employees []*Employee, id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*Employee)<br>    <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> employees &#123;<br>        m[e.Id] = e<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    queue := list.New()<br>    queue.PushBack(m[id])<br>    <br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        pop := queue.Remove(queue.Front()).(*Employee)<br>        res += pop.Importance<br>        <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> pop.Subordinates &#123;<br>            queue.PushBack(m[e])<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">执行用时: <span class="hljs-number">12</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">内存消耗: 6</span>.<span class="hljs-number">7</span> MB<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Parallels Desktop 16 网络初始化失败和不能连接USB设备解决方法</title>
    <link href="/2021/05/01/parallels-desktop-16-wang-luo-chu-shi-hua-shi-bai-he-bu-neng-lian-jie-usb-she-bei-jie-jue-fang-fa/"/>
    <url>/2021/05/01/parallels-desktop-16-wang-luo-chu-shi-hua-shi-bai-he-bu-neng-lian-jie-usb-she-bei-jie-jue-fang-fa/</url>
    
    <content type="html"><![CDATA[<p>Parallels Desktop 16 在最新的macOS Big Sur 11.0系统上无法联网，并且无法连接USB设备。之前解决联网的办法是在终端通过命令启动parallels desktop的方法解决联网的问题，但是相对比较麻烦，而且还是无法解决Parallels Desktop 16 不能连接USB设备的问题。</p><p>今天小编为大家提供一个更好的方法解决Parallels Desktop 16 不能联网与连接USB设备的问题。详细操作步骤如下：</p><p>1、打开访达，按下shift+command+G 三个键，前往文件夹：&#x2F;Library&#x2F;Preferences&#x2F;Parallels ；</p><p>2、下载 Sublime Text 打开文件 network.desktop.xml ，找到第5行的 <UseKextless>-1</UseKextless> （也可能是 <UseKextless>1</UseKextless> ），修改为 <UseKextless>0</UseKextless>  保存并退出，保存时会提示输入密码，输入系统密码确定即可；</p><p>3、用 Sublime Text 打开文件 dispatcher.desktop.xml ，按 command + F 查找 <Usb>0</Usb> ，修改为 <Usb>1</Usb> 保存并退出，保存时会提示输入密码，输入系统密码确定即可；    </p><p>4、然后打开Parallels Desktop 16，可能会提示 Parallels需要系统扩展 ，打开 系统偏好设置 ，进入 安全性与隐私 ，点击左下角的锁图标解锁，在点击下方【 来自开发者“Parallels International GmbH”的系统软件已被阻止载入。 】右侧的 允许 按钮，提示需要重启，点击确定重启电脑，再打开Parallels Desktop 16进入Windows系统即可正常上网和连接USB设备了。</p><p>————————————————<br>版权声明：本文为CSDN博主「blank_t」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/blank_t/article/details/111567618">https://blog.csdn.net/blank_t/article/details/111567618</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go：记一次 defer 错误</title>
    <link href="/2021/04/23/goji-yi-ci-defer-cuo-wu/"/>
    <url>/2021/04/23/goji-yi-ci-defer-cuo-wu/</url>
    
    <content type="html"><![CDATA[<h2 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> err := func1(); err != <span class="hljs-literal">nil</span> &#123;     <span class="hljs-comment">// func1() 会产生错误</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer func&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数不会输出 ”defer func“，因为压根就没有执行到 defer 处，导致 defer 没有注册（或者说是压入栈中？还不了解 defer 的原理）</p><p>正确写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer func&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err := func1(); err != <span class="hljs-literal">nil</span> &#123;     <span class="hljs-comment">// func1() 会产生错误</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把 defer 定义在前面就好了，这样在一开始就会将 defer 函数注册。<br>看来还是得多写写项目才能发现自己的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再探 for 循环</title>
    <link href="/2021/04/23/wei-shi-me-bu-neng-yong-bian-liang-bao-cun-die-dai-qi/"/>
    <url>/2021/04/23/wei-shi-me-bu-neng-yong-bian-liang-bao-cun-die-dai-qi/</url>
    
    <content type="html"><![CDATA[<p>有如下 <code>c++</code> 代码，它的功能是删除容器中所有小于 10 的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>&#125;;<br><span class="hljs-type">int</span> xx = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f = l.<span class="hljs-built_in">front</span>(); f &lt; xx &amp;&amp; !l.<span class="hljs-built_in">empty</span>(); ) &#123;<br>    l.<span class="hljs-built_in">pop_front</span>();<br>&#125;<br><br>for_each(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> v) -&gt; <span class="hljs-type">void</span> &#123;<br>    cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;);<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这段代码的逻辑是：首先获取 list 的第一个元素的值，用变量 f 保存，再用 f 和 变量 xx 比较，如果 f &lt; xx 且 list 不为空，则移除 list 的第一个元素。</p><p>正确的结果应该是 [12, 13, 15]，但是运行上面的代码，结果却为空，容器里的所有元素都被删掉了。</p><p>将上面的 for 改成下面的代码后，结果正确</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (; l.<span class="hljs-built_in">front</span>() &lt; xx &amp;&amp; !l.<span class="hljs-built_in">empty</span>(); ) &#123;<br>        l.<span class="hljs-built_in">pop_front</span>();<br> &#125;<br></code></pre></td></tr></table></figure><p>原因出在 auto f &#x3D; l.front() 这里了，打印一下该值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>&#125;;<br><span class="hljs-type">int</span> xx = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f = l.<span class="hljs-built_in">front</span>(); f &lt; xx &amp;&amp; !l.<span class="hljs-built_in">empty</span>(); ) &#123;<br>    l.<span class="hljs-built_in">pop_front</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<code>1 1 1 1 1 1 1</code></p><p>我希望的是每次 for 都会更新 f 的值，因为执行了 pop_front() 后，l.front() 也随之改变，所以用来保存 front() 的变量 f 也需要改变，但这恰好说明了我的基础不牢固，对 for 循环的理解不到位。</p><p>参见菜鸟教程中对 for 循环的讲解：（<a href="https://www.runoob.com/cplusplus/cpp-for-loop.html%EF%BC%89">https://www.runoob.com/cplusplus/cpp-for-loop.html）</a></p><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">for</span> ( init; condition; increment )<br>&gt;&#123;<br> <span class="hljs-built_in">statement</span>(s);<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里<br>写任何语句，只要有一个分号出现即可。</p></blockquote><p>for 循环的第一个语句只会执行一次，上面的运行结果可以证明这一点，有这一句话就可以解释上面的所有问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 67. 把字符串转换成整数</title>
    <link href="/2021/04/21/jian-zhi-offer-67-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu/"/>
    <url>/2021/04/21/jian-zhi-offer-67-ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为<br>该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造<br>成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符<br>时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超<br>过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42</p><p>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p><p>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p><p>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>    因此无法执行有效的转换。</p><p>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>因此返回 INT_MIN (−231) 。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题乍一看好像没什么特殊之处，不就是一个 atoi 嘛，只是这个 28% 的通过率有些不对劲，等到自己写的时候才发现，这道题太 tm 恶心了，有各种各样的特殊情况，比如：</p><ol><li>”          +1“      空格后面紧跟一个符号</li><li>”         +-1“     两个符号在一起</li><li>”   +0 123“      两个数字之间有空格</li><li>”0-1“              两个数字之间右符号</li><li>还有溢出的问题，如果小于 minInt32，则返回 minInt32，maxInt32 同理</li></ol><p>这些条件会导致写出来的代码非常繁琐，而且非常容易出错，往往是解决了一种情况，又导致另一种情况错误，有点像边修 bug 边造 bug。</p><h2 id="方法1-自动机"><a href="#方法1-自动机" class="headerlink" title="方法1 自动机"></a>方法1 自动机</h2><p>自动机表示如下：</p><table><thead><tr><th align="center"></th><th align="center">start</th><th align="center">signed</th><th align="center">in_number</th><th align="center">end</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">in_number</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>解释：<br>start：代表空格<br>signed：代表 “+” 或者 “-”<br>in_number：代表数字<br>end：代表其他字符</p><p>当 start 遇到 start 时：代表空格遇到空格，状态依然为 start，例如 “      ”<br>当 start 遇到 signed 时：代表空格遇到 + 或 -，状态改变为 signed，例如 “      +”<br>当 start 遇到 in_number 时：代表空格遇到数字，状态改变为 in_number，例如 “       1”<br>当 start 遇到 end 时：代表空格遇到其他字符，状态改变为 end，例如 “         a”</p><p>当 signed 遇到 start 时：代表符号遇到空格，例如 “+     ”，此时为非法，状态改为 end<br>当 signed 遇到 signed 时：代表符号遇到符号：例如 “++”，此时为非法，状态改为 end<br>当 signed 遇到 in_number 时，代表符号遇到数字，例如 “+1”，合法且为一个数字，状态改为 in_number<br>当 signed 遇到 end 时，代表符号遇到其他字符，例如 “+a”，此时为非法，状态改为 end</p><p>下面为简写，x -&gt; y 表示为 x 遇到 y，” “ 为示例，stat 为更新后的状态</p><p>in_number -&gt; start：”1     “，stat &#x3D; end<br>in_number -&gt; signed：”1+”，stat &#x3D; end<br>in_number -&gt;  in_number：”12”，stat &#x3D; in_number<br>in_number -&gt; end：”1a”，stat &#x3D; end</p><p>end -&gt; start：”a “，stat &#x3D; end<br>end -&gt; signed：”a+”，stat &#x3D; end<br>end -&gt; in_number：”a1”，stat &#x3D; end<br>end -&gt; end：”ab”，stat &#x3D; end</p><p>理解了自动机以后，也就有了一些写代码的思路了，不得不说这种方法真的十分巧妙，能够轻松化解各种繁杂的 if else 条件和边界判断。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对应之前的自动机图表</span><br><span class="hljs-keyword">var</span> stat = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;sign&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;sign&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;num&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>    <span class="hljs-string">&quot;end&quot;</span>: &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 对应自动机图表的表头</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getStat</span><span class="hljs-params">(c <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> unicode.IsSpace(c) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> unicode.IsDigit(c) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    is := <span class="hljs-string">&quot;start&quot;</span><br>    sign := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int</span><br>    <br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> s &#123;<br>        is = stat[is][getStat(c)]<br>        <span class="hljs-keyword">if</span> is == <span class="hljs-string">&quot;num&quot;</span> &#123;<br>            res = res*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-comment">// math.MinInt32: -2147483648</span><br>            <span class="hljs-comment">// math.MaxInt32: 2147483647</span><br>            <span class="hljs-keyword">switch</span> sign &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                res = min(res, math.MaxInt32)<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>                <span class="hljs-comment">// min(res, math.MaxInt32)</span><br>                <span class="hljs-comment">// 输入：&quot;-91283472332&quot;</span><br>                <span class="hljs-comment">// 输出：-2147483647</span><br>                <span class="hljs-comment">// 预期：-2147483648</span><br>                <span class="hljs-comment">// -math.MinInt32 ????</span><br>                res = min(res, -math.MinInt32)    <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> is == <span class="hljs-string">&quot;sign&quot;</span> &#123;<br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>                sign = <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sign = <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res * sign<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>       <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要说明一下 <code>sign = -1</code> 时的溢出判断 <code>res = min(res, -math.MinInt32)</code> ，为什么要加负号呢？以测试用例 <code>-91283472332</code> 为例，正确的结果为 <code>-2147483648</code>：</p><p>(注：math.MinInt32: -2147483648    math.MaxInt32: 2147483647)</p><p>因为有负号，所以 sign 的值更新为 -1，而最后返回的的结果为 res * sign，即 - res，所以需要为 math.MinInt32 添加一个符号，将其变为 2147483648，这样再与 sign 相乘，得到的就是一个负数了。</p><p>此外，如果条件为 min(res, math.MinInt32)，那么当 res 为 -42 时，并没有溢出，但是会错误的返回 MinInt32，如果改为 -math.MinInt32 则会正确的返回 -42 了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>剑指offer</tag>
      
      <tag>自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 394. 字符串解码</title>
    <link href="/2021/04/19/leetcode-394-zi-fu-chuan-jie-ma/"/>
    <url>/2021/04/19/leetcode-394-zi-fu-chuan-jie-ma/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k<br>保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] <br>的输入。</p><p>示例 1：</p><p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”</p><p>示例 2：</p><p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”</p><p>示例 3：</p><p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”</p><p>示例 4：</p><p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”</p></blockquote><h1 id="方法1-两个辅助栈"><a href="#方法1-两个辅助栈" class="headerlink" title="方法1 两个辅助栈"></a>方法1 两个辅助栈</h1><p><img src="https://zengh1.github.io/post-images/1619947305597.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    resStack := list.New()<br>    culStack := list.New()<br>    <br>    mul, res := <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        c := <span class="hljs-type">byte</span>(char)<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            resStack.PushBack(res)<br>            culStack.PushBack(mul)<br>            mul = <span class="hljs-number">0</span><br>            res = <span class="hljs-string">&quot;&quot;</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;]&#x27;</span> &#123;<br>            <span class="hljs-keyword">var</span> temp <span class="hljs-type">string</span><br>            cpop := culStack.Remove(culStack.Back()).(<span class="hljs-type">int</span>)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cpop; i++ &#123;<br>                temp += res<br>            &#125;<br>            rpop := resStack.Remove(resStack.Back()).(<span class="hljs-type">string</span>)<br>            res = rpop + temp<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>            mul = mul*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(c-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res += <span class="hljs-type">string</span>(c)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res            <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go：http.Request.Body 第二次读取为空 </title>
    <link href="/2021/04/17/goiocopy-de-keng/"/>
    <url>/2021/04/17/goiocopy-de-keng/</url>
    
    <content type="html"><![CDATA[<p>有如下代码，先使用 io.Copy 将 request.Body copy 到 stdout 标准输出，再使用 io.ReadAll 再次读取 request.Body：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>io.WriteString(os.Stdout, <span class="hljs-string">&quot;read request body from io.Copy: &quot;</span>)<br>io.Copy(os.Stdout, r.Body)<br>io.WriteString(os.Stdout, <span class="hljs-string">&quot;\n&quot;</span>)<br>    <br>body, err := io.ReadAll(r.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read request body error: &quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;read request body from io.ReadAll: &quot;</span>, body)<br>&#125;)<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 curl 访问接口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl localhost:8080 -d <span class="hljs-string">&quot;user=admin&amp;passwd=12345678&quot;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http server 这边的输出：</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run http_readcloser.go</span><br>read request body from io.Copy: user=admin&amp;passwd=12345678<br>read request body from io.ReadAll:  []<br></code></pre></td></tr></table></figure><p>执行时发现 io.ReadAll() 读出来的内容始终为空。</p><p>原因：<br><del>【猜测】copy() 会将 src 清空而不是 copy，这和它的函数名不符，</del></p><p>copy 函数没有问题，对于这种标准库的东西也不可能犯这种低级错误，真正的原因在于 http.Request.Body。</p><p>http.request.Body 是 readCloser 类型的，我们使用 ReadAll 读取 http.request.Body 后将无法再次读取 http.request.Body 里面的信息</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-keyword">var</span> bodyB []<span class="hljs-type">byte</span><br>bodyB, _ = io.ReadAll(r.Body)<br>fmt.Println(bodyB)<br><br>  <span class="hljs-comment">// 把刚刚读出来的再写进去</span><br>r.Body = io.NopCloser(bytes.NewReader(bodyB))<br>all, _ := io.ReadAll(r.Body)<br>fmt.Println(all)<br></code></pre></td></tr></table></figure><h2 id="为什么-Request-Body-只能读取一次（未解决）"><a href="#为什么-Request-Body-只能读取一次（未解决）" class="headerlink" title="为什么 Request.Body 只能读取一次（未解决）"></a>为什么 Request.Body 只能读取一次（未解决）</h2><h2 id="NopCloser"><a href="#NopCloser" class="headerlink" title="NopCloser()"></a>NopCloser()</h2><p>该函数将一个 reader 类型包装成 readCloser 类型，而相应的 Close 方法啥也不做，只是返回 nil。</p><p>源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NopCloser returns a ReadCloser with a no-op Close method wrapping</span><br><span class="hljs-comment">// the provided Reader r.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NopCloser</span><span class="hljs-params">(r Reader)</span></span> ReadCloser &#123;<br><span class="hljs-keyword">return</span> nopCloser&#123;r&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> nopCloser <span class="hljs-keyword">struct</span> &#123;<br>Reader<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go：ioutil.ReadAll() 引发的 out of memory </title>
    <link href="/2021/04/16/goioutilreadall-yin-fa-de-out-of-memory/"/>
    <url>/2021/04/16/goioutilreadall-yin-fa-de-out-of-memory/</url>
    
    <content type="html"><![CDATA[<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>某天突发奇想，写了一个在线阅读的 http 小程序，当访问某一路由时会读取电子书文件，并写入到 response 中，其中封装了一个读取文件的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(src <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>file, err := os.Open(src)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>b, err := io.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-keyword">return</span> b, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很简单的一个函数，使用 io.ReadAll() （在 go 1.16 中废弃了 ioutil包，将其中的函数全部移到了 io 包下）读取文件为字节切片并返回，这里读取的文件是电子书。</p><p>但是当部署到服务器上（1核 2g 的学生服务器）并访问路由时，产生了 out of memory  异常，致使程序中指，这是一个我还未曾见过的错误，同时也比较诧异，这样一个简单的小程序为什么会内存溢出呢？</p><p>从错误的提示信息中，定位到了问题的所在为：io.ReadAll()，早就听说过这个函数是一次性将文件全部读取的，在文件较大时不建议使用（go 语言圣经中有提到），但也没太当回事，毕竟这个所谓的“文件较大”过于宽泛，但经过这次的错误后，我对文件较大这个概念有了新的认识，在我这台土豆服务器上，读取一个 300m 的文件会直接导致内存溢出，服务器的内存使用情况：<code>KiB Mem :  1882892 total,    70112 free,  1347204 used</code> ，也就是说使用 ReadAll() 读取一个 300m 的文件，会占用超过 700m 的内存。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>将 ReadAll() 替换为 io.Copy() 即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 字节数组错误：&#92;u0001</title>
    <link href="/2021/04/16/2021-3-13-byte-array/"/>
    <url>/2021/04/16/2021-3-13-byte-array/</url>
    
    <content type="html"><![CDATA[<p>在做 <code>压缩字符串</code> 这道题时，提交的输出结果十分诡异，如下：</p><p>输入：</p><p>[“a”,”a”,”b”,”b”,”c”,”c”,”c”]</p><p>输出：</p><p>[“a”,”\u0002”,”b”,”\u0002”,”c”,”\u0003”]</p><p>预期：</p><p>[“a”,”2”,”b”,”2”,”c”,”3”]</p><p>可以看到结果中的数字部分是对的，但是多了 \u000 这部分，这个结果令我百思不得其解，在 ide 中运行时正常的，但在力扣上运行一直都会有 <code>\u000</code> ，起初还以为是力扣的问题，在查阅资料以后终于找到了原因所在，是一个比较低级的错误。</p><p>大概是力扣会将运行的字节数组转换为字符串，而字符数组转字符串会根据 <code>ascii</code> 来映射转换，问题来了，我的字节数组里存储的全部都是 1 - 9 的数字，而不是数字对应的 ascii 码，所以在转换后无法输出有效字符，解决的方法也很简单，只要在存储的值上加 ‘0’ 即可（ascii 为48）</p><p>比如，原先的字节数组是 [2, 2, 3]，再加 48 以后，变成了 [50, 50, 51]，ascii 50 对应十进制 2，ascii 51 对应十进制 3，此时转换后的结果就是正确的了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang GDB 调试提示 No symbol table is loaded. Use the &quot;file&quot; command</title>
    <link href="/2021/04/16/2021-4-10-golang-gdb/"/>
    <url>/2021/04/16/2021-4-10-golang-gdb/</url>
    
    <content type="html"><![CDATA[<p>背景：</p><blockquote><p>本地 MacOS 上通过 GDB 调试 golang 程序，结果提示 No symbol table is loaded. Use the “file”<br>command.</p></blockquote><p>解决方法：</p><blockquote><p>打包时加上 -ldflags&#x3D;-compressdwarf&#x3D;false 参数即可 比如在作者本地就是 go build -gcflags “-N -l”<br>-ldflags&#x3D;-compressdwarf&#x3D;false gdb&#x2F;main.go 然后通过命令 gdb main 即可调试</p></blockquote><p>参考：<a href="https://kaijuan.co/topics/25/no-symbol-table-is-loaded-use-the-file-command">https://kaijuan.co/topics/25/no-symbol-table-is-loaded-use-the-file-command</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gdb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++：iterator.begin() 和 *iterator.begin() 的区别 【未完】</title>
    <link href="/2021/04/16/2021-4-14-whats-different-in-cpp-iterator-var/"/>
    <url>/2021/04/16/2021-4-14-whats-different-in-cpp-iterator-var/</url>
    
    <content type="html"><![CDATA[<h2 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述"></a>情景描述</h2><p>有如下 <code>c++</code> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> b = vec.<span class="hljs-built_in">begin</span>();<br>*b = <span class="hljs-number">99999</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i : vec) &#123;<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-comment">// Output: 99999 2 3 4 5</span><br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">auto</span> bb = *vec.<span class="hljs-built_in">begin</span>(); <br>cout &lt;&lt; <span class="hljs-string">&quot;bb: &quot;</span> &lt;&lt; bb &lt;&lt; endl;<br>bb = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp; i : vec) &#123;<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-comment">// Output: 99999 2 3 4 5</span><br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>通过 <em>b 的方式可以更改元素的值，而 bb 则不行。这里我比较疑惑的是，</em>b 和 *vec.begin() 难道不一样吗？</p><p>通过编译器查看得知，b 的类型是 <code>__wrap_iter&lt;vector&lt;int, allocator&lt;_Tp&gt;&gt;::pointer&gt;</code>，bb 的类型是 <code>int</code>，这让我有了一些思路。</p><p>举一个指针的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> *p = &amp;i;<br><br><span class="hljs-comment">// 类似上面的 b</span><br><span class="hljs-type">int</span> *b = p;<br>*b = <span class="hljs-number">555</span>;<br>cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 555</span><br>                    <span class="hljs-comment">// 修改成功</span><br><br><span class="hljs-comment">// 类似上面的 bb</span><br><span class="hljs-type">int</span> bb = *p;<br>bb = <span class="hljs-number">555</span>;<br>cout &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">// Output: 5</span><br>                  <span class="hljs-comment">//  未修改</span><br></code></pre></td></tr></table></figure><p>b 保存的是 p 指向的地址，也就是 i，所以通过解引用 *b 的方式可以更改掉 i 的值，而 bb 保存的是 p 解引用的值，仅仅是一个 int 变量，而不是地址，自然也不会对 i 产生任何影响。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>鉴于还处于初学 c++ 的阶段，对迭代器以及语言本身都不熟悉，所以以上仅仅是猜想，本文仅做保存记录，方便以后的回看。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd 错误：context deadline exceeded</title>
    <link href="/2021/04/16/2020-10-17-etcd-error/"/>
    <url>/2021/04/16/2020-10-17-etcd-error/</url>
    
    <content type="html"><![CDATA[<h1 id="etcd-远程操作失败：Error-context-deadline-exceeded"><a href="#etcd-远程操作失败：Error-context-deadline-exceeded" class="headerlink" title="etcd 远程操作失败：Error: context deadline exceeded"></a>etcd 远程操作失败：Error: context deadline exceeded</h1><p>在服务器启动 etcd，并在本地机器通过 <strong>etcdctl –endpoints&#x3D;<a href="http://ip:2379/">http://ip:2379</a> put name “123”</strong> 命令，在服务器的 etcd 中创建一对键值对， 如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1618573630890.jpg"></p><p>服务端 etcd 的启动命令如下：</p><p><img src="https://zengh1.github.io/post-images/1618573644827.jpg"></p><p>但是在执行 etcdctl 命令后发生了错误：</p><p><img src="https://zengh1.github.io/post-images/1618573652525.jpg"></p><p>经过网上查阅资料，终于找到了解决方法，在启动 etcd 时，需要添加一些参数，否则远程连接无法执行，</p><p>完整命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./etcd --listen-client-urls http://0.0.0.0:2379 --advertise-client-urls http://0.0.0.0:2379 --listen-peer-urls http://0.0.0.0:2380 --initial-advertise-peer-urls http://0.0.0.0:2380  --initial-cluster my-etcd-1=http://0.0.0.0:2380</span><br></code></pre></td></tr></table></figure><p>将ip为0.0.0.0可以理解为不限制连接机器（真正的生产不推荐这样设置）。 </p><p>使用上面的命令启动 etcd 后，本地机就可以正常的对其执行操作了</p><p><img src="https://zengh1.github.io/post-images/1618573663493.jpg"></p><p>参考：<a href="https://github.com/yuedun/micro-service/blob/master/README.md">https://github.com/yuedun/micro-service/blob/master/README.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>issues</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题 01.06. 字符串压缩</title>
    <link href="/2021/04/16/2021-3-13-ctcl-0106-compress-string/"/>
    <url>/2021/04/16/2021-3-13-ctcl-0106-compress-string/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p>示例1:</p><p>输入：”aabcccccaaa”<br> 输出：”a2b1c5a3”<br>示例2:</p><p>输入：”abbccd”<br> 输出：”abbccd”<br> 解释：”abbccd”压缩后为”a1b2c2d1”，比原字符串长度更长。<br>提示：</p><p>字符串长度在[0, 50000]范围内。</p></blockquote><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><img src="https://zengh1.github.io/post-images/1618573324644.png"></p><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compressString</span><span class="hljs-params">(S <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> sb strings.Builder<br>    p, l := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    <span class="hljs-comment">// l 记录长度，初始值为 1</span><br>    <span class="hljs-keyword">var</span> cur <span class="hljs-type">byte</span><br><br>    <span class="hljs-comment">// 指针 p 从 0 开始，i 从 1 开始</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(S); i++ &#123;<br>        cur = S[p]<br>        <span class="hljs-keyword">if</span> S[i] == cur &#123;<br>            l++<br>        &#125; <span class="hljs-keyword">else</span>  &#123;<br>            sb.WriteByte(cur)<br>            sb.WriteString(strconv.Itoa(l))<br>            l = <span class="hljs-number">1</span>   <span class="hljs-comment">// 重置 l</span><br>        &#125; <br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(S) - <span class="hljs-number">1</span> &#123;    <span class="hljs-comment">// 到最后一个 char 了</span><br>            sb.WriteByte(S[i])  <br>            sb.WriteString(strconv.Itoa(l))<br>        &#125;<br>        p++<br>    &#125;<br><br>    <span class="hljs-comment">// 压缩后没有变短则返回原先的字符串</span><br>    <span class="hljs-comment">// 长度为 1 的也直接返回</span><br>    <span class="hljs-keyword">if</span> sb.Len() &gt;= <span class="hljs-built_in">len</span>(S) || <span class="hljs-built_in">len</span>(S) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> S<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>程序员面试金典</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <link href="/2021/04/16/2021-3-17-offer-53-search-sort-array1/"/>
    <url>/2021/04/16/2021-3-17-offer-53-search-sort-array1/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: 0</p><p>限制：</p><p>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p></blockquote><h4 id="方法1：二分查找"><a href="#方法1：二分查找" class="headerlink" title="方法1：二分查找"></a>方法1：二分查找</h4><p>这道题最简单粗暴的方法就是从头遍历，当获取到值等于 target 的元素时开始累加次数，直到当前值不等于 target，但是这样做的话时间复杂度为 O(n)，此外像这种暴力法也显然不是一个合格的解决方案。</p><p>解决这道题的另一种方式是 <code>二分查找</code>，这道题属于二分查找的一个变种，常规的二分查找，在 nums[mid] &#x3D;&#x3D; target 时返回，但是这道题要求的是寻找出 target 出现的次数，所以区别就在于 nums[mid] &#x3D;&#x3D; target 时的处理。</p><p>整道题的思路可以是这样：先查找出 target 最后出现的位置，记为 leftIndex，再查找出 target 第一次出现的位置，记为 rightIndex，然后用 leftIndex - rightIndex + 1 即可求出出现的次数。</p><p>至于二分查找的特殊处理，可以将 [mid] &#x3D;&#x3D; target 时处理为 left &#x3D; mid + 1。</p><p>具体的流程如下图：</p><p><img src="https://zengh1.github.io/post-images/1618573278487.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    leftIndex := binarySearch(nums, target)<br>    rightIndex := binarySearch(nums, target<span class="hljs-number">-1</span>)<br><br>    <span class="hljs-keyword">return</span> leftIndex - rightIndex<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        m := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[m] &lt;= target &#123;<br>            l = m + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = m - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> l<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <link href="/2021/04/16/2021-3-23-offer-52-get-intersection-node/"/>
    <url>/2021/04/16/2021-3-23-offer-52-get-intersection-node/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>输入两个链表，找出它们的第一个公共节点。编写一个程序，找到两个单链表相交的起始节点。</p><pre><code class="hljs">如下面的两个链表：  a1 -&gt; a2 ↘                    c1 -&gt; c2 -&gt; c3    b1 -&gt; b2 -&gt; b3 ↗在节点 c1 开始相交。示例 1：         4 -&gt; 1 ↘                 8 -&gt; 4 -&gt; 5    5 -&gt; 0 -&gt; 1 ↗输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5],     skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。        从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。        在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2：2 -&gt; 6 -&gt; 41 -&gt; 5输入：intersectVal = 0, listA = [2,6,4], listB = [1,5],     skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p></blockquote><h2 id="方法1-双指针法"><a href="#方法1-双指针法" class="headerlink" title="方法1 双指针法"></a>方法1 双指针法</h2><p>具体的方法如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1618573213021.jpg"></p><p>对应代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 不需要边界检查</span><br>    <span class="hljs-comment">// if headA == nil || headB == nil &#123;</span><br>    <span class="hljs-comment">//     return nil</span><br>    <span class="hljs-comment">// &#125;</span><br>    hha, hhb := headA, headB<br>    <span class="hljs-comment">//pa, pb := headA, headB</span><br><br>    <span class="hljs-keyword">for</span> headA != headB &#123;<br>        <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> &#123;<br>            headA = hhb<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            headA = headA.Next<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> headB == <span class="hljs-literal">nil</span> &#123;<br>            headB = hha<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            headB = headB.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> headA<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-超出时间限制"><a href="#1-超出时间限制" class="headerlink" title="1.超出时间限制"></a>1.超出时间限制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    hha, hhb := headA, headB<br>    pa, pb := headA, headB<br><br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        pa = pa.Next<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = hhb<br>        &#125;<br><br>        pb = pb.Next<br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = hha<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">0</span><br>[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>分析：两个链表分别为 2 -&gt; 6 -&gt; 4 和 1 -&gt; 5，且没有交点，而上面代码的问题在于，当某个指针为 null 时，会继续跳转到另一个链表的头部，而不会停留。对应代码为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">pa = pa.Next<br><span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>    pa = hhb<br>&#125;<br></code></pre></td></tr></table></figure><p>对于两个不相交的链表而言，退出 while 的条件是两个指针都为 null，而上面的代码会导致指针永远不为 null， while 条件 pa !&#x3D; pb 永远不会成立，所以会进入死循环。</p><h3 id="2-其中一个链表为空"><a href="#2-其中一个链表为空" class="headerlink" title="2.其中一个链表为空"></a>2.其中一个链表为空</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    hha, hhb := headA, headB<br>    pa, pb := headA, headB<br><br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = hhb<br>        &#125;<br>        pa = pa.Next<br>        <br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = hha<br>        &#125;<br>        pb = pb.Next<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`    </span><br><span class="hljs-string"></span><br><span class="hljs-string">测试用例：</span><br></code></pre></td></tr></table></figure><p>0<br>[1,3]<br>[]<br>2<br>0</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>分析：解决之前的 `超出时间` 问题很简单，只要调换一下 pa == nil 和 pa = pa.<span class="hljs-keyword">Next</span> 的位置即可，现在指针会停留在 <span class="hljs-literal">null</span> 上了。<br><br>但又有了新的问题：如果两个链表有一个为空，如这里的测试用例 <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> 和 <span class="hljs-literal">null</span>，此时第一个指针移动到 <span class="hljs-number">3</span>，第二个链表的指针会直接移动到第一个链表的 <span class="hljs-number">1</span> 处，接着又会执行 pa = pa.<span class="hljs-keyword">Next</span> 移动到 <span class="hljs-number">3</span>，两个指针的节点相同，返回结果 <span class="hljs-number">3</span><br><br>这个结果明显是错误的，有一个空链表，怎么可能会有交点呢，错误的原因在于：pa = pa.<span class="hljs-keyword">Next</span> 这句话是一定会执行的，解决这个问题只需要为 pa = pa.<span class="hljs-keyword">Next</span> 加一个 <span class="hljs-keyword">else</span>，让 pa = hhb 和 pa = pa.<span class="hljs-keyword">Next</span> 只有一个能执行即可，更改后如下。<br><br>```go<br><span class="hljs-keyword">if</span> pa == nil &#123;<br>    pa = hhb<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    pa = pa.<span class="hljs-keyword">Next</span>  <br>&#125;<br>        <br></code></pre></td></tr></table></figure><p>起初还以为是边界判断的问题，为此加上了判断语句</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后来分析了以后才发现，这道题并不需要边界检查。</p><h2 id="一个特殊的测试用例"><a href="#一个特殊的测试用例" class="headerlink" title="一个特殊的测试用例"></a>一个特殊的测试用例</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">3</span><br><span class="hljs-string">[3]</span><br><span class="hljs-string">[2,3]</span><br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>两个链表分别为 3 和 2 -&gt; 3，在 3 处相交。</p><p>按照上面的步骤：<br>第 1 次<br>p1 &#x3D; 3.Next &#x3D; null （链表1）<br>p2 &#x3D; 2.Next &#x3D; 3    （链表2）</p><p>第 2 次<br>p1 &#x3D; 2              （链表2）<br>p2 &#x3D; 3.Next &#x3D; null  （链表2）</p><p>第 3 次<br>p1 &#x3D; 2.Next &#x3D; 3     （链表2）<br>p2 &#x3D; 3              （链表1）</p><p>此时虽然两个指针都为 3，但是并不是同一个节点，一个在链表1，一个在链表2，按照逻辑，如果继续往下执行，两个指针则都为 null，会返回错误结果 无交点。</p><p>但返回的却是正确结果 3，造成这一结果的原因，只可能是两个链表的 3 节点是相同的地址，为了验证这一猜想，打印一下两个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;h1:%p %v h2:%p %v\n&quot;</span>, <br>        headA, headA, headB, headB)<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// h1:0xc00008a320 &amp;&#123;3 &lt;nil&gt;&#125;   h2:0xc00008a340 &amp;&#123;2 0xc00008a320&#125;        </span><br></code></pre></td></tr></table></figure><p>果真如此，两个链表的 3 节点地址都为 0xc00008a320</p>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 15. 三数之和</title>
    <link href="/2021/04/16/2021-3-24-leet-15-three-sum/"/>
    <url>/2021/04/16/2021-3-24-leet-15-three-sum/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三<br>个元素 a，b，c ，使得 a + b + c &#x3D; 0<br>请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p> <br>示例 1：</p><p>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：nums &#x3D; [0]<br>输出：[] </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p></blockquote><h2 id="方法1：排序-双指针"><a href="#方法1：排序-双指针" class="headerlink" title="方法1：排序 + 双指针"></a>方法1：排序 + 双指针</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>大致流程：</p><ol><li>首先将数组按 <code>升序</code> 排序</li><li>准备三个指针 k、i、j</li><li>初始化，将 k 放置在第一个元素，i 放置在 k+1 处，j 放置在最后一个元素处</li><li>开始循环，条件为 k &lt; len(nums)-2</li><li>如果当前 <code>nums[k]</code> &gt; 0，则 break</li><li>如果 <code>nums[k-1]</code> 和 <code>nums[k]</code> 相同，则 continue 跳过本轮循环，达到去重的效果</li><li>固定 k（外层 for 循环） ，先移动 i 和 j （内层 for 循序），当 i &#x3D;&#x3D; j 时 break 掉内层 for 循环，让外层 for 循环 k 继续移动 </li><li>在移动 i 和 j 时计算 <code>nums[k] + nums[j] + nums[i]</code> 的值，记为 s<ol><li>如果 s &lt; 0，先判断是否重复，即 <code>for nums[i++] == nums[i] &#123;i++&#125;</code> 进行去重，然后再 <code>i++</code> 将指针 i 向后移动，<strong>这里一定要注意顺序，先去重，再移动指针 <code>i++</code>，原因后面会说明。</strong></li><li>如果 s &gt; 0，与上面类似，也是先判断是否重复，再执行 <code>j--</code></li><li>如果 s &#x3D;&#x3D; 0，记录当前的三个数字，之后移动 i 和 j 两个指针，将 i++，<code>j--</code>，和上面一样，也是先去重，再移动。</li></ol></li></ol><p>分析：</p><p>因为数组是排好序的，所以 k 指向的是最小元素，i 指向次小元素，j 指向最大元素（排除一些特殊情况比如 [0, 0, 0, 0]）</p><p>这里的 k 起的是固定作用，目的是枚举全部情况，当三个值的和小于 0 时，可以将 i++ 使和增大，同理当和大于 0 时，可以将 j– 将和减小，当和等于 0 时，说明此时已经搜集到了结果，可以将 k++ 进行下个数的枚举</p><p>第 5 步的原因是：因为 nums[j] &gt;&#x3D; nums[i] &gt;&#x3D; nums[k]，而当前 nums[k] &gt; 0，则代表 3 个数字都大于 0 ，必然不可能再找到结果了。</p><p>第 4 步的条件为 k &lt; len(nums)-2，原因是 i 和 j 都在 k 之后，当 k 在 len(nums)-2-1 处时，j 在最后一个，i 在倒数第二个，k，i，j 刚好对应最后三个数，所以可以作为最后一次判断。这只是一个优化，可以减少 2 次不必要的循环，k &lt; len(nums) 依然是正确的。</p><p>关于去重的条件 <code>i &lt; j &amp;&amp; nums[i] == nums[i+1]</code> 中需要首先判断 i &lt; j 的原因是防止越界，例如：</p><p>测试用例 [0, 0, 0]，k 在 [0]，i 在 [1]，j 在 [2]，sum &#x3D; 0，此时因为 nums[i] &#x3D;&#x3D; nums[i+1]，所以执行 i++ 到 [1]，还是重复，继续 i++ 到 [2]，如果没有 i &lt; j 的条件，这里会执行判断语句 nums[i] &#x3D;&#x3D; nums[i+1] 即 nums[2] &#x3D;&#x3D; nums[3]，而这个 nums[3] 就会导致越界致使程序错误，但加了 i &lt; j 会导致短路，使得后面的 nums[i] &#x3D;&#x3D; nums[i+1] 不执行。</p><p>对于 <code>i &lt; j &amp;&amp; nums[j] == nums[j-1]</code> 也是一样的道理，还是测试用例 [0, 0, 0]，如果没有 i &lt; j 的约束，则 j 会一直执行 j–，当 j 到达 0 时，[j-1] 就会发生数组越界问题。</p><p><strong>为什么在判断 sum 的分支中，都需要先去重，再移动指针呢？考虑如下情况：</strong></p><p>[ (k) -2, (i) 0, 1, 1, (j) 2]</p><p>此时 nums[k] + nums[i] + nums[j] &#x3D;&#x3D; 0，按照分支的流程，应该是先去重，再移动指针，那如果我反着来会发生什么情况呢？</p><p>如果先 i++，再去重，那么：</p><ol><li>i++，变为 &#x3D;&gt; [ (k) -2, 0, (i) 1, 1, (j) 2]</li><li>此时再去重，nums[i] &#x3D;&#x3D; nums[i+1]，导致 i 又要 +1，变为 [ (k) -2, 0, 1, (i) 1, (j) 2]，这将导致一种正确结果 [-2, 1, 1] 无法获得了</li></ol><p><strong>整个算法的流程如下图所示。</strong></p><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618573149147.png"></p><p>代码如下：</p><p>未优化版，是我根据上面思路写的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br>sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> nums[i] &lt; nums[j]<br>&#125;)<br><br>k := <span class="hljs-number">0</span><br>i, j := k+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> k &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span> &#123;<br>count++<br>s := <span class="hljs-number">0</span><br><span class="hljs-comment">// [-1, 0, 0]</span><br><span class="hljs-keyword">if</span> i &gt;= j &#123;<br>k++<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">if</span> nums[k] &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">//fmt.Println(k, i, j)</span><br>s = nums[k] + nums[i] + nums[j]<br><span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>j--<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br>i++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>r = <span class="hljs-built_in">append</span>(r, nums[k], nums[i], nums[j])<br>res = <span class="hljs-built_in">append</span>(res, r)<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>i++<br>j--<br><br>&#125;<br><br><span class="hljs-keyword">if</span> i &gt;= j &#123;<br><span class="hljs-keyword">for</span> k &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>] &#123;<br>k++<br>&#125;<br>k++<br>i, j = k+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>优化版，来自题解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum1</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> nums[i] &lt; nums[j]<br>&#125;)<br>res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; k++ &#123;<br>count++<br><span class="hljs-keyword">if</span> nums[k] &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>i, j := k+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br><br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>count++<br>sum := nums[i] + nums[j] + nums[k]<br><span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br>i++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>j--<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>r = <span class="hljs-built_in">append</span>(r, nums[k], nums[i], nums[j])<br>res = <span class="hljs-built_in">append</span>(res, r)<br><br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i++<br>&#125;<br>i++<br><span class="hljs-keyword">for</span> i &lt; j &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j--<br>&#125;<br>j--<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>经过测试，这两个函数的执行时间相差了三十倍！不知道为何性能差距会如此之大，可能是我写的冗余判断条件太多了，暂时也没有去仔细分析的想法，只能说明自己的逻辑能力还是菜的抠脚，还需要多多去练习才行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 56. 合并区间</title>
    <link href="/2021/04/16/2021-3-26-leet-56-merge-interval/"/>
    <url>/2021/04/16/2021-3-26-leet-56-merge-interval/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。<br>请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如何判断区间是否重叠，需要比较第二个数组的首元素是否小于前一个数组的尾元素，例如 [1,5],[2,6]，2 是小于 6 的，所以存在重叠，<br>而 [2,6],[8,10] 中，8 大于 6，所以区间不重叠。判断是否重叠并不难，难的在于合并。</p><p>考虑如下几种情况：</p><ol><li>重叠，两个数组的尾元素<code>相同</code>，例如：[[1,4],[0,4]] &#x3D;&gt; [0, 4]</li><li>重叠，第二个数组的尾元素<code>大于</code>第一个数组的尾元素：[[1,5],[2,6]] &#x3D;&gt; [1, 6]</li><li>重叠，第二个数组的尾元素<code>小于</code>第一个数组的尾元素：[[1,5],[2,4]] &#x3D;&gt; [1, 5]</li><li>重叠，第一个数组的首元素<code>大于</code>第二个数组的首元素：[[1,4],[0,1]] &#x3D;&gt; [1, 4]</li><li>重叠，第一个数组的首元素<code>小于</code>第二个数组的首元素：[[0,4],[1,2]] &#x3D;&gt; [1, 4]</li><li>比较特殊的，[[1,4],[0,0]] &#x3D;&gt; [[0,0],[1,4]]</li><li>等等其他情况</li></ol><p>可以看到情况有很多种，而我的第一想法也是粗暴的 if else，于是写出了下面的丑陋代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    res = <span class="hljs-built_in">append</span>(res, intervals[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment">// 上一个数组的下标</span><br>    prev := <span class="hljs-number">0</span><br>    <span class="hljs-comment">//start, end := intervals[0][0], intervals[0][1]</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>        <span class="hljs-comment">// 上一个数组的 [0] 和 [1]</span><br>        prevs, preve := intervals[prev][<span class="hljs-number">0</span>], intervals[prev][<span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 当前数组的 [0] 和 [1]</span><br>        curs, cure := intervals[i][<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> curs &lt;= preve &amp;&amp; cure &gt; preve &#123;  <span class="hljs-comment">// [[1,5],[2,6]]</span><br>            <span class="hljs-keyword">if</span> curs &lt; prevs &#123;   <span class="hljs-comment">// [[1,4],[0,5]]</span><br>                r := []<span class="hljs-type">int</span>&#123;curs, cure&#125;<br>                res[i<span class="hljs-number">-1</span>] = r<br>                prev = i - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r := []<span class="hljs-type">int</span>&#123;prevs, cure&#125;<br>                res[i<span class="hljs-number">-1</span>] = r<br>                prev = i - <span class="hljs-number">1</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> curs &lt;= preve &amp;&amp; cure &lt;= preve &#123; <span class="hljs-comment">// [[1,5],[2,4]]</span><br>            <span class="hljs-keyword">if</span> curs &lt; prevs   &#123;   <span class="hljs-comment">// [[1,4],[0,4]]  [[1,4],[0,1]]</span><br>                r := []<span class="hljs-type">int</span>&#123;curs, preve&#125;<br>                res[i<span class="hljs-number">-1</span>] = r<br>                prev = i - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cure &lt; prevs &#123;    <span class="hljs-comment">// [[1,4],[0,0]]</span><br>                res = <span class="hljs-built_in">append</span>(res, intervals[i])<br>                swap(res, i, prev)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>        &#125;  <span class="hljs-keyword">else</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, intervals[i])<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(nums [][]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>这是在提交失败了 n 次的基础上不断修改的，每个 if 分支都标明了对应的情况，但是，还是遇到了一种特殊的测试用例：[[1,4],[0,0]]，我的代码运行的结果是 [0,4]，但是正确答案是 [[0,0],[1,4]]，为了对付这种情况，我又写了一个 swap 函数来应对。考虑的情况越来越多，代码也越来越丑，最关键的是，提交还始终无法通过。无奈只能看题解了，</p><h2 id="方法-排序-双指针"><a href="#方法-排序-双指针" class="headerlink" title="方法 排序 + 双指针"></a>方法 排序 + 双指针</h2><p>这个排序我是万万没想到的，根据数组的左元素进行排序，这样一来，就可以完美处理 [[1,4],[0,0]] 这种情况了。</p><p>这里直接贴上来自题解中的代码，非常直观易懂且简洁，巧妙的使用了 max 函数来合并区间，比我傻傻的写的一堆 if else 优雅多了。<br>（来自 <a href="https://leetcode-cn.com/problems/merge-intervals/solution/shou-hua-tu-jie-56he-bing-qu-jian-by-xiao_ben_zhu/%EF%BC%89">https://leetcode-cn.com/problems/merge-intervals/solution/shou-hua-tu-jie-56he-bing-qu-jian-by-xiao_ben_zhu/）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>&#125;)<br>res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>prev := intervals[<span class="hljs-number">0</span>]<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>cur := intervals[i]<br><span class="hljs-keyword">if</span> prev[<span class="hljs-number">1</span>] &lt; cur[<span class="hljs-number">0</span>] &#123; <span class="hljs-comment">// 没有一点重合</span><br>res = <span class="hljs-built_in">append</span>(res, prev)<br>prev = cur<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有重合</span><br>prev[<span class="hljs-number">1</span>] = max(prev[<span class="hljs-number">1</span>], cur[<span class="hljs-number">1</span>])<br>&#125;<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, prev)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123; <span class="hljs-keyword">return</span> a &#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用 prev 来保存上一个数组，初始保存的是第 0 个，然后 for 从 1 开始，即用第 1 个和第 0 个进行比较，如果没有重合，则 append 并更新 prev 为当前数组，有重合，则对 prev 进行合并，因为已经排好序了，所以前一个的 [0] 是一定小于后一个的 [0]，只需要比较 前一个的[1] 和后一个的 [1] 即可，这里用了 max 函数来比较。</p><p>特别注意一下最后的 <code>res = append(res, prev)</code> ，没有这句话会导致错误。</p><p>原因：for 是从第二个数组开始判断的，并不断与前一个数组比较，如果不在 for 外面再定义一次 <code>res = append(res, prev)</code>，则会导致结果缺失的情况。</p><p>例如：[[1,3]]，此时都不会进入 for ，如果没有末尾的这句话，会直接导致结果为空。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求二叉树根节点到指定节点的路径</title>
    <link href="/2021/04/16/2021-3-27-find-binaryTree-root-to-node-path/"/>
    <url>/2021/04/16/2021-3-27-find-binaryTree-root-to-node-path/</url>
    
    <content type="html"><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这不是一道力扣或者剑指上的原题，但却是二叉树问题的一个基础核心算法，适用于许多二叉树类型的题目，比如 <code>剑指 Offer 68 - II. 二叉树的最近公共祖先</code>，因为这里有必要记录一下，大致的说明如下：</p><p>例如如下一颗二叉树：</p><p><img src="https://autsu.github.io/post-images/1618572928978.png"></p><p>当指定节点为 4 时，输出 [3,5,2,4]</p><h2 id="方法1-回溯，有返回值"><a href="#方法1-回溯，有返回值" class="headerlink" title="方法1 回溯，有返回值"></a>方法1 回溯，有返回值</h2><p>代码如下，<a href="https://blog.csdn.net/shizheng_li/article/details/104675990">参考</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 找到根节点到某一节点的路径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(node, need *TreeNode, // node: 当前节点，need: 指定节点</span></span><br><span class="hljs-params"><span class="hljs-function">              path, res *[]*TreeNode, // path: 记录当前路径 res: 保存结果路径</span></span><br><span class="hljs-params"><span class="hljs-function">              flag *<span class="hljs-type">bool</span>)</span></span> []*TreeNode &#123;<span class="hljs-comment">// flag: 用来标识是否已经找到结果，作为递归终止的条件</span><br><br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> || *flag &#123;<br>        <span class="hljs-keyword">return</span> *res<br>    &#125;<br>    *path = <span class="hljs-built_in">append</span>(*path, node)<br><span class="hljs-comment">// 找到指定的节点了，将 flag 更改为 true，同时将当前路径添加到 res 作为结果</span><br>    <span class="hljs-keyword">if</span> node == need &#123;<br>        *flag = <span class="hljs-literal">true</span><br>        *res = *path<br>    &#125;<br><span class="hljs-comment">// 先找左子树，再找右子树</span><br>    findPath(node.Left, need, path, res, flag)<br>    findPath(node.Right, need, path, res, flag)<br><span class="hljs-comment">// 回溯，在 path 中移除当前节点</span><br>    *path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br><br>    rr := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-built_in">len</span>(*res))<br>    <span class="hljs-comment">// 因为 slice 共用一个底层数组，第二次会更改第一次的结果，</span><br>    <span class="hljs-comment">// 所以需要 copy 一个新 slice</span><br>    <span class="hljs-built_in">copy</span>(rr, *res)  <br>    <br>    <span class="hljs-keyword">return</span> rr<br>&#125;<br></code></pre></td></tr></table></figure><p>path 和 res 都需要为指针切片，因为 append 会导致地址变更，flag 为了保证递归参数传递的状态一致，也需要为指针类型，其他的都写在注释中了，特别需要说明的是最后的 <code>copy</code>，这也是我踩的一个坑，特此记录一下：</p><p>引用 <code>算法</code> 中的二叉树，求 1 和 4 两个节点的路径，正确结果应该为 [3,1] 和 [3,5,2,4]但是最后运行的结果却是 [3,5] 和 [3,5,2,4]，测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// p = 1</span><br>pr := findPath(root, p, &amp;path, &amp;res, &amp;flag)<br>flag = <span class="hljs-literal">false</span><br><span class="hljs-comment">// p = 4</span><br>qr := findPath(root, q, &amp;path, &amp;res, &amp;flag)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(pr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, pr[i]) <span class="hljs-comment">// Output: [3, 5]</span><br>&#125;<br>fmt.Println()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(qr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, qr[i]) <span class="hljs-comment">// Output: [3,5,2,4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我又尝试将 pr 的输出语句移动至 qr 前，结果是正确的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// p = 1</span><br>pr := findPath(root, p, &amp;path, &amp;res, &amp;flag)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(pr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, pr[i]) <span class="hljs-comment">// Output: [3, 1]</span><br>&#125;<br>fmt.Println()<br><br>flag = <span class="hljs-literal">false</span><br><span class="hljs-comment">// p = 4</span><br>qr := findPath(root, q, &amp;path, &amp;res, &amp;flag)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(qr); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, qr[i]) <span class="hljs-comment">// Output: [3,5,2,4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因是因为我刚开始在函数中返回的是 *res，而 *res &#x3D; *path ，即让 res 的底层数组指针指向了 path 的底层数组， 传入的 path 都是同一个，这样第二次寻找路径时，path 会改变，这会使得指向 path 的 res 也跟着改变，所以第二次运行时会将 res 的 [1] 改为 [5]，解决方法就是新定义一个 slice，并 copy，再返回这个新 slice 即可。</p><p>此外，flag 参数也不需要传递指针类型，只要 bool 即可。</p><h2 id="方法2-回溯，无返回值"><a href="#方法2-回溯，无返回值" class="headerlink" title="方法2 回溯，无返回值"></a>方法2 回溯，无返回值</h2><p>方法 1 中的返回值其实完全是多余的，参数 res 已经保存了结果，完全可以不需要返回值，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root, need *TreeNode, path, res *[]*TreeNode, flag *<span class="hljs-type">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || *flag &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>*path = <span class="hljs-built_in">append</span>(*path, root)<br><span class="hljs-keyword">if</span> root == need &#123;<br>*flag = <span class="hljs-literal">true</span><br><span class="hljs-comment">// copy 一个新切片，防止多个 res 指向同一个 path</span><br>news := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-built_in">len</span>(*path))<br><span class="hljs-built_in">copy</span>(news, *path)<br>*res = news<br><span class="hljs-keyword">return</span><br>&#125;<br><br>findPath(root.Left, need, path, res, flag)<br>findPath(root.Right, need, path, res, flag)<br><br>*path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> path, pp, qq []*TreeNode<br><span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span><br>findPath(root, p, &amp;path, &amp;pp, &amp;flag)<br><span class="hljs-comment">// 重置参数</span><br>flag = <span class="hljs-literal">false</span><br>path = path[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br>findPath(root, q, &amp;path, &amp;qq, &amp;flag)<br><span class="hljs-comment">// 此时 pp 和 qq 已经保存了结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有无返回值的性能差异"><a href="#有无返回值的性能差异" class="headerlink" title="有无返回值的性能差异"></a>有无返回值的性能差异</h2><p>在 <code>剑指 Offer 68 - II. 二叉树的最近公共祖先</code> 这道题中，有一个非常长的测试用例（可能有上万个节点），这里使用有返回值的方法会超时，即使返回指针也一样超时，而无返回值则正常，可能是因为返回值需要拷贝的缘故，而且方法 1 的返回值本身就是一个冗余的东西，既然都已经提供了 res 参数用来保存结果，就不需要再返回了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>算法</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode165.比较版本号</title>
    <link href="/2021/04/16/2021-3-5-leet-165-compare-version-numbers/"/>
    <url>/2021/04/16/2021-3-5-leet-165-compare-version-numbers/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><p>示例 1：</p><p>输入：version1 &#x3D; “1.01”, version2 &#x3D; “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br>示例 2：</p><p>输入：version1 &#x3D; “1.0”, version2 &#x3D; “1.0.0”<br>输出：0<br>解释：version1 没有指定下标为 2 的修订号，即视为 “0”<br>示例 3：</p><p>输入：version1 &#x3D; “0.1”, version2 &#x3D; “1.1”<br>输出：-1<br>解释：version1 中下标为 0 的修订号是 “0”，version2 中下标为 0 的修订号是 “1” 。0 &lt; 1，所以 version1 &lt; version2<br>示例 4：</p><p>输入：version1 &#x3D; “1.0.1”, version2 &#x3D; “1”<br>输出：1<br>示例 5：</p><p>输入：version1 &#x3D; “7.5.2.4”, version2 &#x3D; “7.5.3”<br>输出：-1</p><p>提示：</p><p>1 &lt;&#x3D; version1.length, version2.length &lt;&#x3D; 500<br>version1 和 version2 仅包含数字和 ‘.’<br>version1 和 version2 都是 有效版本号<br>version1 和 version2 的所有修订号都可以存储在 32 位整数 中</p></blockquote><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="1-切割比较"><a href="#1-切割比较" class="headerlink" title="1.切割比较"></a>1.切割比较</h3><p>思路：使用 strings.split() 函数，按 <code>.</code> 切割，再使用 atoi() 将切割好的字符转换为整形，并一一比较。</p><p>上面的问题：如果两个版本号长度不同，例如 1.0 和 1.0.0，切割出的数组分别为 [1, 0] 和 [1, 0, 0]，按下标逐一比较，会有一个出现越界异常</p><p>解决方法：对较短的数组进行扩充，使二者长度相同，扩充元素为 0，因为 0 不会对结果产生影响，例如上面的例子，可以将 1 扩充为 [1, 0, 0]，这样就可以安全比较了。</p><p><img src="https://zengh1.github.io/post-images/1618572799885.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    v1arr := strings.Split(version1, <span class="hljs-string">&quot;.&quot;</span>)<br>    v2arr := strings.Split(version2, <span class="hljs-string">&quot;.&quot;</span>)<br>    <br>  <span class="hljs-comment">// 为较短数组填充 0，使两个数组的长度相同</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v1arr) &gt; <span class="hljs-built_in">len</span>(v2arr) &#123;<br>        sub := <span class="hljs-built_in">len</span>(v1arr) - <span class="hljs-built_in">len</span>(v2arr)<br>        <span class="hljs-keyword">for</span> sub &gt; <span class="hljs-number">0</span> &#123;<br>            v2arr = <span class="hljs-built_in">append</span>(v2arr, <span class="hljs-string">&quot;0&quot;</span>)<br>            sub--<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(v1arr) &lt; <span class="hljs-built_in">len</span>(v2arr) &#123;<br>        sub := <span class="hljs-built_in">len</span>(v2arr) - <span class="hljs-built_in">len</span>(v1arr)<br>        <span class="hljs-keyword">for</span> sub &gt; <span class="hljs-number">0</span> &#123;<br>            v1arr = <span class="hljs-built_in">append</span>(v1arr, <span class="hljs-string">&quot;0&quot;</span>)<br>            sub--<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(v1arr); i++ &#123;<br>        <span class="hljs-comment">// 转换为整形比较，无需担心 001 这样的字符串，atoi() 会智能的将其转换为 1</span><br>        v1i, _ := strconv.Atoi(v1arr[i])<br>        v2i, _ := strconv.Atoi(v2arr[i])<br>        <span class="hljs-keyword">if</span> v1i &gt; v2i &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1i &lt; v2i &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2.双指针"></a>2.双指针</h3><p>第一种方法比较直观易懂，但是需要额外的空间，还需要多次遍历，效率不是很高，而双指针法可以解决上述的问题。</p><p>思路：准备两个指针，分别置于两个版本号的开头，之后不断移动两个指针，直到都到达末尾。在移动的过程中，初始化两个变量 v1，v2 用于保存当前小版本号的值，如何获取小版本号的值呢？只需要使用 while 循环不断移动指针，当指针值为 <code>.</code> 时停止，每次循环都将 v1 &#x3D; v1 + 指针值 - ‘0’，</p><p><img src="https://zengh1.github.io/post-images/1618572818859.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l1, l2 := <span class="hljs-built_in">len</span>(version1), <span class="hljs-built_in">len</span>(version2)<br>    p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>  <span class="hljs-comment">// 获取最大值 </span><br>    <span class="hljs-keyword">var</span> maxFunc = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> x &gt; y &#123;<br>            <span class="hljs-keyword">return</span> x<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> y<br>        &#125;<br>    &#125;<br><br>    max := maxFunc(l1, l2)<br>    <span class="hljs-keyword">for</span> p1 &lt; max || p2 &lt; max &#123;<br>        <span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br>      <span class="hljs-comment">// 使用 while 来循环读取一个小版本号（例如 1.111 中的 1 和 111 就是小版本号），</span><br> <span class="hljs-comment">// 遇到 . 停止，此时 vv1, vv2 的值即是小版本号，vv1 和 vv2 定义在外层 for 内，</span><br>        <span class="hljs-comment">// 每次比较后都会清零</span><br>        <span class="hljs-keyword">for</span> p1 &lt; l1 &amp;&amp; version1[p1] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v1 = v1*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(version1[p1]) - <span class="hljs-string">&#x27;0&#x27;</span><br>            p1++<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> p2 &lt; l2 &amp;&amp; version2[p2] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v2 = v2*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(version2[p2]) - <span class="hljs-string">&#x27;0&#x27;</span><br>            p2++<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> v1 &gt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1 &lt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        p1++<br>        p2++<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h2><h3 id="1-超出时间限制"><a href="#1-超出时间限制" class="headerlink" title="1. 超出时间限制"></a>1. 超出时间限制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) || p2 &lt; <span class="hljs-built_in">len</span>(version2) &#123;<br>        v1, v2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) &amp;&amp; version1[p1] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version1[p1]))<br>            v1 += v<br>            p1++<br>        &#125;<br>        <span class="hljs-keyword">for</span> p2 &lt; <span class="hljs-built_in">len</span>(version2) &amp;&amp; version1[p2] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version1[p2]))<br>            v2 += v<br>            p2++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> v1 &gt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1 &lt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里超时的原因是末尾没有 p1++ 和 p2++，当 p1 和 p2 都为 ‘.’ 时，p1 和 p2 将不会有任何改变，这会导致 while 条件一直满足，从而陷入死循环。</p><p>所以末尾的 p1++ 和 p2++ 就是用来保证当 p1，p2 都为 ‘.’ 时仍然会移动，防止死循环的发生。</p><h3 id="2-解答错误"><a href="#2-解答错误" class="headerlink" title="2. 解答错误"></a>2. 解答错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    p1, p2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) || p2 &lt; <span class="hljs-built_in">len</span>(version2) &#123;<br>        v1, v2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> p1 &lt; <span class="hljs-built_in">len</span>(version1) &amp;&amp; version1[p1] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version1[p1]))<br>            v1 += v<br>            p1++<br>        &#125;<br>        <span class="hljs-keyword">for</span> p2 &lt; <span class="hljs-built_in">len</span>(version2) &amp;&amp; version2[p2] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>            v, _ := strconv.Atoi(<span class="hljs-type">string</span>(version2[p2]))<br>            v2 += v<br>            p2++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> v1 &gt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> v1 &lt; v2 &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        p1++<br>        p2++<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;1.1&quot;</span><br><span class="hljs-string">&quot;1.10&quot;</span><br></code></pre></td></tr></table></figure><p>这里错误的原因是因为对于小版本号只是单纯的相加操作，对于 1.10 的第二个小版本而言，结果为 1 + 0 &#x3D; 1，从而导致错误结果 1.1 &#x3D; 1.10，解决方法是将对应小版本号从 string 转为 int，具体方法是 v &#x3D; v*10 + s[i] - ‘0’。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="/2021/04/16/2021-3-6-offer-11-retate-array-min-num/"/>
    <url>/2021/04/16/2021-3-6-offer-11-retate-array-min-num/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p></blockquote><p>图片来源：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></p><p><img src="https://zengh1.github.io/post-images/1618572544771.png"></p><p>从上图可以看出来，所谓的旋转数组，实质上是变成了两个有序数组，且左边的有序数组要大于右边的有序数组，所以右边的有序数组的第一个值，就是整个数组中的最小值。</p><p>二分查找，是通过每次缩短查找区间来减少查找的次数，但前提是数组必须是有序的，而旋转数组恰好破坏了数组的有序性，但这并不代表旋转数组就不能使用二分查找来解决问题了。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>还是和常规的二分查找一样，先创建两个指针（left 和 right），分别置于数组的第一个数（left）和最后一个数（right），并相加除以二求出中位</li><li>接下来判断中位属于哪个有序数组，是左边的还是右边的，具体的判断方法后面会提到</li><li>在确定了属于哪个有序数组后，就可以像普通的二分查找一样，去掉一部分的查找区间了，如何去除，后面会提到</li><li>不断更新指针，直到两个指针在同一位置</li></ol><p>1.如何判断中位属于左边还是右边？</p><p>如果中位值 <strong>大于</strong> right 的值，说明在左边数组<br>如果中位值 <strong>小于</strong> right 的值，说明在右边数组</p><p>例如：<br>[4, 5, 1, 2, 3]，中位值为 1，小于 right 3，所以在右边数组<br>[3, 4, 5, 1, 2]，中位值为 5，大于 right 2，所以在左边数组</p><p>2.在确定了中位所属数组后，如何缩短查找空间？</p><p>因为左数组要大于右数组，所以：</p><p><del>如果中位在右数组，那么可以直接去掉左数组，例如 [4, 5, <strong>1</strong>, 2, 3]，左数组 [4, 5] 是要大于右数组 [1, 2, 3] 的，所以可以直接去掉 4, 5 这两个元素，但其本身有可能是最小元素，所以不能去除。</del></p><p>如果中位在左数组，那么可以去掉其左边的所有元素以及它自己，因为左数组是要大于右数组的，例如 [3, 4, <strong>5</strong>, 1, 2]，可以直接将 3，4，5全部去掉  </p><p>如果中位在右数组，那么可以去掉其右边的所有元素，因为这些元素是一定比它大的，例如 [5, 1, <strong>2</strong>, 3, 4]，中位所处数组为 [1, 2, 3, 4]，它右边的 3 和 4 可以直接去除掉。</p><p>一种特殊情况：<br>[1, 0, <strong>1</strong>, 1, 1]，中位的值和 right 值相等，这时该如何处理呢？参照力扣的题解说法：遇到 <code>nums[mid] == nums[right]</code> 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 <code>right</code> 舍弃掉，并不影响结果。</p><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>图片来源：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/</a></p><p><img src="https://zengh1.github.io/post-images/1618572639234.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572646946.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572651504.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572659962.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572665167.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572675768.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572683253.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572690139.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572697498.jpg"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minArray</span><span class="hljs-params">(numbers []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers)<span class="hljs-number">-1</span><br><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid := (left + right) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 在第一个数组</span><br>        <span class="hljs-keyword">if</span> numbers[mid] &gt; numbers[right] &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> numbers[mid] &lt; numbers[right] &#123;   <span class="hljs-comment">// 在第二个</span><br>            right = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers[left]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误记录-x2F-思考"><a href="#错误记录-x2F-思考" class="headerlink" title="错误记录&#x2F;思考"></a>错误记录&#x2F;思考</h2><p>为什么判断是否在第一个数组，必须用 mid 和 right 比较，而不能和 left 比较？比如 [3, 4, 5, 1, 2]，可以通过 mid &gt; right 得到在第一个数组，但同样也可以用 mid &gt; left 判断出同样的结果。</p><p>首先可以确定的是，mid 和 left 比较会出错，比如这个测试用例 [1, 1, 0, 1, 1]，两种比较方式结果如下图：</p><p><img src="https://zengh1.github.io/post-images/1618572745215.png"></p><p>对于这样一种特殊旋转数组 [1, 2, 3, 4, 5] （即旋转了 0 个数），此时 mid 无法确定属于哪个数组，且也不符合之前的<strong>左数组大于右数组</strong>的条件，这种情况下，与 right 比较是安全的，这会将其分配到右数组 [3, 4, 5]，并将搜索区间转移到左部分 [1, 2, 3]。</p><p>如果与 left 比较，会错误的分配到右数组 [1, 2, 3]，并将这部分从搜索区间中去除，留下 [4, 5]，结果也显然意见是错误的。</p><p>综上，要避免与 left 比较。</p>]]></content>
    
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
    <link href="/2021/04/16/2021-4-3-offer-68-lowest-common-ancestor/"/>
    <url>/2021/04/16/2021-4-3-offer-68-lowest-common-ancestor/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点<br>p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖<br>先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:<br>root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572470707.png"></p><p>示例 1:</p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4],<br>p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p>示例 2:</p><p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4],<br>p &#x3D; 5, q &#x3D; 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定<br>义最近公共祖先节点可以为节点本身。</p></blockquote><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="方法1-递归"><a href="#方法1-递归" class="headerlink" title="方法1. 递归"></a>方法1. 递归</h3><p>这次不多 bb 直接上代码：</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root == p || root == q &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-comment">// 记录左子树部分是否有 p 或 q，如果有，则 left 的值为 p 或 q 的某</span><br>    <span class="hljs-comment">// 一父节点（也有可能是 p 或 q本身），如果没有则为 null</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    <span class="hljs-comment">// 记录右子树部分是否有 p 或 q，如果有，则 left 的值为 p 或 q 的某</span><br>    <span class="hljs-comment">// 一父节点（也有可能是 p 或 q本身），如果没有则为 null</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br><br>    <span class="hljs-comment">// left 为空，说明左子树部分没有 p，q，返回 right，即在右子树部分</span><br>    <span class="hljs-comment">// 找到的结果</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    <span class="hljs-comment">// 同理如上    </span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>    <span class="hljs-comment">// left 和 right 都不为空，说明 p，q 在异侧，此时当前节点 root </span><br>    <span class="hljs-comment">// 就是它们的公共父节点</span><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h4><h5 id="递归流程图"><a href="#递归流程图" class="headerlink" title="递归流程图"></a>递归流程图</h5><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572490386.png"></p><h5 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h5><p><img src="https://raw.githubusercontent.com/autsu/diagrams/master/img/1618572503501.png"></p><p>（勘误：p&#x3D;7，q&#x3D;4 这一步的图片流程的第 2 步，应该是：说明该节点在其右子树，图片中错误的写成了：说明该节点在其左子树，这里懒得再修改图片了，直接文字说明）</p><h5 id="文字分析"><a href="#文字分析" class="headerlink" title="文字分析"></a>文字分析</h5><p>递归解析：</p><ol><li>终止条件：<ol><li>当越过叶节点，则直接返回 null；</li><li>当 root 等于 p, q，则直接返回 root；</li></ol></li><li>递推工作：<ol><li>开启递归左子节点，返回值记为 left；</li><li>开启递归右子节点，返回值记为 right；</li></ol></li><li>返回值： 根据 left 和 right ，可展开为四种情况；<ol><li>当 left 和 right 同时为空 ：说明 root 的左 &#x2F; 右子树中都不包含 p,q ，返回 null；</li><li>当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 &#x2F; 右子树），因此 root 为最近公共祖先，返回 root；</li><li>当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：<ol><li>p,q 其中一个在 root 的 右子树 中，此时 right 指向 pp（假设为 pp ）；</li><li>p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；</li></ol></li></ol></li><li>当 left 不为空 ， right 为空 ：与情况 3. 同理；</li></ol><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/">参考</a></p><p>递归在向上<code>归</code>时，会不断根据当前条件，更新返回的信息（参考递归过程图）</p><h3 id="方法2-搜索根节点到-p，q-的路径，再求两条路径的最后一个相同节点"><a href="#方法2-搜索根节点到-p，q-的路径，再求两条路径的最后一个相同节点" class="headerlink" title="方法2. 搜索根节点到 p，q 的路径，再求两条路径的最后一个相同节点"></a>方法2. 搜索根节点到 p，q 的路径，再求两条路径的最后一个相同节点</h3><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go">    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">var</span> path, pp, qq []*TreeNode<br>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">bool</span><br>    findPath(root, p, &amp;path, &amp;pp, &amp;flag)<br>    <br>    flag = <span class="hljs-literal">false</span><br>    path = path[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br>    findPath(root, q, &amp;path, &amp;qq, &amp;flag)<br><br>    size := min(<span class="hljs-built_in">len</span>(pp), <span class="hljs-built_in">len</span>(qq))<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; i &lt; size; i++ &#123;<br>        <span class="hljs-keyword">if</span> pp[i] == qq[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pp[i<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPath</span><span class="hljs-params">(root, need *TreeNode, path, res *[]*TreeNode,</span></span><br><span class="hljs-params"><span class="hljs-function">              flag *<span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || *flag &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125; <br>    *path = <span class="hljs-built_in">append</span>(*path, root)<br>    <span class="hljs-keyword">if</span> root == need &#123;<br>        *flag = <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//*res = *path</span><br>        <span class="hljs-comment">//fmt.Println(res)</span><br>        news := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-built_in">len</span>(*path))<br>        <span class="hljs-built_in">copy</span>(news, *path)<br>        <span class="hljs-comment">//fmt.Println(news)</span><br>        *res = news<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <br>    findPath(root.Left, need, path, res, flag)<br>    findPath(root.Right, need, path, res, flag)<br><br>    *path = (*path)[:<span class="hljs-built_in">len</span>(*path)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的思路已经写在标题里了，分析可以参考文章 <a href="https://autsu.github.io/post/2021-3-27-find-binaryTree-root-to-node-path/">求二叉树根节点到指定节点的路径</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 46.全排列【未完】</title>
    <link href="/2021/04/16/2021-4-6-leet-46-quan-pai-lie/"/>
    <url>/2021/04/16/2021-4-6-leet-46-quan-pai-lie/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="方法1-回溯法，使用-bool-数组记录每个数是否被访问"><a href="#方法1-回溯法，使用-bool-数组记录每个数是否被访问" class="headerlink" title="方法1 回溯法，使用 bool 数组记录每个数是否被访问"></a>方法1 回溯法，使用 bool 数组记录每个数是否被访问</h3><p><img src="https://zengh1.github.io/post-images/1618572434875.png"></p><p><code>cpp 版本：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">bool</span>&gt; visit;<br>        <span class="hljs-comment">// error: load of null pointer of type &#x27;std::_Bit_type&#x27;</span><br>        <span class="hljs-comment">// need init bool vector</span><br>        visit.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>); <br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-built_in">backtrack</span>(nums, temp, visit, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, </span></span><br><span class="hljs-params"><span class="hljs-function">                   vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visit, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            temp.<span class="hljs-built_in">emplace_back</span>(nums[i]);<br>            visit[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtrack</span>(nums, temp, visit, res);<br>            visit[i] = <span class="hljs-literal">false</span>;<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>go 版本：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    temp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>    isvisited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(nums))<br>    BackTrack(isvisited, temp, nums, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BackTrack</span><span class="hljs-params">(isvisited []<span class="hljs-type">bool</span>, temp []<span class="hljs-type">int</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">               nums []<span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        newTemp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(temp))<br>        <span class="hljs-built_in">copy</span>(newTemp, temp)<br>        *res = <span class="hljs-built_in">append</span>(*res, newTemp)<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 这里可以直接 return 了，没必要再走下面的循环了</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> isvisited[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        temp = <span class="hljs-built_in">append</span>(temp, nums[i])<br>        isvisited[i] = <span class="hljs-literal">true</span><br>        BackTrack(isvisited, temp, nums, res)<br>        temp = temp[:<span class="hljs-built_in">len</span>(temp)<span class="hljs-number">-1</span>]<br>        isvisited[i] = <span class="hljs-literal">false</span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法2-回溯法，使用-swap"><a href="#方法2-回溯法，使用-swap" class="headerlink" title="方法2 回溯法，使用 swap"></a>方法2 回溯法，使用 swap</h3><p>swap 的方式相比方法 1 要简洁一些，也比较好理解，效率也高一些。</p><p>代码如下：</p><p><code>cpp 版本：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec, <span class="hljs-type">int</span> first, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (first == vec.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">emplace_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = first; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-built_in">swap</span>(vec.<span class="hljs-built_in">at</span>(i), vec.<span class="hljs-built_in">at</span>(first));<br>            <span class="hljs-built_in">backtrack</span>(vec, first+<span class="hljs-number">1</span>, res);<br>            <span class="hljs-built_in">swap</span>(vec.<span class="hljs-built_in">at</span>(i), vec.<span class="hljs-built_in">at</span>(first));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>go 版本：</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> res [][]<span class="hljs-type">int</span><br>    backtrack(nums, <span class="hljs-number">0</span>, &amp;res)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, first <span class="hljs-type">int</span>, res *[][]<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> first == <span class="hljs-built_in">len</span>(nums) &#123;<br>        news := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-built_in">copy</span>(news, nums)<br>        *res = <span class="hljs-built_in">append</span>(*res, news)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := first; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        swap(nums, first, i)<br>        backtrack(nums, first+<span class="hljs-number">1</span>, res)<br>        swap(nums, first, i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    nums[i], nums[j] = nums[j], nums[i]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>采用 go test benchmark，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// BenchmarkBool-8    2581156       437.1 ns/op</span><br><span class="hljs-comment">// BenchmarkSwap-8    1999869       573.2 ns/op</span><br><span class="hljs-comment">// BenchmarkSwap-8    2313684       440.1 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSwap</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>n := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>permute(n)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// BenchmarkBool-8     999951      1029 ns/op</span><br><span class="hljs-comment">// BenchmarkBool-8    1098356       963.6 ns/op</span><br><span class="hljs-comment">// BenchmarkBool-8    1248417       927.0 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkBool</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>n := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>permute1(n)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>回溯法</tag>
      
      <tag>全排列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode 225. 用队列实现栈【未完】</title>
    <link href="/2021/04/16/leetcode-225-yong-dui-lie-shi-xian-zhan-wei-wan/"/>
    <url>/2021/04/16/leetcode-225-yong-dui-lie-shi-xian-zhan-wei-wan/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 </p><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 </p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False </p><p>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空 </p><p>进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。</p><h2 id="方法1-一个队列实现"><a href="#方法1-一个队列实现" class="headerlink" title="方法1 一个队列实现"></a>方法1 一个队列实现</h2><p>具体思路：<br>push 时，先将元素正常 push 到队尾，再将之前的所有元素执行 <strong>1.出队</strong>、<strong>2.入队</strong> 操作</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    Queue *list.List<br>&#125;<br><br><br><span class="hljs-comment">/** Initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyStack &#123;<br>    <span class="hljs-keyword">return</span> MyStack&#123;<br>        Queue: list.New(),<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Push element x onto stack. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>)  &#123;<br>    q := this.Queue<br>    _len := q.Len()<br>    q.PushBack(x)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; _len; i++ &#123;<br>        q.PushBack(q.Remove(q.Front()) )<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.Queue.Remove(this.Queue.Front()).(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">/** Get the top element. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.Queue.Front().Value.(<span class="hljs-type">int</span>)<br>&#125;<br><br><br><span class="hljs-comment">/** Returns whether the stack is empty. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> this.Queue.Len() == <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(x);</span><br><span class="hljs-comment"> * param_2 := obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.Empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/2021/04/16/jian-zhi-offer-04-er-wei-shu-zu-zhong-de-cha-zhao/"/>
    <url>/2021/04/16/jian-zhi-offer-04-er-wei-shu-zu-zhong-de-cha-zhao/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例：</strong></p><p>现有矩阵 matrix 如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,   4,  7, 11, 15]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,   5,  8, 12, 19]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,   6,  9, 16, 22]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[10, 13, 14, 17, 24]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[18, 21, 23, 26, 30]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= n &lt;= <span class="hljs-number">1000</span><br><span class="hljs-symbol">0 </span>&lt;= m &lt;= <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为矩阵是从上往下、从左往右递增的，所以可以选择左下角或者右上角为起始点：</p><p><img src="https://zengh1.github.io/post-images/1618571896492.png"></p><p>算法流程：</p><p>从起始点 m[a] [b]  开始判断，如果是 <strong>右上角</strong>，若当前值 <strong>大于</strong> target，则可以 b– 去掉 <strong>当前列</strong> ，若当前值 <strong>小于</strong>  target，可以 a++ 去掉 <strong>当前行</strong> ，左下角也类似</p><p>图解，这里借用一下别人的：</p><p>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/</a></p><p><img src="https://zengh1.github.io/post-images/1618571965271.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618571980921.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618571989060.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618571995996.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572003332.jpg"></p><p><img src="https://zengh1.github.io/post-images/1618572009814.jpg"></p><p>结合上面的图示，这道题的思路还是比较好理解的，但是代码并不好写，主要是 while 条件比较难把握，很容易出错，比如对于以下测试用例： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">// 越界<br><span class="hljs-string">[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]</span><br><span class="hljs-number">20</span><br><br>// 不执行 <span class="hljs-keyword">while</span>，直接返回 <span class="hljs-literal">false</span><br><span class="hljs-string">[[-5]]</span><br><span class="hljs-number">-5</span><br></code></pre></td></tr></table></figure><p>具体分析如下：</p><p><img src="https://zengh1.github.io/post-images/1618572038320.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>起始点在左下角：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    i, j := <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span><br><br>    <br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) &#123;<br>        flag = matrix[i][j]<br>        <span class="hljs-keyword">if</span> flag &gt; target &#123;<br>            i--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> flag &lt; target &#123;<br>            j++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>起始点在右上角：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">var</span> flag <span class="hljs-type">int</span><br><br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(matrix) &amp;&amp; j &gt;= <span class="hljs-number">0</span> &#123;<br>        flag = matrix[i][j]<br>        <span class="hljs-keyword">if</span> flag &gt; target &#123;<br>            j--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> flag &lt; target &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">//fmt.Printf(&quot;i -&gt; %d  j -&gt; %d\n&quot;, i, j)</span><br>        <span class="hljs-comment">//fmt.Println(&quot;flag: &quot;, flag)</span><br>        <span class="hljs-comment">//flag = matrix[i][j]</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>剑指offer</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <link href="/2021/04/16/jian-zhi-offer-48-zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan/"/>
    <url>/2021/04/16/jian-zhi-offer-48-zui-chang-bu-han-chong-fu-zi-fu-de-zi-zi-fu-chuan/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>         请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串<br></code></pre></td></tr></table></figure><p>提示：</p><p>s.length &lt;&#x3D; 40000</p></blockquote><h4 id="方法1：滑动窗口"><a href="#方法1：滑动窗口" class="headerlink" title="方法1：滑动窗口"></a>方法1：滑动窗口</h4><p>通过双指针 + 哈希表实现，算法思路如下：</p><ol><li>初始化两个指针 i 和 j，同时指向第一个字符</li><li>i 指针不动，j 指针不断前进，每次前进都更新其在 map 中的值（值是下标），同时计算最大窗口值</li><li>如果 j 在移动过程中遇到重复元素（在 map 中已存在），则将 i 移动到 max(i, map[重复元素]+1) 处，这里为什么要比较大小，后面会解释</li><li>当 j 大于字符串长度时，结束循环，返回最大窗口值</li></ol><p><img src="https://zengh1.github.io/post-images/1618559975600.png"></p><p>对应代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>i, j, maxl := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>cur := s[j]<br><span class="hljs-comment">// 当前字符重复</span><br><span class="hljs-keyword">if</span> _, ok := m[cur]; ok &#123;<br><span class="hljs-comment">// 移动 i 到重复元素下标+1 处，如果当前位置下标大于 m[cur]+1，则不移动</span><br>i = max(i, m[cur]+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 如果当前长度更大，则更新最大长度</span><br>maxl = max(maxl, j-i+<span class="hljs-number">1</span>)<br>m[cur] = j<br>j++<br>&#125;<br><span class="hljs-keyword">return</span> maxl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 执行用时: 8 ms</span><br><span class="hljs-comment">// 内存消耗: 3.1 MB</span><br><br></code></pre></td></tr></table></figure><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>当元素重复时，为什么 i 要移动到 max(i, m[cur]+1) 处，而不是直接移动到 m[cur]+1 处？</p><p>刚开始写的时候，我就犯了这个错误，写下了如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    maxl := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        char := s[j]<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            i = m[char] + <span class="hljs-number">1</span><br>        &#125; <br>      maxl = max(maxl, j-i)<br>        m[char] = j<br>        j++<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> maxl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：abba，正确结果应该是 2 ，但是上面代码执行却诡异的返回了 3，通过画图分析后才知道了原因所在：</p><p><img src="https://zengh1.github.io/post-images/1618560095136.png"></p><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>    maxl := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        char := s[j]<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            maxl = max(maxl, j-i)<br>            i = m[char] + <span class="hljs-number">1</span><br>        &#125; <br>        m[char] = j<br>        j++<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> maxl<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例：</p><p>au预期：2输出：0</p><p>原因：更新最大长度语句写在了 if 内，只有字符重复时才会执行，对于 au 这个没有重复字符的 string，该语言始终不会执行，所以最后会返回 0</p><p>“ “预期：1输出：0</p><p>原因：还是和上面一样的情况。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一次做这道题的时候是毫无头绪的，因为当时并不知道滑动窗口是什么东西，在看了题解后，照猫画虎，大致摸清了算法思路，但对于一些特殊语句，比如 if 中的 max(i, m[s[j]]+1)，却没有很好的理解，只是知道这句话不这样写，答案就不会正确。</p><p>这次二刷，则是先大致回想一下之前记忆里的思路，并尝试在不看原来正确代码的情况下，先自己写写，结果就发现了很多问题，一些测试用例无法通过，这时再结合之前的正确代码，比较自己写的代码的缺陷并改正，对于特殊语句也理解清楚了。</p><p>所以这道题给我的感悟就是，做题还是得自己动手实践才能真正理解，只是看别人的代码，很有可能会处于半知半解状态。算法题就是这样，往往你以为自己做对了，实际并没有，就是有几个刁钻的测试用例过不去，只要有 1 个测试过不去，就说明这个代码写的是有问题的，这个时候再结合错误仔细分析，查找发现有问题的地方，就能更好的理解代码。如果只是看别人的，少了发现并改正错误的过程，对代码的理解也会不够透彻，。</p><p>总的来说，在不会做的情况下可以看别人的题解，学习方法和思路，但不能只看不写，要试着将别人的思路转换成自己的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>剑指offer</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符（书中为35题）</title>
    <link href="/2021/04/16/jian-zhi-offer-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-shu-zhong-wei-35-ti/"/>
    <url>/2021/04/16/jian-zhi-offer-50-di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-shu-zhong-wei-35-ti/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例:</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abaccdeff&quot;</span><br>返回 <span class="hljs-string">&quot;b&quot;</span><br><br><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> <br>返回 <span class="hljs-string">&quot; &quot;</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="方法1：哈希表"><a href="#方法1：哈希表" class="headerlink" title="方法1：哈希表"></a>方法1：哈希表</h4><p>可以将哈希表的 key 定义为 char，用来存储 string 的每个字符；value 定义为 int ，用来记录字符出现的次数，或者定义为 bool，用来标识字符是否重复出现，因为 bool 的方式相对简单明了，也并不需要频繁对变量进行自增操作，所以这里选择 bool，false 代表未重复出现。</p><p>由于 go 的 map 是无序的，遍历出的第一个 value 为 false 的字符，在字符串中未必是第一个，所以只能通过二次遍历字符串，判断每个字符在 map 中对应的值，并返回第一个值为 false 的字符。 </p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            m[char] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        m[char] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> !m[char] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 48 ms</span><br><span class="hljs-comment">// 内存消耗: 5.3 MB</span><br></code></pre></td></tr></table></figure><h4 id="方法2：使用数组代替哈希表"><a href="#方法2：使用数组代替哈希表" class="headerlink" title="方法2：使用数组代替哈希表"></a>方法2：使用数组代替哈希表</h4><p>这是 《剑指offer》 中提供的方法，虽然哈希表可以很好地解决问题，但是对于一个只有小写字母的字符串来说（题目中说明了）来说，杀鸡焉用宰牛刀，可以用一个长度为 26 的数组，建立一个简单的哈希表即可，用字符的 ascii 减去 97 作为下标，值为出现的次数，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    n := [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        n[char<span class="hljs-number">-97</span>]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> n[char<span class="hljs-number">-97</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 8 ms</span><br><span class="hljs-comment">// 内存消耗: 5.3 MB</span><br></code></pre></td></tr></table></figure><p>执行用时只有原来的 1&#x2F;6，这个结果可能不是很准确，但是相对哈希表而言，少了哈希计算、处理哈希冲突等等操作，效率肯定要好一些的。通过这道题也使我明白了，不要无脑使用 map，在一些特殊条件下，往往会有更简单高效的解决方法。</p><h4 id="方法-3：-有序哈希表"><a href="#方法-3：-有序哈希表" class="headerlink" title="方法 3： 有序哈希表"></a>方法 3： 有序哈希表</h4><p>如果哈希表有序，则可以遍历哈希表，找到第一个值为 fasle 的字符，但 go 中没有提供有序 map，所以这里使用一个 slice 来按顺序保存 key ，之后遍历这个 slice 即可，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>    sli := <span class="hljs-built_in">make</span>([]<span class="hljs-type">rune</span>, <span class="hljs-number">0</span>)<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-comment">// map 中没有该 char，则 append 到 slice 中</span><br>        <span class="hljs-keyword">if</span> _, ok := m[char]; !ok &#123;<br>            sli = <span class="hljs-built_in">append</span>(sli, char)<br>        &#125;<br>        <span class="hljs-keyword">if</span> _, ok := m[char]; ok &#123;<br>            m[char] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        m[char] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 遍历 slice</span><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> sli &#123;<br>        <span class="hljs-keyword">if</span> m[char] == <span class="hljs-literal">false</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 48 ms</span><br><span class="hljs-comment">// 内存消耗: 5.3 MB</span><br></code></pre></td></tr></table></figure><p>不过该方法看起来并没有显著提高效率。</p><h4 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">byte</span> &#123;<br>  <span class="hljs-comment">// 这里错误的将 value 设置为 byte 类型，最大值只有 255，255 + 1 会被重置为 0</span><br>  <span class="hljs-comment">// 也就是说如果一个数出现了 257 次，则它的值会变为 1</span><br>    n := [<span class="hljs-number">26</span>]<span class="hljs-type">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        n[char<span class="hljs-number">-97</span>]++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> n[char<span class="hljs-number">-97</span>] == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">byte</span>(char)<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">32</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>例如下面这个刁钻的测试用例，它的正确结果应该是 “y”，但是上面的代码却返回了 “n”，原因就是 n 出现了 257 次，值变为了 1，而字符串中 n 又比 y 先出现，导致错误地返回了 n。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;uindrseqbljlhqvlwvgdebeihttirikuahlikgnahvgnptmqwbovmuwesxkvcitcwrwrucsbbfqvldridfviduqvmfcmeiphoqupbitnwdbvevouoaetisdmgvvvwoglwtgjrpcbghxkrkjthetxeexbphbjiehaicuicgnirslhdstgmqcdnlulpdpadjdltfouwhfqicfcqntnpeqaohslwkhbvflxaudembsrsindluthxapnmrqinsivbxmkohubvmmmpmklbfrmeuvdrhptdmelmjjefgbsqqlbqhvsmswwxrlkutadqbbeisbgfrcivvoxmxxptrscxnjjvtajfhqiucdihihcutxhlonlomfdnbwanrcnbarojsajseqrgkuqgkcnvrghxnmbclfomktwfaakodeecsglufvobkgoqsbrhdiuhxqbcndkmxuertupngvnkgwrfwgdbiurbooxariklwarjgavsuddoveipltessrssxwxgvrrtkisnbavkbpaphicxhapjjpkccakepuafjdaswfwfmbdmuuaveukxvnpkgmhcjcpqntssthjlvrngugbhrivtwmbrvrprrlfmvwjdkonfmgnepqoxwfcvefjihisarwskjfmqrjlkbbugfawmkqgfxgpokkxxivqbqimwsccdekjegwcxhmmuhpstxfpofwmrmhrxeptxwbvxsesheijjfsshgrrwckjkmbslpbngnwhokjnujtiepfrdhiwwgbffixaidabacaibummwxgxowsewlqfxrkarjrkqxmxwobqbcoowmbggtpoqadhqdxlhvxrkfuwpxxgnchudreoeuefkqhlrmwwfvjexvbxdhtdngwvoohpjtdbdbesceiafrhenfljleegsencfmbauxlltfueudnjxsiiggsfwiuidgktsbtcvxtdllviocfdbonjciosucbjidwxnogmnveqkcrxbpamfxwxiugjgrfpstromuxxdiodqeoqdlfulttraquskhwfholbrcbchijlgqvuwxvejedikvgetlmrcmeampdgjvmbdovkcjilbralhmniwvbeandldnudkpjvhoqtfdwllridwljfvflfdrbqadvabggwsiexrthrngexpebuhtefkqgkkjoopsmunesfotsprxuaswwenhkdvsspkppulecahkkvccqngeaoijjgvsfqfpvphvhdnkkcqsebhijkvfpqjmarbkpejagtbtisnflrrvawmvfxeccxtrmorihgslxlqrqcmouojjfhcieuwlrcqhevmveookgonxqdbtgqjimsidnaaiuchwkfkpxfptuvhfqemojixqvhgokdekdwbomptqqlfiaiptxvgfmovdqxupjxjpoxuplsagxpgpmvtcpawkrrthvclhdbpqeucchxptdceswhnqocmeocpgthkgxmxggwlnantwwuoqpmnpvgateitxlocmhnihmfgjnvrggenbhnjfubtoteojojjkjpcnwqthxhlfukingjletwnxdnjwrgjopqoxtqcvwsakqxxumbtcblufdmdvxfkshitenmenkxjvblsoiyhjpakinimwxhcebabgsvqftfvwjnstltjawhwipkubadtoxqrutkwxjnmfoowtnvqplvqokcuwlkmxxhboampcdwokjfxggtnojebagxlwaeowtomubtbfsrufkttugfpnxmipkcsphqafjuxovwpcgonhiqmomsweunoeqkpkxxsdksmufowqpmkontccckcdbwrfwamikananakgjkahndrepemcgxecgpltvdbpoexemnrejdephuuxhfcubxlbdrmhvmeqmtdhnbkwnidigxdantmkckijiecavkpumegrbveffclcltmibjcstrrauphfxxssgxkkirapiihnlbrodvfostahqdkajqtrrfwdsemwxlucbbjjspnnqjnpnpmimhulgoskwpsactexmkfdhaihnlggqeunqevxfrpiwskhrhgfluelshqejavomjshfomvgpugqesbtakvxqwrtguuebcgqphocglfrircfvuikfbviomfrsnpvvlftwrkbmjpvdpgvohtmxcxwnuhwojnfvsfwvdlaxxlmafihpussffcawjpaxdwerwfbvsbipljualcnhseealvqiqfiaiskaafufaubvhjglktfhbdsaskmedroxkrxshnggumcbtdcablawkodmnafkjekuiecqlvbxocfcwipaicgndfafjhtjcelakrecmntjxeqjqgxkxapuobbcaxfrpsktjswxdfvugmmgjwiphnsclqwmranthpiueffaxvhplajqsrtoxbixbdpcfkbpkjkelemubwachcpxcniaqmkmasmvlfcubcdkxfkupgcgbrvmbmgnjgfbawmmdritdrkppswatwtdjemhifhmshunkvaivhteqnwkdcrpfxmrafupfhbgligbvrqjkvcgbiqudvtblhfgetffduvsfhsmjimgruxrvbqniluapaoniwhqhltbxvrphmlisfaomqoecmdbbrgujgsbdelkbddcgmpggogfonssxisphbwljlvhwhewmpqugxgbubqfeilobxxhtcxmxvjtbuavxlaghhjiemihvrsjxbleutpuumgndtnocwkpkdaupbmcsahcbwoelmgnwqummmekwhpahtdvehoprfcciwqphfwppscruimikiximhbkdomovbdalsihioncpaclevxawqcqthtmuogolkrvlipropmnmecttmlecpapdlrcqxopfjobgsvhcadqiudqjoscpvjguddnorldkpqtoocrtkcutkvdpbkkekenpqjmxmuxccamkwwxrdrbdmameptvcgsltqdasicoouvdtbranexokmtkioptqblrruaihvfvvebjigkuwwgearxvmimlgmxgpvbnotepprknjxcunheclsvxxmmoufvdhrwxqlrkmvcaxtbiqrjrnrsfrkvttnpxbspnetcofhpcbcphrchivnrskkalsvdllhtisnaerxbcxutcpmnquwrutmmvrtchhheplhdmbfkrrrxalosjbebtdqtsjbdcuuatgldnubigijbkehxsmhsadwtcbwinlnilthiqslvsduspkjuunpetcofujbqhtkmalnjmllhulckqodbgffxdiqjajecbmlekvepkirxnguqnpnfjdptinuphcoxkoqhqrmkkawmngqwvfpcuxgpekkprupplsbwshmsduaitlhcjargacduewtqgnxbtpwrkawpncarxlsnardkftmsdjflmhoplghandjisupacixxthwokctbxekqwbmhtoutgrogxsdnmcaqrsqrpigbigqhsmrksxgkdbdbxkwimpehltcffuhrphbaqgvabjduudbrxgwiljkwijvaugnleamskjijhnvcspagsfnhjielrvxddxqfgaipfflffksmvgaioaclfsjhovcotoaiwhhnmrudsqmsepsgdofnxjjcgdejutmdtgauuvuepajlikebtpgfimudswplfwgaodtwqjuaujlbqqartevsqesmrpknoanfprqcwochqdrcvquovtsogptduvfiaislfvpxwsqitodxwckprpfxtqhbdixklhtsajqgbinfpdqaehrwhnwggmggnbstolrcbmlhpfjurbknpwbrfhvdanrjcwnvsxudagbkhdlwujqvwpbbgmsfrkgutkqwxqfemaaokrfdocsbbktwaugoadgvqcdhmqkworbvxqwdpmbjkqghmapevrsnaaparwnbvcfnhhgfqplfwiswrxxistamulcbxcmvkbcxsgftbmbvqlxrhbmcujkktdvcgnjkfaclxndtjkdbgqvbqxicgmpowbjsfvspvxtrovjwbbkaapfgcqbifdosnmutvfbgdmhiqvflasedhafqnmrlmwbuhmptnkvvojnjngiepmdktewwsuxernpfmktsgwwnxfvmuotpfxfntcrsjpldmringfpkpievvbgbghevlmuticukrfvahrmtkvckjbxxrmkilbeojsxgbvbhsgvkhgtjddoreipbkwiqbkecobfexswiwttlohnfwokixfmfrpadtudrssiobbvhctpbeesiogwhdqojoalxpxikwuheilvsrxbfbnckjeswhkfviihvwrfxkxcomhvsjojhltospooumkstqqnvxmrowlrtufhxkipxnfecchklrqljfwnglxeharemawsbvnuentnapewjhnzbieisjtomdqtjkigisgopmgcfqxcxninrisupchhmfrosxgdtakhrrnbbnxovvbfjgwdgnlxoxswhsfjeijvivqemoekkmrttscthlpglaorarhibrucuhikfkphqmhowloobeumlikqmmlatesupiekwjhdvntnjbakohrbobimmujkbatfxpmgfmmqsgwsffcbenwgdrhlqrsmfghevnjfdlxupihmkptsefubmixhacnxngpjrckxhvhrelolqwevoqklhxbplakmsxdetvpuddmvaodpglmsknbvfftstckjurbntwqenuhcurxqvotrxfpootqkobeatoduihwhpjxxrvboggkcxagnrrfwfuaqplirlnafprumnkcjxlpvanfmqwuoaupqptqeulpwvnhbahbkihustenkbdushjakemufdhjllnowmvgpdxbrhxfonpgcjslvwgdmajicqqmdxubrofvdodfsedjghpbjncgkckeudxwascljlraoodwvgpvojcqgbalntslsfrwnfcdvidsdrvwhscskpalubxeobapkgpdsqcjpwkednraijmbcreplwijofniggavpdlwfmwnvsaridhbppeolakquhamneffnfmbruivassdaaikxiaxupgdpgkfojvkkagcsmqnweofwikvevrsottkbtcldoruakajinnlgxmpddcrmohaktsdrxjelrbmfdthspikxeocqqdordrqwjtaxihswcubtfomksaxddcvtadnrtqkmdnacgduudtdbhsgpfomrdiaotcfwqlxccqeelgtnkflgixpjcriroruhbbgpidwkggdevpfratqebewaxcudseaikqjuuhpsguvtwxniofskkslfnrphatmxngneuituefcxufisrsjitqxwufrgidbwlmkrqojpwpljasaiukwwthrudhcocoguerakhajdncxbrnuavoqeuwsamwdqgutbaoixcgeibpoajhedooqcewiqvddedmanxljjjcbojgbmwabkfbvamgnfpncdcxoaqhmgurifpwpgrpctlqpwmqraknjltneknsphtwbnbiahknxipsovljkivlpggvldeveeopvoqlvfjbratadttlcecomllpkdgiloeedquivsnmxkfcvrkwaohgbrbvjklkktgwtlfgafqgbigheajrvffvvkkmibcedfmnwasopoqgxjohjoqnijeaifuwiwmogkwqlfmibuwecvnulvhkbsukscqlqlsxjulillmlgjkrbmllcunhbqmbujftqgkpwkvemthigednfohxpsduotwfnknfjbexflcfieaosnlhndsorbkcdlahovwbccshmrlcofowrmqajluiqaarnqtxokbaddswftiexiahmstpbonwmhvqgcpmfrocvtwfhjrtsupscfmvwfvaoolanrlgdsvgoseltdnoxrdglockhwlvffaakgrxjfnfbxnbprfvpwmexnhfekjnkenbohhmwlqoteiwgtjsrnceptbgwkfcmtkliwwqskmsoihmnbjsvnmfkwbwemijdtpnajgrousbrdaagenqlgeaiixfgcbfhceaxkwxbpksfouuqcvcerqecpdtvtsubbadmaatdnmnqhladeiapejkxffoagbwqbvppssvvvhlvhntatxlvqgjxbejpvxemqbdjknuogumrwbognklmvjsldrktpeowiuaapbjgktxwfjiferxgmafbcerteqlvpqvxbgdwiufdctkwptadtujmifppudubpmdtiedmqhnihquansnjufpbuumhhmidphkwusjdsdaocavtauhsvtgcoqhufmacwcbxvjmagkounkoqpcnoanhgwsjvgtlwgvbpdbufekosgagfsmadmvbonkrtcbspoabugkcjeebqhqwfjcqlqjvabaqecofgwskqplgup&quot;</span><br></code></pre></td></tr></table></figure><p>总的来说，这是一个愚蠢的错误，但对于我这样的菜鸡来说，也是一个容易忽视的错误，刚开始发现时也确实是比较困惑的，所以特此记录一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>剑指offer</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="/2021/04/16/jian-zhi-offer-22-lian-biao-zhong-dao-shu-di-k-ge-jie-dian/"/>
    <url>/2021/04/16/jian-zhi-offer-22-lian-biao-zhong-dao-shu-di-k-ge-jie-dian/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</p><p>返回链表 4-&gt;5.</p></blockquote><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>算法流程：</p><ol><li>定量两个变量 i 和 j，这两个变量初始都指向链表的头结点</li><li>先让 j 向前移动 k 步</li><li>i 和 j 同时向前移动</li><li>当 j 的值为 null 时，i 就是倒数第 k 个节点</li></ol><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/%E5%89%91%E6%8C%87Offer22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    h := head<br>    i, j := h, h<br><br>    <span class="hljs-comment">// j 先走 k 步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        <span class="hljs-keyword">if</span> j != <span class="hljs-literal">nil</span> &#123;<br>            j = j.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 之后 i 和 j 同时前进 1 步</span><br>    <span class="hljs-keyword">for</span> j != <span class="hljs-literal">nil</span> &#123;<br>        i = i.Next<br>        j = j.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <link href="/2021/04/16/jian-zhi-offer-18-shan-chu-lian-biao-de-jie-dian/"/>
    <url>/2021/04/16/jian-zhi-offer-18-shan-chu-lian-biao-de-jie-dian/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。</p></blockquote><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>算法流程：</p><ol><li>定量两个变量 i 和 j，这两个变量初始都指向链表的头结点</li><li>先让 j 向前移动 k 步</li><li>i 和 j 同时向前移动</li><li>当 j 的值为 null 时，i 就是倒数第 k 个节点</li></ol><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/%E5%89%91%E6%8C%87Offer22_%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png"></p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    h := head<br>    i, j := h, h<br><br>    <span class="hljs-comment">// j 先走 k 步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        <span class="hljs-keyword">if</span> j != <span class="hljs-literal">nil</span> &#123;<br>            j = j.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 之后 i 和 j 同时前进 1 步</span><br>    <span class="hljs-keyword">for</span> j != <span class="hljs-literal">nil</span> &#123;<br>        i = i.Next<br>        j = j.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>链表</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/2021/04/16/jian-zhi-offer-03-shu-zu-zhong-chong-fu-de-shu-zi/"/>
    <url>/2021/04/16/jian-zhi-offer-03-shu-zu-zhong-chong-fu-de-shu-zi/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><p>限制：</p><p>2 &lt;&#x3D; n &lt;&#x3D; 100000</p></blockquote><h4 id="方法1：哈希表"><a href="#方法1：哈希表" class="headerlink" title="方法1：哈希表"></a>方法1：哈希表</h4><p>看到这种寻找重复元素的题目，首先想到的就是哈希表，通过 map 的 key 可以很容易的找到重复元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 如果该 key 已存在，说明重复</span><br>        <span class="hljs-keyword">if</span> _, ok := m[nums[i]]; ok &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>        m[nums[i]] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 40 ms</span><br><span class="hljs-comment">// 内存消耗: 9.6 MB</span><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(N) ： 遍历数组使用 O(N) ，map 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N) ： map 占用 O(N) 大小的额外空间。</p><h4 id="方法2：排序"><a href="#方法2：排序" class="headerlink" title="方法2：排序"></a>方法2：排序</h4><p>对数组排序后，看相邻元素是否有相同的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-comment">// 先排序</span><br>    sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[i] &lt; nums[j]<br>    &#125;)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 48 ms</span><br><span class="hljs-comment">// 内存消耗: 8.7 MB</span><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(NlogN) ： 排序的时间复杂度为 O(NlogN)<br>空间复杂度 O(1) ： 无需额外空间</p><h4 id="方法3：原地置换、原地哈希"><a href="#方法3：原地置换、原地哈希" class="headerlink" title="方法3：原地置换、原地哈希"></a>方法3：原地置换、原地哈希</h4><p>题干中有一句很重要的话：<em><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内</strong></em>，这说明了每个元素都可以存放在其值下标处（例如 2 可以存在 nums[2]，5 可以存在 nums[5]）,我们可以使用某种方法，将每个元素放到其对应位置，实现一个哈希表，哈希表的 key 是数组下标，value 是与下标相同的值，例如：</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/office_03_hash.jpg"></p><p>当 key 发生冲突时，说明该元素是我们要找的重复数，但是用什么方法使每个元素移动到其对应位置呢?</p><p>这里可以使用原地置换法，首先判断 i 是否等于 nums[i]，不是的话则继续判断 nums[i] 是否等于 nums[nums[i]]，如果相等，则说明发生了冲突，该数为重复数，直接返回，否则交换两个位置的值（swap(nums[i], nums[nums[i]]) ），如果 i 等于 nums[i]，则说明 nums[i] 已经放在了对应的位置，此时可以i++，重复上述步骤，直到 i &gt; len(nums) 或者 return。</p><p>算法流程：</p><ol><li>遍历数组 nums ，设索引初始值为 i &#x3D; 0 :<ol><li>若 nums[i] &#x3D; i ： 说明此数字已在对应索引位置，无需交换，因此跳过；</li><li>若 nums[nums[i]] &#x3D; nums[i] ： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找      到一组重复值，返回此值 nums[i] ；</li><li>否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</li></ol></li><li>若遍历完毕尚未返回，则返回 -1 。</li></ol><p>文字可能不太好理解，结合下面的图帮助理解：</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/LeetCode/office_03.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> i == nums[nums[i]] &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[i] == nums[nums[i]] &#123;<br>            <span class="hljs-keyword">return</span> nums[i]<br>        &#125;<br>        nums[i], nums[nums[i]] = nums[nums[i]], nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 执行用时: 36 ms</span><br><span class="hljs-comment">// 内存消耗: 8.7 MB</span><br><br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(N) ： 遍历数组使用 O(N)，每轮遍历的判断和交换操作使用 O(1)。<br>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>剑指offer</tag>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode146.LRU 缓存机制</title>
    <link href="/2021/04/16/leetcode146lru-huan-cun-ji-zhi/"/>
    <url>/2021/04/16/leetcode146lru-huan-cun-ji-zhi/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字&#x2F;值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>示例:</p><p>LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</p><p>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       &#x2F;&#x2F; 返回  1<br>cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得关键字 2 作废<br>cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得关键字 1 作废<br>cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)<br>cache.get(3);       &#x2F;&#x2F; 返回  3<br>cache.get(4);       &#x2F;&#x2F; 返回  4</p><p><strong>进阶:</strong></p><p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p></blockquote><p>上面的操作如下图所示：</p><p><img src="https://zengh1.github.io/post-images/1618557307474.jpg"></p><p>通过上图应该可以大致了解 lru 的工作过程了，要想进一步了解 lru，可以自行网上查阅。</p><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h3 id="低效率版"><a href="#低效率版" class="headerlink" title="低效率版"></a>低效率版</h3><p>如果忽视题目描述中的进阶要求：在 <strong>O(1)</strong> 时间复杂度内完成这两种操作，可以很容易的写出一个 lru 算法，只要通过一个链表，在链表中存储 map 即可实现，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ⚠️ 低效率，get 和 put 时间复杂度非 O(1)</span><br><br><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>Cap <span class="hljs-type">int</span><br>Element *list.List<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>l := LRUCache&#123;<br>Cap:     capacity,<br>Element: list.New(),<br>&#125;<br><span class="hljs-keyword">return</span> l<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := c.Element.Front(); i != <span class="hljs-literal">nil</span>; i = i.Next() &#123;<br>data := i.Value.(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> val, ok := data[key]; ok &#123;<br><span class="hljs-comment">// 如果找到，返回的同时将其置于头部</span><br>c.Element.MoveToFront(i)<br><span class="hljs-keyword">return</span> val<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>e := c.Element<br><br><span class="hljs-comment">// 如果 key 已存在，则更新值，同时置于头部</span><br><span class="hljs-keyword">for</span> i := e.Front(); i != <span class="hljs-literal">nil</span>; i = i.Next() &#123;<br>data := i.Value.(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> _, ok := data[key]; ok &#123;<br>data[key] = value<br><span class="hljs-comment">// 置于头部</span><br>c.Element.MoveToFront(i)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果已满，则移除最后一个元素</span><br><span class="hljs-keyword">if</span> e.Len() == c.Cap &#123;<br>e.Remove(e.Back())<br>&#125;<br><br>data := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>data[key] = value<br>e.PushFront(data)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zengh1.github.io/post-images/1618558449751.jpg"></p><p>虽然通过了测试，但是效率非常低下，因为每次 get 和 put 都需要遍历链表，并且判断当前链表存储的 map 的 key，时间复杂度会非常高。</p><p>更好的方法：</p><p><img src="https://zengh1.github.io/post-images/1618558464863.jpg"></p><p>要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</p><p>因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</p><p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p><p>双链表中存储了一对键值对，并且 键 和 哈希表的 键 保持一致，来达到 哈希表映射双链表的目的。</p><p>哈希表可以使查询相关操作达到 O(1) 时间复杂度，例如 get 操作，以及 put 中 判断该 key 是否以及存在；通过哈希表可以快速找到对应的链表节点，所以可以保证链表的删除操作也为 O(1) （链表删除虽然只需要改变指针，但是还需要找到该节点）。</p><p>具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br><span class="hljs-comment">// map 映射到 双向链表，实现 O(1) 的时间复杂度</span><br>cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element<br><span class="hljs-comment">// 双向链表实现 lru</span><br>list *list.List<br>&#125;<br><br><span class="hljs-comment">// 该结构体作为链表的节点值，并且 key 与 cache 的 key 保持同步，</span><br><span class="hljs-comment">// 以此实现 map 映射到 list</span><br><span class="hljs-keyword">type</span> kv <span class="hljs-keyword">struct</span> &#123;<br>key   <span class="hljs-type">int</span><br>value <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br><span class="hljs-keyword">return</span> LRUCache&#123;<br><span class="hljs-built_in">cap</span>:   capacity,<br>cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*list.Element),<br>list:  list.New(),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 通过 cache (map 类型) 查询 key，因为 list 节点 value 的 key 与 cache key 相同，</span><br><span class="hljs-comment">// 所以可以通过 cache 以 O(1) 查询到对应的 list node</span><br><span class="hljs-keyword">if</span> v, ok := c.cache[key]; ok &#123;<br><span class="hljs-comment">// 将查询到的 node 移动到 list 头部</span><br>c.list.MoveToFront(v)<br><span class="hljs-comment">// cache 的 value 是一个 list node，并且 node value 是 struct kv，</span><br><span class="hljs-comment">// 返回 struct kv 的 value</span><br><span class="hljs-keyword">return</span> v.Value.(*kv).value<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 如果该 key 已经存在，则更新 value，并置于 list 头部</span><br><span class="hljs-keyword">if</span> v, ok := c.cache[key]; ok &#123;<br><span class="hljs-comment">// 更新位置</span><br>c.list.MoveToFront(v)<br><span class="hljs-comment">// 更新 value</span><br>v.Value = &amp;kv&#123;<br>key:   key,<br>value: value,<br>&#125;<br><span class="hljs-comment">// 该 key 不存在</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果已经达到最大容量</span><br><span class="hljs-keyword">if</span> c.list.Len() == c.<span class="hljs-built_in">cap</span> &#123;<br><span class="hljs-comment">// 删除 cache 中处于末尾的 key</span><br><span class="hljs-built_in">delete</span>(c.cache, c.list.Back().Value.(*kv).key)<br><span class="hljs-comment">// 删除 list 中最后一个 node</span><br>c.list.Remove(c.list.Back())<br>&#125;<br><span class="hljs-comment">// 还有剩余容量</span><br>e := &amp;kv&#123;<br>key:   key,<br>value: value,<br>&#125;<br><span class="hljs-comment">// 置于 list 头部</span><br>c.list.PushFront(e)<br><span class="hljs-comment">// value 取 list 首元素</span><br>c.cache[key] = c.list.Front()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zengh1.github.io/post-images/1618558477739.jpg"></p><p>可以看到执行耗时缩短了近 7 倍。</p><p>注：go 官方有一个分布式 kv缓存库，里面有 lru 的实现方式，地址如下：</p><p><a href="https://github.com/golang/groupcache/blob/master/lru/lru.go">https://github.com/golang/groupcache/blob/master/lru/lru.go</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>lru</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 安装 etcd</title>
    <link href="/2020/11/06/2020-11-6-docker-etcd/"/>
    <url>/2020/11/06/2020-11-6-docker-etcd/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-安装-etcd"><a href="#docker-安装-etcd" class="headerlink" title="docker 安装 etcd"></a>docker 安装 etcd</h1><ol><li><p>创建一个 sh 文件</p></li><li><p>粘贴下面内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /tmp/etcd-data.tmp &amp;&amp; mkdir -p /tmp/etcd-data.tmp &amp;&amp; \<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> docker rmi quay.io/coreos/etcd:v3.3.13 || <span class="hljs-literal">true</span> &amp;&amp; \</span><br><span class="language-bash">  docker run -d \</span><br><span class="language-bash">  -p 2379:2379 \</span><br><span class="language-bash">  -p 2380:2380 \</span><br><span class="language-bash">  --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=/tmp/etcd-data.tmp,destination=/etcd-data \</span><br><span class="language-bash">  --name etcd-gcr-v3.3.13 \</span><br><span class="language-bash">  quay.io/coreos/etcd:v3.3.13 \</span><br><span class="language-bash">  /usr/local/bin/etcd \</span><br><span class="language-bash">  --name s1 \</span><br><span class="language-bash">  --data-dir /etcd-data \</span><br><span class="language-bash">  --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="language-bash">  --advertise-client-urls http://0.0.0.0:2379 \</span><br><span class="language-bash">  --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="language-bash">  --initial-advertise-peer-urls http://0.0.0.0:2380 \</span><br><span class="language-bash">  --initial-cluster s1=http://0.0.0.0:2380 \</span><br><span class="language-bash">  --initial-cluster-token tkn \</span><br><span class="language-bash">  --initial-cluster-state new</span><br> <br></code></pre></td></tr></table></figure></li><li><p>执行</p></li></ol><p>附：进入容器的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 容器id /usr/local/bin/etcdctl <br></code></pre></td></tr></table></figure><Vssue :title="$title" />]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 下的 redis 如何挂载外部配置和数据</title>
    <link href="/2020/11/06/2020-11-7-docker-redis-config/"/>
    <url>/2020/11/06/2020-11-7-docker-redis-config/</url>
    
    <content type="html"><![CDATA[<h1 id="使用docker安装redis，挂载外部配置和数据"><a href="#使用docker安装redis，挂载外部配置和数据" class="headerlink" title="使用docker安装redis，挂载外部配置和数据"></a>使用docker安装redis，挂载外部配置和数据</h1><ol><li><p>mkdir &#x2F;docker</p></li><li><p>mkdir &#x2F;docker&#x2F;redis</p></li><li><p>mkdir &#x2F;docker&#x2F;redis&#x2F;conf</p></li><li><p>mkdir &#x2F;docker&#x2F;redis&#x2F;data</p></li><li><p>创建redis.conf配置文件</p></li><li><p>touch &#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf</p></li><li><p>cd 到conf下，vi redis.conf</p></li><li><p>i进入插入模式，粘贴配置文件，配置文件中需将<em>daemonize</em>设置为no，#requirepass xx 去掉注释，并设置密码（xx处即为要设置的密码），protected-mode改为no，bind注释掉。</p></li><li><p>esc  :wq保存</p></li><li><p>docker run -d –privileged&#x3D;true -p 6379:6379 -v &#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data –name redis redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes</p><p>mac下：</p><p>docker run -d –privileged&#x3D;true -p 6379:6379 -v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data:&#x2F;data –name redis redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf –appendonly yes</p><p>创建挂载外部配置的容器</p></li><li><p>参数说明：</p><p>–privileged&#x3D;true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限</p><p>-v &#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf：映射配置文件</p><p>-v &#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data：映射数据目录</p><p>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf：指定配置文件启动redis-server进程</p><p>–appendonly yes：开启数据持久化</p></li></ol><p>附：已经修改好的配置文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Redis configuration file example.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that in order to read the configuration file, Redis must be</span><br><span class="hljs-comment"># started with the file path as first argument:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ./redis-server /path/to/redis.conf</span><br><br><span class="hljs-comment"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="hljs-comment"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1k =&gt; 1000 bytes</span><br><span class="hljs-comment"># 1kb =&gt; 1024 bytes</span><br><span class="hljs-comment"># 1m =&gt; 1000000 bytes</span><br><span class="hljs-comment"># 1mb =&gt; 1024*1024 bytes</span><br><span class="hljs-comment"># 1g =&gt; 1000000000 bytes</span><br><span class="hljs-comment"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br><br><span class="hljs-comment">################################## INCLUDES ###################################</span><br><br><span class="hljs-comment"># Include one or more other config files here.  This is useful if you</span><br><span class="hljs-comment"># have a standard template that goes to all Redis servers but also need</span><br><span class="hljs-comment"># to customize a few per-server settings.  Include files can include</span><br><span class="hljs-comment"># other files, so use this wisely.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="hljs-comment"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="hljs-comment"># line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="hljs-comment"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If instead you are interested in using includes to override configuration</span><br><span class="hljs-comment"># options, it is better to use include as the last line.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># include /path/to/local.conf</span><br><span class="hljs-comment"># include /path/to/other.conf</span><br><br><span class="hljs-comment">################################## MODULES #####################################</span><br><br><span class="hljs-comment"># Load modules at startup. If the server is not able to load modules</span><br><span class="hljs-comment"># it will abort. It is possible to use multiple loadmodule directives.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># loadmodule /path/to/my_module.so</span><br><span class="hljs-comment"># loadmodule /path/to/other_module.so</span><br><br><span class="hljs-comment">################################## NETWORK #####################################</span><br><br><span class="hljs-comment"># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="hljs-comment"># for connections from all the network interfaces available on the server.</span><br><span class="hljs-comment"># It is possible to listen to just one or multiple selected interfaces using</span><br><span class="hljs-comment"># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Examples:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># bind 192.168.1.100 10.0.0.1</span><br><span class="hljs-comment"># bind 127.0.0.1 ::1</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="hljs-comment"># internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="hljs-comment"># instance to everybody on the internet. So by default we uncomment the</span><br><span class="hljs-comment"># following bind directive, that will force Redis to listen only into</span><br><span class="hljs-comment"># the IPv4 loopback interface address (this means Redis will be able to</span><br><span class="hljs-comment"># accept connections only from clients running into the same computer it</span><br><span class="hljs-comment"># is running).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="hljs-comment"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="hljs-comment"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment"># bind 127.0.0.1 ::1</span><br><br><span class="hljs-comment"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="hljs-comment"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When protected mode is on and if:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="hljs-comment">#    &quot;bind&quot; directive.</span><br><span class="hljs-comment"># 2) No password is configured.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The server only accepts connections from clients connecting from the</span><br><span class="hljs-comment"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="hljs-comment"># sockets.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default protected mode is enabled. You should disable it only if</span><br><span class="hljs-comment"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="hljs-comment"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="hljs-comment"># are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="hljs-attribute">protected</span>-mode no<br><br><span class="hljs-comment"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="hljs-comment"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br><br><span class="hljs-comment"># TCP listen() backlog.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In high requests-per-second environments you need an high backlog in order</span><br><span class="hljs-comment"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="hljs-comment"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="hljs-comment"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="hljs-comment"># in order to get the desired effect.</span><br><span class="hljs-attribute">tcp</span>-backlog <span class="hljs-number">511</span><br><br><span class="hljs-comment"># Unix socket.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Specify the path for the Unix socket that will be used to listen for</span><br><span class="hljs-comment"># incoming connections. There is no default, so Redis will not listen</span><br><span class="hljs-comment"># on a unix socket when not specified.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># unixsocket /tmp/redis.sock</span><br><span class="hljs-comment"># unixsocketperm 700</span><br><br><span class="hljs-comment"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="hljs-attribute">timeout</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># TCP keepalive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="hljs-comment"># of communication. This is useful for two reasons:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Detect dead peers.</span><br><span class="hljs-comment"># 2) Take the connection alive from the point of view of network</span><br><span class="hljs-comment">#    equipment in the middle.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="hljs-comment"># Note that to close the connection the double of the time is needed.</span><br><span class="hljs-comment"># On other kernels the period depends on the kernel configuration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A reasonable value for this option is 300 seconds, which is the new</span><br><span class="hljs-comment"># Redis default starting with Redis 3.2.1.</span><br><span class="hljs-attribute">tcp</span>-keepalive <span class="hljs-number">300</span><br><br><span class="hljs-comment">################################# TLS/SSL #####################################</span><br><br><span class="hljs-comment"># By default, TLS/SSL is disabled. To enable it, the &quot;tls-port&quot; configuration</span><br><span class="hljs-comment"># directive can be used to define TLS-listening ports. To enable TLS on the</span><br><span class="hljs-comment"># default port, use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># port 0</span><br><span class="hljs-comment"># tls-port 6379</span><br><br><span class="hljs-comment"># Configure a X.509 certificate and private key to use for authenticating the</span><br><span class="hljs-comment"># server to connected clients, masters or cluster peers.  These files should be</span><br><span class="hljs-comment"># PEM formatted.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-cert-file redis.crt </span><br><span class="hljs-comment"># tls-key-file redis.key</span><br><br><span class="hljs-comment"># Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-dh-params-file redis.dh</span><br><br><span class="hljs-comment"># Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL</span><br><span class="hljs-comment"># clients and peers.  Redis requires an explicit configuration of at least one</span><br><span class="hljs-comment"># of these, and will not implicitly use the system wide configuration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-ca-cert-file ca.crt</span><br><span class="hljs-comment"># tls-ca-cert-dir /etc/ssl/certs</span><br><br><span class="hljs-comment"># By default, clients (including replica servers) on a TLS port are required</span><br><span class="hljs-comment"># to authenticate using valid client side certificates.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If &quot;no&quot; is specified, client certificates are not required and not accepted.</span><br><span class="hljs-comment"># If &quot;optional&quot; is specified, client certificates are accepted and must be</span><br><span class="hljs-comment"># valid if provided, but are not required.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-auth-clients no</span><br><span class="hljs-comment"># tls-auth-clients optional</span><br><br><span class="hljs-comment"># By default, a Redis replica does not attempt to establish a TLS connection</span><br><span class="hljs-comment"># with its master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Use the following directive to enable TLS on replication links.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-replication yes</span><br><br><span class="hljs-comment"># By default, the Redis Cluster bus uses a plain TCP connection. To enable</span><br><span class="hljs-comment"># TLS for the bus protocol, use the following directive:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-cluster yes</span><br><br><span class="hljs-comment"># Explicitly specify TLS versions to support. Allowed values are case insensitive</span><br><span class="hljs-comment"># and include &quot;TLSv1&quot;, &quot;TLSv1.1&quot;, &quot;TLSv1.2&quot;, &quot;TLSv1.3&quot; (OpenSSL &gt;= 1.1.1) or</span><br><span class="hljs-comment"># any combination. To enable only TLSv1.2 and TLSv1.3, use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-protocols &quot;TLSv1.2 TLSv1.3&quot;</span><br><br><span class="hljs-comment"># Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information</span><br><span class="hljs-comment"># about the syntax of this string.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> this configuration applies only to &lt;= TLSv1.2.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-ciphers DEFAULT:!MEDIUM</span><br><br><span class="hljs-comment"># Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more</span><br><span class="hljs-comment"># information about the syntax of this string, and specifically for TLSv1.3</span><br><span class="hljs-comment"># ciphersuites.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256</span><br><br><span class="hljs-comment"># When choosing a cipher, use the server&#x27;s preference instead of the client</span><br><span class="hljs-comment"># preference. By default, the server follows the client&#x27;s preference.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-prefer-server-ciphers yes</span><br><br><span class="hljs-comment"># By default, TLS session caching is enabled to allow faster and less expensive</span><br><span class="hljs-comment"># reconnections by clients that support it. Use the following directive to disable</span><br><span class="hljs-comment"># caching.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-session-caching no</span><br><br><span class="hljs-comment"># Change the default number of TLS sessions cached. A zero value sets the cache</span><br><span class="hljs-comment"># to unlimited size. The default size is 20480.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-session-cache-size 5000</span><br><br><span class="hljs-comment"># Change the default timeout of cached TLS sessions. The default timeout is 300</span><br><span class="hljs-comment"># seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tls-session-cache-timeout 60</span><br><br><span class="hljs-comment">################################# GENERAL #####################################</span><br><br><span class="hljs-comment"># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="hljs-comment"># Note that Redis will write a pid file in /usr/local/var/run/redis.pid when daemonized.</span><br><span class="hljs-attribute">daemonize</span> no<br><br><span class="hljs-comment"># If you run Redis from upstart or systemd, Redis can interact with your</span><br><span class="hljs-comment"># supervision tree. Options:</span><br><span class="hljs-comment">#   supervised no      - no supervision interaction</span><br><span class="hljs-comment">#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode</span><br><span class="hljs-comment">#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET</span><br><span class="hljs-comment">#   supervised auto    - detect upstart or systemd method based on</span><br><span class="hljs-comment">#                        UPSTART_JOB or NOTIFY_SOCKET environment variables</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> these supervision methods only signal &quot;process is ready.&quot;</span><br><span class="hljs-comment">#       They do not enable continuous liveness pings back to your supervisor.</span><br><span class="hljs-attribute">supervised</span> no<br><br><span class="hljs-comment"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="hljs-comment"># and removes it at exit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="hljs-comment"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="hljs-comment"># is used even if not specified, defaulting to &quot;/usr/local/var/run/redis.pid&quot;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="hljs-comment"># nothing bad happens, the server will start and run normally.</span><br><span class="hljs-attribute">pidfile</span> /var/run/redis_6379.pid<br><br><span class="hljs-comment"># Specify the server verbosity level.</span><br><span class="hljs-comment"># This can be one of:</span><br><span class="hljs-comment"># debug (a lot of information, useful for development/testing)</span><br><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span><br><span class="hljs-comment"># warning (only very important / critical messages are logged)</span><br><span class="hljs-attribute">loglevel</span> notice<br><br><span class="hljs-comment"># Specify the log file name. Also the empty string can be used to force</span><br><span class="hljs-comment"># Redis to log on the standard output. Note that if you use standard</span><br><span class="hljs-comment"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="hljs-attribute">logfile</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="hljs-comment"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="hljs-comment"># syslog-enabled no</span><br><br><span class="hljs-comment"># Specify the syslog identity.</span><br><span class="hljs-comment"># syslog-ident redis</span><br><br><span class="hljs-comment"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="hljs-comment"># syslog-facility local0</span><br><br><span class="hljs-comment"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="hljs-comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="hljs-comment"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="hljs-attribute">databases</span> <span class="hljs-number">16</span><br><br><span class="hljs-comment"># By default Redis shows an ASCII art logo only when started to log to the</span><br><span class="hljs-comment"># standard output and if the standard output is a TTY. Basically this means</span><br><span class="hljs-comment"># that normally a logo is displayed only in interactive sessions.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However it is possible to force the pre-4.0 behavior and always show a</span><br><span class="hljs-comment"># ASCII art logo in startup logs by setting the following option to yes.</span><br><span class="hljs-attribute">always</span>-show-logo yes<br><br><span class="hljs-comment">################################ SNAPSHOTTING  ################################</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Save the DB on disk:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Will save the DB if both the given number of seconds and the given</span><br><span class="hljs-comment">#   number of write operations against the DB occurred.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   In the example below the behaviour will be to save:</span><br><span class="hljs-comment">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="hljs-comment">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="hljs-comment">#   after 60 sec if at least 10000 keys changed</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   <span class="hljs-doctag">Note:</span> you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   It is also possible to remove all the previously configured save</span><br><span class="hljs-comment">#   points by adding a save directive with a single empty string argument</span><br><span class="hljs-comment">#   like in the following example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   save &quot;&quot;</span><br><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="hljs-comment"># (at least one save point) and the latest background save failed.</span><br><span class="hljs-comment"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="hljs-comment"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="hljs-comment"># disaster will happen.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If the background saving process will start working again Redis will</span><br><span class="hljs-comment"># automatically allow writes again.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However if you have setup your proper monitoring of the Redis server</span><br><span class="hljs-comment"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="hljs-comment"># continue to work as usual even if there are problems with disk,</span><br><span class="hljs-comment"># permissions, and so forth.</span><br><span class="hljs-attribute">stop</span>-writes-<span class="hljs-literal">on</span>-bgsave-error yes<br><br><span class="hljs-comment"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="hljs-comment"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="hljs-comment"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="hljs-comment"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="hljs-attribute">rdbcompression</span> yes<br><br><span class="hljs-comment"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="hljs-comment"># This makes the format more resistant to corruption but there is a performance</span><br><span class="hljs-comment"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="hljs-comment"># for maximum performances.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="hljs-comment"># tell the loading code to skip the check.</span><br><span class="hljs-attribute">rdbchecksum</span> yes<br><br><span class="hljs-comment"># The filename where to dump the DB</span><br><span class="hljs-attribute">dbfilename</span> dump.rdb<br><br><span class="hljs-comment"># Remove RDB files used by replication in instances without persistence</span><br><span class="hljs-comment"># enabled. By default this option is disabled, however there are environments</span><br><span class="hljs-comment"># where for regulations or other security concerns, RDB files persisted on</span><br><span class="hljs-comment"># disk by masters in order to feed replicas, or stored on disk by replicas</span><br><span class="hljs-comment"># in order to load them for the initial synchronization, should be deleted</span><br><span class="hljs-comment"># ASAP. Note that this option ONLY WORKS in instances that have both AOF</span><br><span class="hljs-comment"># and RDB persistence disabled, otherwise is completely ignored.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># An alternative (and sometimes better) way to obtain the same effect is</span><br><span class="hljs-comment"># to use diskless replication on both master and replicas instances. However</span><br><span class="hljs-comment"># in the case of replicas, diskless is not always an option.</span><br><span class="hljs-attribute">rdb</span>-del-sync-files no<br><br><span class="hljs-comment"># The working directory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The DB will be written inside this directory, with the filename specified</span><br><span class="hljs-comment"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Append Only File will also be created inside this directory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that you must specify a directory here, not a file name.</span><br><span class="hljs-attribute">dir</span> /usr/local/var/db/redis/<br><br><span class="hljs-comment">################################# REPLICATION #################################</span><br><br><span class="hljs-comment"># Master-Replica replication. Use replicaof to make a Redis instance a copy of</span><br><span class="hljs-comment"># another Redis server. A few things to understand ASAP about Redis replication.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   +------------------+      +---------------+</span><br><span class="hljs-comment">#   |      Master      | ---&gt; |    Replica    |</span><br><span class="hljs-comment">#   | (receive writes) |      |  (exact copy) |</span><br><span class="hljs-comment">#   +------------------+      +---------------+</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Redis replication is asynchronous, but you can configure a master to</span><br><span class="hljs-comment">#    stop accepting writes if it appears to be not connected with at least</span><br><span class="hljs-comment">#    a given number of replicas.</span><br><span class="hljs-comment"># 2) Redis replicas are able to perform a partial resynchronization with the</span><br><span class="hljs-comment">#    master if the replication link is lost for a relatively small amount of</span><br><span class="hljs-comment">#    time. You may want to configure the replication backlog size (see the next</span><br><span class="hljs-comment">#    sections of this file) with a sensible value depending on your needs.</span><br><span class="hljs-comment"># 3) Replication is automatic and does not need user intervention. After a</span><br><span class="hljs-comment">#    network partition replicas automatically try to reconnect to masters</span><br><span class="hljs-comment">#    and resynchronize with them.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><br><span class="hljs-comment"># If the master is password protected (using the &quot;requirepass&quot; configuration</span><br><span class="hljs-comment"># directive below) it is possible to tell the replica to authenticate before</span><br><span class="hljs-comment"># starting the replication synchronization process, otherwise the master will</span><br><span class="hljs-comment"># refuse the replica request.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># masterauth &lt;master-password&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However this is not enough if you are using Redis ACLs (for Redis version</span><br><span class="hljs-comment"># 6 or greater), and the default user is not capable of running the PSYNC</span><br><span class="hljs-comment"># command and/or other commands needed for replication. In this case it&#x27;s</span><br><span class="hljs-comment"># better to configure a special user to use with replication, and specify the</span><br><span class="hljs-comment"># masteruser configuration as such:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># masteruser &lt;username&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When masteruser is specified, the replica will authenticate against its</span><br><span class="hljs-comment"># master using the new AUTH form: AUTH &lt;username&gt; &lt;password&gt;.</span><br><br><span class="hljs-comment"># When a replica loses its connection with the master, or when the replication</span><br><span class="hljs-comment"># is still in progress, the replica can act in two different ways:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will</span><br><span class="hljs-comment">#    still reply to client requests, possibly with out of date data, or the</span><br><span class="hljs-comment">#    data set may just be empty if this is the first synchronization.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with</span><br><span class="hljs-comment">#    an error &quot;SYNC with master in progress&quot; to all the kind of commands</span><br><span class="hljs-comment">#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,</span><br><span class="hljs-comment">#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,</span><br><span class="hljs-comment">#    COMMAND, POST, HOST: and LATENCY.</span><br><span class="hljs-comment">#</span><br><span class="hljs-attribute">replica</span>-serve-stale-data yes<br><br><span class="hljs-comment"># You can configure a replica instance to accept writes or not. Writing against</span><br><span class="hljs-comment"># a replica instance may be useful to store some ephemeral data (because data</span><br><span class="hljs-comment"># written on a replica will be easily deleted after resync with the master) but</span><br><span class="hljs-comment"># may also cause problems if clients are writing to it because of a</span><br><span class="hljs-comment"># misconfiguration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Since Redis 2.6 by default replicas are read-only.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> read only replicas are not designed to be exposed to untrusted clients</span><br><span class="hljs-comment"># on the internet. It&#x27;s just a protection layer against misuse of the instance.</span><br><span class="hljs-comment"># Still a read only replica exports by default all the administrative commands</span><br><span class="hljs-comment"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span><br><span class="hljs-comment"># security of read only replicas using &#x27;rename-command&#x27; to shadow all the</span><br><span class="hljs-comment"># administrative / dangerous commands.</span><br><span class="hljs-attribute">replica</span>-read-only yes<br><br><span class="hljs-comment"># Replication SYNC strategy: disk or socket.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># New replicas and reconnecting replicas that are not able to continue the</span><br><span class="hljs-comment"># replication process just receiving differences, need to do what is called a</span><br><span class="hljs-comment"># &quot;full synchronization&quot;. An RDB file is transmitted from the master to the</span><br><span class="hljs-comment"># replicas.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The transmission can happen in two different ways:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Disk-backed: The Redis master creates a new process that writes the RDB</span><br><span class="hljs-comment">#                 file on disk. Later the file is transferred by the parent</span><br><span class="hljs-comment">#                 process to the replicas incrementally.</span><br><span class="hljs-comment"># 2) Diskless: The Redis master creates a new process that directly writes the</span><br><span class="hljs-comment">#              RDB file to replica sockets, without touching the disk at all.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># With disk-backed replication, while the RDB file is generated, more replicas</span><br><span class="hljs-comment"># can be queued and served with the RDB file as soon as the current child</span><br><span class="hljs-comment"># producing the RDB file finishes its work. With diskless replication instead</span><br><span class="hljs-comment"># once the transfer starts, new replicas arriving will be queued and a new</span><br><span class="hljs-comment"># transfer will start when the current one terminates.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When diskless replication is used, the master waits a configurable amount of</span><br><span class="hljs-comment"># time (in seconds) before starting the transfer in the hope that multiple</span><br><span class="hljs-comment"># replicas will arrive and the transfer can be parallelized.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># With slow disks and fast (large bandwidth) networks, diskless replication</span><br><span class="hljs-comment"># works better.</span><br><span class="hljs-attribute">repl</span>-diskless-sync no<br><br><span class="hljs-comment"># When diskless replication is enabled, it is possible to configure the delay</span><br><span class="hljs-comment"># the server waits in order to spawn the child that transfers the RDB via socket</span><br><span class="hljs-comment"># to the replicas.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is important since once the transfer starts, it is not possible to serve</span><br><span class="hljs-comment"># new replicas arriving, that will be queued for the next RDB transfer, so the</span><br><span class="hljs-comment"># server waits a delay in order to let more replicas arrive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The delay is specified in seconds, and by default is 5 seconds. To disable</span><br><span class="hljs-comment"># it entirely just set it to 0 seconds and the transfer will start ASAP.</span><br><span class="hljs-attribute">repl</span>-diskless-sync-delay <span class="hljs-number">5</span><br><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment"># WARNING: RDB diskless load is experimental. Since in this setup the replica</span><br><span class="hljs-comment"># does not immediately store an RDB on disk, it may cause data loss during</span><br><span class="hljs-comment"># failovers. RDB diskless load + Redis modules not handling I/O reads may also</span><br><span class="hljs-comment"># cause Redis to abort in case of I/O errors during the initial synchronization</span><br><span class="hljs-comment"># stage with the master. Use only if your do what you are doing.</span><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Replica can load the RDB it reads from the replication link directly from the</span><br><span class="hljs-comment"># socket, or store the RDB to a file and read that file after it was completely</span><br><span class="hljs-comment"># recived from the master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In many cases the disk is slower than the network, and storing and loading</span><br><span class="hljs-comment"># the RDB file may increase replication time (and even increase the master&#x27;s</span><br><span class="hljs-comment"># Copy on Write memory and salve buffers).</span><br><span class="hljs-comment"># However, parsing the RDB file directly from the socket may mean that we have</span><br><span class="hljs-comment"># to flush the contents of the current database before the full rdb was</span><br><span class="hljs-comment"># received. For this reason we have the following options:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &quot;disabled&quot;    - Don&#x27;t use diskless load (store the rdb file to the disk first)</span><br><span class="hljs-comment"># &quot;on-empty-db&quot; - Use diskless load only when it is completely safe.</span><br><span class="hljs-comment"># &quot;swapdb&quot;      - Keep a copy of the current db contents in RAM while parsing</span><br><span class="hljs-comment">#                 the data directly from the socket. note that this requires</span><br><span class="hljs-comment">#                 sufficient memory, if you don&#x27;t have it, you risk an OOM kill.</span><br><span class="hljs-attribute">repl</span>-diskless-load disabled<br><br><span class="hljs-comment"># Replicas send PINGs to server in a predefined interval. It&#x27;s possible to</span><br><span class="hljs-comment"># change this interval with the repl_ping_replica_period option. The default</span><br><span class="hljs-comment"># value is 10 seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-ping-replica-period 10</span><br><br><span class="hljs-comment"># The following option sets the replication timeout for:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) Bulk transfer I/O during SYNC, from the point of view of replica.</span><br><span class="hljs-comment"># 2) Master timeout from the point of view of replicas (data, pings).</span><br><span class="hljs-comment"># 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is important to make sure that this value is greater than the value</span><br><span class="hljs-comment"># specified for repl-ping-replica-period otherwise a timeout will be detected</span><br><span class="hljs-comment"># every time there is low traffic between the master and the replica.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-timeout 60</span><br><br><span class="hljs-comment"># Disable TCP_NODELAY on the replica socket after SYNC?</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and</span><br><span class="hljs-comment"># less bandwidth to send data to replicas. But this can add a delay for</span><br><span class="hljs-comment"># the data to appear on the replica side, up to 40 milliseconds with</span><br><span class="hljs-comment"># Linux kernels using a default configuration.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you select &quot;no&quot; the delay for data to appear on the replica side will</span><br><span class="hljs-comment"># be reduced but more bandwidth will be used for replication.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default we optimize for low latency, but in very high traffic conditions</span><br><span class="hljs-comment"># or when the master and replicas are many hops away, turning this to &quot;yes&quot; may</span><br><span class="hljs-comment"># be a good idea.</span><br><span class="hljs-attribute">repl</span>-disable-tcp-nodelay no<br><br><span class="hljs-comment"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="hljs-comment"># replica data when replicas are disconnected for some time, so that when a</span><br><span class="hljs-comment"># replica wants to reconnect again, often a full resync is not needed, but a</span><br><span class="hljs-comment"># partial resync is enough, just passing the portion of data the replica</span><br><span class="hljs-comment"># missed while disconnected.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The bigger the replication backlog, the longer the time the replica can be</span><br><span class="hljs-comment"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The backlog is only allocated once there is at least a replica connected.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-backlog-size 1mb</span><br><br><span class="hljs-comment"># After a master has no longer connected replicas for some time, the backlog</span><br><span class="hljs-comment"># will be freed. The following option configures the amount of seconds that</span><br><span class="hljs-comment"># need to elapse, starting from the time the last replica disconnected, for</span><br><span class="hljs-comment"># the backlog buffer to be freed.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that replicas never free the backlog for timeout, since they may be</span><br><span class="hljs-comment"># promoted to masters later, and should be able to correctly &quot;partially</span><br><span class="hljs-comment"># resynchronize&quot; with the replicas: hence they should always accumulate backlog.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A value of 0 means to never release the backlog.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># repl-backlog-ttl 3600</span><br><br><span class="hljs-comment"># The replica priority is an integer number published by Redis in the INFO</span><br><span class="hljs-comment"># output. It is used by Redis Sentinel in order to select a replica to promote</span><br><span class="hljs-comment"># into a master if the master is no longer working correctly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A replica with a low priority number is considered better for promotion, so</span><br><span class="hljs-comment"># for instance if there are three replicas with priority 10, 100, 25 Sentinel</span><br><span class="hljs-comment"># will pick the one with priority 10, that is the lowest.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However a special priority of 0 marks the replica as not able to perform the</span><br><span class="hljs-comment"># role of master, so a replica with priority of 0 will never be selected by</span><br><span class="hljs-comment"># Redis Sentinel for promotion.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default the priority is 100.</span><br><span class="hljs-attribute">replica</span>-priority <span class="hljs-number">100</span><br><br><span class="hljs-comment"># It is possible for a master to stop accepting writes if there are less than</span><br><span class="hljs-comment"># N replicas connected, having a lag less or equal than M seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The N replicas need to be in &quot;online&quot; state.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span><br><span class="hljs-comment"># the last ping received from the replica, that is usually sent every second.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This option does not GUARANTEE that N replicas will accept the write, but</span><br><span class="hljs-comment"># will limit the window of exposure for lost writes in case not enough replicas</span><br><span class="hljs-comment"># are available, to the specified number of seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example to require at least 3 replicas with a lag &lt;= 10 seconds use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># min-replicas-to-write 3</span><br><span class="hljs-comment"># min-replicas-max-lag 10</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Setting one or the other to 0 disables the feature.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default min-replicas-to-write is set to 0 (feature disabled) and</span><br><span class="hljs-comment"># min-replicas-max-lag is set to 10.</span><br><br><span class="hljs-comment"># A Redis master is able to list the address and port of the attached</span><br><span class="hljs-comment"># replicas in different ways. For example the &quot;INFO replication&quot; section</span><br><span class="hljs-comment"># offers this information, which is used, among other tools, by</span><br><span class="hljs-comment"># Redis Sentinel in order to discover replica instances.</span><br><span class="hljs-comment"># Another place where this info is available is in the output of the</span><br><span class="hljs-comment"># &quot;ROLE&quot; command of a master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The listed IP and address normally reported by a replica is obtained</span><br><span class="hljs-comment"># in the following way:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   IP: The address is auto detected by checking the peer address</span><br><span class="hljs-comment">#   of the socket used by the replica to connect with the master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   Port: The port is communicated by the replica during the replication</span><br><span class="hljs-comment">#   handshake, and is normally the port that the replica is using to</span><br><span class="hljs-comment">#   listen for connections.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However when port forwarding or Network Address Translation (NAT) is</span><br><span class="hljs-comment"># used, the replica may be actually reachable via different IP and port</span><br><span class="hljs-comment"># pairs. The following two options can be used by a replica in order to</span><br><span class="hljs-comment"># report to its master a specific set of IP and port, so that both INFO</span><br><span class="hljs-comment"># and ROLE will report those values.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># There is no need to use both the options if you need to override just</span><br><span class="hljs-comment"># the port or the IP address.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># replica-announce-ip 5.5.5.5</span><br><span class="hljs-comment"># replica-announce-port 1234</span><br><br><span class="hljs-comment">############################### KEYS TRACKING #################################</span><br><br><span class="hljs-comment"># Redis implements server assisted support for client side caching of values.</span><br><span class="hljs-comment"># This is implemented using an invalidation table that remembers, using</span><br><span class="hljs-comment"># 16 millions of slots, what clients may have certain subsets of keys. In turn</span><br><span class="hljs-comment"># this is used in order to send invalidation messages to clients. Please</span><br><span class="hljs-comment"># to understand more about the feature check this page:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   https://redis.io/topics/client-side-caching</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When tracking is enabled for a client, all the read only queries are assumed</span><br><span class="hljs-comment"># to be cached: this will force Redis to store information in the invalidation</span><br><span class="hljs-comment"># table. When keys are modified, such information is flushed away, and</span><br><span class="hljs-comment"># invalidation messages are sent to the clients. However if the workload is</span><br><span class="hljs-comment"># heavily dominated by reads, Redis could use more and more memory in order</span><br><span class="hljs-comment"># to track the keys fetched by many clients.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For this reason it is possible to configure a maximum fill value for the</span><br><span class="hljs-comment"># invalidation table. By default it is set to 1M of keys, and once this limit</span><br><span class="hljs-comment"># is reached, Redis will start to evict keys in the invalidation table</span><br><span class="hljs-comment"># even if they were not modified, just to reclaim memory: this will in turn</span><br><span class="hljs-comment"># force the clients to invalidate the cached values. Basically the table</span><br><span class="hljs-comment"># maximum size is a trade off between the memory you want to spend server</span><br><span class="hljs-comment"># side to track information about who cached what, and the ability of clients</span><br><span class="hljs-comment"># to retain cached objects in memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you set the value to 0, it means there are no limits, and Redis will</span><br><span class="hljs-comment"># retain as many keys as needed in the invalidation table.</span><br><span class="hljs-comment"># In the &quot;stats&quot; INFO section, you can find information about the number of</span><br><span class="hljs-comment"># keys in the invalidation table at every given moment.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> when key tracking is used in broadcasting mode, no memory is used</span><br><span class="hljs-comment"># in the server side so this setting is useless.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># tracking-table-max-keys 1000000</span><br><br><span class="hljs-comment">################################## SECURITY ###################################</span><br><br><span class="hljs-comment"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="hljs-comment"># 1 million passwords per second against a modern box. This means that you</span><br><span class="hljs-comment"># should use very strong passwords, otherwise they will be very easy to break.</span><br><span class="hljs-comment"># Note that because the password is really a shared secret between the client</span><br><span class="hljs-comment"># and the server, and should not be memorized by any human, the password</span><br><span class="hljs-comment"># can be easily a long string from /dev/urandom or whatever, so by using a</span><br><span class="hljs-comment"># long and unguessable password no brute force attack will be possible.</span><br><br><span class="hljs-comment"># Redis ACL users are defined in the following format:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user &lt;username&gt; ... acl rules ...</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The special username &quot;default&quot; is used for new connections. If this user</span><br><span class="hljs-comment"># has the &quot;nopass&quot; rule, then new connections will be immediately authenticated</span><br><span class="hljs-comment"># as the &quot;default&quot; user without the need of any password provided via the</span><br><span class="hljs-comment"># AUTH command. Otherwise if the &quot;default&quot; user is not flagged with &quot;nopass&quot;</span><br><span class="hljs-comment"># the connections will start in not authenticated state, and will require</span><br><span class="hljs-comment"># AUTH (or the HELLO command AUTH option) in order to be authenticated and</span><br><span class="hljs-comment"># start to work.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The ACL rules that describe what an user can do are the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  on           Enable the user: it is possible to authenticate as this user.</span><br><span class="hljs-comment">#  off          Disable the user: it&#x27;s no longer possible to authenticate</span><br><span class="hljs-comment">#               with this user, however the already authenticated connections</span><br><span class="hljs-comment">#               will still work.</span><br><span class="hljs-comment">#  +&lt;command&gt;   Allow the execution of that command</span><br><span class="hljs-comment">#  -&lt;command&gt;   Disallow the execution of that command</span><br><span class="hljs-comment">#  +@&lt;category&gt; Allow the execution of all the commands in such category</span><br><span class="hljs-comment">#               with valid categories are like @admin, @set, @sortedset, ...</span><br><span class="hljs-comment">#               and so forth, see the full list in the server.c file where</span><br><span class="hljs-comment">#               the Redis command table is described and defined.</span><br><span class="hljs-comment">#               The special category @all means all the commands, but currently</span><br><span class="hljs-comment">#               present in the server, and that will be loaded in the future</span><br><span class="hljs-comment">#               via modules.</span><br><span class="hljs-comment">#  +&lt;command&gt;|subcommand    Allow a specific subcommand of an otherwise</span><br><span class="hljs-comment">#                           disabled command. Note that this form is not</span><br><span class="hljs-comment">#                           allowed as negative like -DEBUG|SEGFAULT, but</span><br><span class="hljs-comment">#                           only additive starting with &quot;+&quot;.</span><br><span class="hljs-comment">#  allcommands  Alias for +@all. Note that it implies the ability to execute</span><br><span class="hljs-comment">#               all the future commands loaded via the modules system.</span><br><span class="hljs-comment">#  nocommands   Alias for -@all.</span><br><span class="hljs-comment">#  ~&lt;pattern&gt;   Add a pattern of keys that can be mentioned as part of</span><br><span class="hljs-comment">#               commands. For instance ~* allows all the keys. The pattern</span><br><span class="hljs-comment">#               is a glob-style pattern like the one of KEYS.</span><br><span class="hljs-comment">#               It is possible to specify multiple patterns.</span><br><span class="hljs-comment">#  allkeys      Alias for ~*</span><br><span class="hljs-comment">#  resetkeys    Flush the list of allowed keys patterns.</span><br><span class="hljs-comment">#  &gt;&lt;password&gt;  Add this passowrd to the list of valid password for the user.</span><br><span class="hljs-comment">#               For example &gt;mypass will add &quot;mypass&quot; to the list.</span><br><span class="hljs-comment">#               This directive clears the &quot;nopass&quot; flag (see later).</span><br><span class="hljs-comment">#  &lt;&lt;password&gt;  Remove this password from the list of valid passwords.</span><br><span class="hljs-comment">#  nopass       All the set passwords of the user are removed, and the user</span><br><span class="hljs-comment">#               is flagged as requiring no password: it means that every</span><br><span class="hljs-comment">#               password will work against this user. If this directive is</span><br><span class="hljs-comment">#               used for the default user, every new connection will be</span><br><span class="hljs-comment">#               immediately authenticated with the default user without</span><br><span class="hljs-comment">#               any explicit AUTH command required. Note that the &quot;resetpass&quot;</span><br><span class="hljs-comment">#               directive will clear this condition.</span><br><span class="hljs-comment">#  resetpass    Flush the list of allowed passwords. Moreover removes the</span><br><span class="hljs-comment">#               &quot;nopass&quot; status. After &quot;resetpass&quot; the user has no associated</span><br><span class="hljs-comment">#               passwords and there is no way to authenticate without adding</span><br><span class="hljs-comment">#               some password (or setting it as &quot;nopass&quot; later).</span><br><span class="hljs-comment">#  reset        Performs the following actions: resetpass, resetkeys, off,</span><br><span class="hljs-comment">#               -@all. The user returns to the same state it has immediately</span><br><span class="hljs-comment">#               after its creation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ACL rules can be specified in any order: for instance you can start with</span><br><span class="hljs-comment"># passwords, then flags, or key patterns. However note that the additive</span><br><span class="hljs-comment"># and subtractive rules will CHANGE MEANING depending on the ordering.</span><br><span class="hljs-comment"># For instance see the following example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user alice on +@all -DEBUG ~* &gt;somepassword</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This will allow &quot;alice&quot; to use all the commands with the exception of the</span><br><span class="hljs-comment"># DEBUG command, since +@all added all the commands to the set of the commands</span><br><span class="hljs-comment"># alice can use, and later DEBUG was removed. However if we invert the order</span><br><span class="hljs-comment"># of two ACL rules the result will be different:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   user alice on -DEBUG +@all ~* &gt;somepassword</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Now DEBUG was removed when alice had yet no commands in the set of allowed</span><br><span class="hljs-comment"># commands, later all the commands are added, so the user will be able to</span><br><span class="hljs-comment"># execute everything.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Basically ACL rules are processed left-to-right.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information about ACL configuration please refer to</span><br><span class="hljs-comment"># the Redis web site at https://redis.io/topics/acl</span><br><br><span class="hljs-comment"># ACL LOG</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The ACL Log tracks failed commands and authentication events associated</span><br><span class="hljs-comment"># with ACLs. The ACL Log is useful to troubleshoot failed commands blocked </span><br><span class="hljs-comment"># by ACLs. The ACL Log is stored in memory. You can reclaim memory with </span><br><span class="hljs-comment"># ACL LOG RESET. Define the maximum entry length of the ACL Log below.</span><br><span class="hljs-attribute">acllog</span>-max-len <span class="hljs-number">128</span><br><br><span class="hljs-comment"># Using an external ACL file</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Instead of configuring users here in this file, it is possible to use</span><br><span class="hljs-comment"># a stand-alone file just listing users. The two methods cannot be mixed:</span><br><span class="hljs-comment"># if you configure users here and at the same time you activate the exteranl</span><br><span class="hljs-comment"># ACL file, the server will refuse to start.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The format of the external ACL user file is exactly the same as the</span><br><span class="hljs-comment"># format that is used inside redis.conf to describe users.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># aclfile /etc/redis/users.acl</span><br><br><span class="hljs-comment"># IMPORTANT NOTE: starting with Redis 6 &quot;requirepass&quot; is just a compatiblity</span><br><span class="hljs-comment"># layer on top of the new ACL system. The option effect will be just setting</span><br><span class="hljs-comment"># the password for the default user. Clients will still authenticate using</span><br><span class="hljs-comment"># AUTH &lt;password&gt; as usually, or more explicitly with AUTH default &lt;password&gt;</span><br><span class="hljs-comment"># if they follow the new protocol: both will work.</span><br><span class="hljs-comment">#</span><br><span class="hljs-attribute">requirepass</span> zxvf666<br><br><span class="hljs-comment"># Command renaming (DEPRECATED).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># ------------------------------------------------------------------------</span><br><span class="hljs-comment"># WARNING: avoid using this option if possible. Instead use ACLs to remove</span><br><span class="hljs-comment"># commands from the default user, and put them only in some admin user you</span><br><span class="hljs-comment"># create for administrative purposes.</span><br><span class="hljs-comment"># ------------------------------------------------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is possible to change the name of dangerous commands in a shared</span><br><span class="hljs-comment"># environment. For instance the CONFIG command may be renamed into something</span><br><span class="hljs-comment"># hard to guess so that it will still be available for internal-use tools</span><br><span class="hljs-comment"># but not available for general clients.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is also possible to completely kill a command by renaming it into</span><br><span class="hljs-comment"># an empty string:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># rename-command CONFIG &quot;&quot;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Please note that changing the name of commands that are logged into the</span><br><span class="hljs-comment"># AOF file or transmitted to replicas may cause problems.</span><br><br><span class="hljs-comment">################################### CLIENTS ####################################</span><br><br><span class="hljs-comment"># Set the max number of connected clients at the same time. By default</span><br><span class="hljs-comment"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="hljs-comment"># able to configure the process file limit to allow for the specified limit</span><br><span class="hljs-comment"># the max number of allowed clients is set to the current file limit</span><br><span class="hljs-comment"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="hljs-comment"># an error &#x27;max number of clients reached&#x27;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># IMPORTANT: When Redis Cluster is used, the max number of connections is also</span><br><span class="hljs-comment"># shared with the cluster bus: every node in the cluster will use two</span><br><span class="hljs-comment"># connections, one incoming and another outgoing. It is important to size the</span><br><span class="hljs-comment"># limit accordingly in case of very large clusters.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxclients 10000</span><br><br><span class="hljs-comment">############################## MEMORY MANAGEMENT ################################</span><br><br><span class="hljs-comment"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="hljs-comment"># When the memory limit is reached Redis will try to remove keys</span><br><span class="hljs-comment"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="hljs-comment"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="hljs-comment"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="hljs-comment"># to reply to read-only commands like GET.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="hljs-comment"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="hljs-comment"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="hljs-comment"># from the used memory count, so that network problems / resyncs will</span><br><span class="hljs-comment"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="hljs-comment"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="hljs-comment"># of more keys, and so forth until the database is completely emptied.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="hljs-comment"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="hljs-comment"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxmemory &lt;bytes&gt;</span><br><br><span class="hljs-comment"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="hljs-comment"># is reached. You can select one from the following behaviors:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set.</span><br><span class="hljs-comment"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="hljs-comment"># volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set.</span><br><span class="hljs-comment"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="hljs-comment"># volatile-random -&gt; Remove a random key having an expire set.</span><br><span class="hljs-comment"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="hljs-comment"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="hljs-comment"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># LRU means Least Recently Used</span><br><span class="hljs-comment"># LFU means Least Frequently Used</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="hljs-comment"># randomized algorithms.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> with any of the above policies, Redis will return an error on write</span><br><span class="hljs-comment">#       operations, when there are no suitable keys for eviction.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#       At the date of writing these commands are: set setnx setex append</span><br><span class="hljs-comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="hljs-comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="hljs-comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="hljs-comment">#       getset mset msetnx exec sort</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default is:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxmemory-policy noeviction</span><br><br><span class="hljs-comment"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="hljs-comment"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="hljs-comment"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="hljs-comment"># used less recently, you can change the sample size using the following</span><br><span class="hljs-comment"># configuration directive.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="hljs-comment"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># maxmemory-samples 5</span><br><br><span class="hljs-comment"># Starting from Redis 5, by default a replica will ignore its maxmemory setting</span><br><span class="hljs-comment"># (unless it is promoted to master after a failover or manually). It means</span><br><span class="hljs-comment"># that the eviction of keys will be just handled by the master, sending the</span><br><span class="hljs-comment"># DEL commands to the replica as keys evict in the master side.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This behavior ensures that masters and replicas stay consistent, and is usually</span><br><span class="hljs-comment"># what you want, however if your replica is writable, or you want the replica</span><br><span class="hljs-comment"># to have a different memory setting, and you are sure all the writes performed</span><br><span class="hljs-comment"># to the replica are idempotent, then you may change this default (but be sure</span><br><span class="hljs-comment"># to understand what you are doing).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that since the replica by default does not evict, it may end using more</span><br><span class="hljs-comment"># memory than the one set via maxmemory (there are certain buffers that may</span><br><span class="hljs-comment"># be larger on the replica, or data structures may sometimes take more memory</span><br><span class="hljs-comment"># and so forth). So make sure you monitor your replicas and make sure they</span><br><span class="hljs-comment"># have enough memory to never hit a real out-of-memory condition before the</span><br><span class="hljs-comment"># master hits the configured maxmemory setting.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># replica-ignore-maxmemory yes</span><br><br><span class="hljs-comment"># Redis reclaims expired keys in two ways: upon access when those keys are</span><br><span class="hljs-comment"># found to be expired, and also in background, in what is called the</span><br><span class="hljs-comment"># &quot;active expire key&quot;. The key space is slowly and interactively scanned</span><br><span class="hljs-comment"># looking for expired keys to reclaim, so that it is possible to free memory</span><br><span class="hljs-comment"># of keys that are expired and will never be accessed again in a short time.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default effort of the expire cycle will try to avoid having more than</span><br><span class="hljs-comment"># ten percent of expired keys still in memory, and will try to avoid consuming</span><br><span class="hljs-comment"># more than 25% of total memory and to add latency to the system. However</span><br><span class="hljs-comment"># it is possible to increase the expire &quot;effort&quot; that is normally set to</span><br><span class="hljs-comment"># &quot;1&quot;, to a greater value, up to the value &quot;10&quot;. At its maximum value the</span><br><span class="hljs-comment"># system will use more CPU, longer cycles (and technically may introduce</span><br><span class="hljs-comment"># more latency), and will tollerate less already expired keys still present</span><br><span class="hljs-comment"># in the system. It&#x27;s a tradeoff betweeen memory, CPU and latecy.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># active-expire-effort 1</span><br><br><span class="hljs-comment">############################# LAZY FREEING ####################################</span><br><br><span class="hljs-comment"># Redis has two primitives to delete keys. One is called DEL and is a blocking</span><br><span class="hljs-comment"># deletion of the object. It means that the server stops processing new commands</span><br><span class="hljs-comment"># in order to reclaim all the memory associated with an object in a synchronous</span><br><span class="hljs-comment"># way. If the key deleted is associated with a small object, the time needed</span><br><span class="hljs-comment"># in order to execute the DEL command is very small and comparable to most other</span><br><span class="hljs-comment"># O(1) or O(log_N) commands in Redis. However if the key is associated with an</span><br><span class="hljs-comment"># aggregated value containing millions of elements, the server can block for</span><br><span class="hljs-comment"># a long time (even seconds) in order to complete the operation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For the above reasons Redis also offers non blocking deletion primitives</span><br><span class="hljs-comment"># such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and</span><br><span class="hljs-comment"># FLUSHDB commands, in order to reclaim memory in background. Those commands</span><br><span class="hljs-comment"># are executed in constant time. Another thread will incrementally free the</span><br><span class="hljs-comment"># object in the background as fast as possible.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.</span><br><span class="hljs-comment"># It&#x27;s up to the design of the application to understand when it is a good</span><br><span class="hljs-comment"># idea to use one or the other. However the Redis server sometimes has to</span><br><span class="hljs-comment"># delete keys or flush the whole database as a side effect of other operations.</span><br><span class="hljs-comment"># Specifically Redis deletes objects independently of a user call in the</span><br><span class="hljs-comment"># following scenarios:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) On eviction, because of the maxmemory and maxmemory policy configurations,</span><br><span class="hljs-comment">#    in order to make room for new data, without going over the specified</span><br><span class="hljs-comment">#    memory limit.</span><br><span class="hljs-comment"># 2) Because of expire: when a key with an associated time to live (see the</span><br><span class="hljs-comment">#    EXPIRE command) must be deleted from memory.</span><br><span class="hljs-comment"># 3) Because of a side effect of a command that stores data on a key that may</span><br><span class="hljs-comment">#    already exist. For example the RENAME command may delete the old key</span><br><span class="hljs-comment">#    content when it is replaced with another one. Similarly SUNIONSTORE</span><br><span class="hljs-comment">#    or SORT with STORE option may delete existing keys. The SET command</span><br><span class="hljs-comment">#    itself removes any old content of the specified key in order to replace</span><br><span class="hljs-comment">#    it with the specified string.</span><br><span class="hljs-comment"># 4) During replication, when a replica performs a full resynchronization with</span><br><span class="hljs-comment">#    its master, the content of the whole database is removed in order to</span><br><span class="hljs-comment">#    load the RDB file just transferred.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In all the above cases the default is to delete objects in a blocking way,</span><br><span class="hljs-comment"># like if DEL was called. However you can configure each case specifically</span><br><span class="hljs-comment"># in order to instead release memory in a non-blocking way like if UNLINK</span><br><span class="hljs-comment"># was called, using the following configuration directives.</span><br><br><span class="hljs-attribute">lazyfree</span>-lazy-eviction no<br><span class="hljs-attribute">lazyfree</span>-lazy-expire no<br><span class="hljs-attribute">lazyfree</span>-lazy-server-del no<br><span class="hljs-attribute">replica</span>-lazy-flush no<br><br><span class="hljs-comment"># It is also possible, for the case when to replace the user code DEL calls</span><br><span class="hljs-comment"># with UNLINK calls is not easy, to modify the default behavior of the DEL</span><br><span class="hljs-comment"># command to act exactly like UNLINK, using the following configuration</span><br><span class="hljs-comment"># directive:</span><br><br><span class="hljs-attribute">lazyfree</span>-lazy-user-del no<br><br><span class="hljs-comment">################################ THREADED I/O #################################</span><br><br><span class="hljs-comment"># Redis is mostly single threaded, however there are certain threaded</span><br><span class="hljs-comment"># operations such as UNLINK, slow I/O accesses and other things that are</span><br><span class="hljs-comment"># performed on side threads.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Now it is also possible to handle Redis clients socket reads and writes</span><br><span class="hljs-comment"># in different I/O threads. Since especially writing is so slow, normally</span><br><span class="hljs-comment"># Redis users use pipelining in order to speedup the Redis performances per</span><br><span class="hljs-comment"># core, and spawn multiple instances in order to scale more. Using I/O</span><br><span class="hljs-comment"># threads it is possible to easily speedup two times Redis without resorting</span><br><span class="hljs-comment"># to pipelining nor sharding of the instance.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default threading is disabled, we suggest enabling it only in machines</span><br><span class="hljs-comment"># that have at least 4 or more cores, leaving at least one spare core.</span><br><span class="hljs-comment"># Using more than 8 threads is unlikely to help much. We also recommend using</span><br><span class="hljs-comment"># threaded I/O only if you actually have performance problems, with Redis</span><br><span class="hljs-comment"># instances being able to use a quite big percentage of CPU time, otherwise</span><br><span class="hljs-comment"># there is no point in using this feature.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span><br><span class="hljs-comment"># threads, if you have a 8 cores, try to use 6 threads. In order to</span><br><span class="hljs-comment"># enable I/O threads use the following configuration directive:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># io-threads 4</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Setting io-threads to 1 will just use the main thread as usually.</span><br><span class="hljs-comment"># When I/O threads are enabled, we only use threads for writes, that is</span><br><span class="hljs-comment"># to thread the write(2) syscall and transfer the client buffers to the</span><br><span class="hljs-comment"># socket. However it is also possible to enable threading of reads and</span><br><span class="hljs-comment"># protocol parsing using the following configuration directive, by setting</span><br><span class="hljs-comment"># it to yes:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># io-threads-do-reads no</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Usually threading reads doesn&#x27;t help much.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NOTE 1: This configuration directive cannot be changed at runtime via</span><br><span class="hljs-comment"># CONFIG SET. Aso this feature currently does not work when SSL is</span><br><span class="hljs-comment"># enabled.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span><br><span class="hljs-comment"># sure you also run the benchmark itself in threaded mode, using the</span><br><span class="hljs-comment"># --threads option to match the number of Redis theads, otherwise you&#x27;ll not</span><br><span class="hljs-comment"># be able to notice the improvements.</span><br><br><span class="hljs-comment">############################ KERNEL OOM CONTROL ##############################</span><br><br><span class="hljs-comment"># On Linux, it is possible to hint the kernel OOM killer on what processes</span><br><span class="hljs-comment"># should be killed first when out of memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Enabling this feature makes Redis actively control the oom_score_adj value</span><br><span class="hljs-comment"># for all its processes, depending on their role. The default scores will</span><br><span class="hljs-comment"># attempt to have background child processes killed before all others, and</span><br><span class="hljs-comment"># replicas killed before masters.</span><br><br><span class="hljs-attribute">oom</span>-score-adj no<br><br><span class="hljs-comment"># When oom-score-adj is used, this directive controls the specific values used</span><br><span class="hljs-comment"># for master, replica and background child processes. Values range -1000 to</span><br><span class="hljs-comment"># 1000 (higher means more likely to be killed).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)</span><br><span class="hljs-comment"># can freely increase their value, but not decrease it below its initial</span><br><span class="hljs-comment"># settings.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Values are used relative to the initial value of oom_score_adj when the server</span><br><span class="hljs-comment"># starts. Because typically the initial value is 0, they will often match the</span><br><span class="hljs-comment"># absolute values.</span><br><br><span class="hljs-attribute">oom</span>-score-adj-values <span class="hljs-number">0</span> <span class="hljs-number">200</span> <span class="hljs-number">800</span><br><br><span class="hljs-comment">############################## APPEND ONLY MODE ###############################</span><br><br><span class="hljs-comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="hljs-comment"># good enough in many applications, but an issue with the Redis process or</span><br><span class="hljs-comment"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="hljs-comment"># the configured save points).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Append Only File is an alternative persistence mode that provides</span><br><span class="hljs-comment"># much better durability. For instance using the default data fsync policy</span><br><span class="hljs-comment"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="hljs-comment"># dramatic event like a server power outage, or a single write if something</span><br><span class="hljs-comment"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="hljs-comment"># still running correctly.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="hljs-comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="hljs-comment"># with the better durability guarantees.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Please check http://redis.io/topics/persistence for more information.</span><br><br><span class="hljs-attribute">appendonly</span> no<br><br><span class="hljs-comment"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><br><span class="hljs-attribute">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br><span class="hljs-comment"># The fsync() call tells the Operating System to actually write data on disk</span><br><span class="hljs-comment"># instead of waiting for more data in the output buffer. Some OS will really flush</span><br><span class="hljs-comment"># data on disk, some other OS will just try to do it ASAP.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Redis supports three different modes:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.</span><br><span class="hljs-comment"># always: fsync after every write to the append only log. Slow, Safest.</span><br><span class="hljs-comment"># everysec: fsync only one time every second. Compromise.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between</span><br><span class="hljs-comment"># speed and data safety. It&#x27;s up to you to understand if you can relax this to</span><br><span class="hljs-comment"># &quot;no&quot; that will let the operating system flush the output buffer when</span><br><span class="hljs-comment"># it wants, for better performances (but if you can live with the idea of</span><br><span class="hljs-comment"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="hljs-comment"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="hljs-comment"># everysec.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># More details please check the following article:</span><br><span class="hljs-comment"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If unsure, use &quot;everysec&quot;.</span><br><br><span class="hljs-comment"># appendfsync always</span><br><span class="hljs-attribute">appendfsync</span> everysec<br><span class="hljs-comment"># appendfsync no</span><br><br><span class="hljs-comment"># When the AOF fsync policy is set to always or everysec, and a background</span><br><span class="hljs-comment"># saving process (a background save or AOF log background rewriting) is</span><br><span class="hljs-comment"># performing a lot of I/O against the disk, in some Linux configurations</span><br><span class="hljs-comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span><br><span class="hljs-comment"># this currently, as even performing fsync in a different thread will block</span><br><span class="hljs-comment"># our synchronous write(2) call.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In order to mitigate this problem it&#x27;s possible to use the following option</span><br><span class="hljs-comment"># that will prevent fsync() from being called in the main process while a</span><br><span class="hljs-comment"># BGSAVE or BGREWRITEAOF is in progress.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This means that while another child is saving, the durability of Redis is</span><br><span class="hljs-comment"># the same as &quot;appendfsync none&quot;. In practical terms, this means that it is</span><br><span class="hljs-comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span><br><span class="hljs-comment"># default Linux settings).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as</span><br><span class="hljs-comment"># &quot;no&quot; that is the safest pick from the point of view of durability.</span><br><br><span class="hljs-attribute">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite no<br><br><span class="hljs-comment"># Automatic rewrite of the append only file.</span><br><span class="hljs-comment"># Redis is able to automatically rewrite the log file implicitly calling</span><br><span class="hljs-comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is how it works: Redis remembers the size of the AOF file after the</span><br><span class="hljs-comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span><br><span class="hljs-comment"># the AOF at startup is used).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This base size is compared to the current size. If the current size is</span><br><span class="hljs-comment"># bigger than the specified percentage, the rewrite is triggered. Also</span><br><span class="hljs-comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span><br><span class="hljs-comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span><br><span class="hljs-comment"># is reached but it is still pretty small.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Specify a percentage of zero in order to disable the automatic AOF</span><br><span class="hljs-comment"># rewrite feature.</span><br><br><span class="hljs-attribute">auto</span>-aof-rewrite-percentage <span class="hljs-number">100</span><br><span class="hljs-attribute">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>mb<br><br><span class="hljs-comment"># An AOF file may be found to be truncated at the end during the Redis</span><br><span class="hljs-comment"># startup process, when the AOF data gets loaded back into memory.</span><br><span class="hljs-comment"># This may happen when the system where Redis is running</span><br><span class="hljs-comment"># crashes, especially when an ext4 filesystem is mounted without the</span><br><span class="hljs-comment"># data=ordered option (however this can&#x27;t happen when Redis itself</span><br><span class="hljs-comment"># crashes or aborts but the operating system still works correctly).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Redis can either exit with an error when this happens, or load as much</span><br><span class="hljs-comment"># data as possible (the default now) and start if the AOF file is found</span><br><span class="hljs-comment"># to be truncated at the end. The following option controls this behavior.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If aof-load-truncated is set to yes, a truncated AOF file is loaded and</span><br><span class="hljs-comment"># the Redis server starts emitting a log to inform the user of the event.</span><br><span class="hljs-comment"># Otherwise if the option is set to no, the server aborts with an error</span><br><span class="hljs-comment"># and refuses to start. When the option is set to no, the user requires</span><br><span class="hljs-comment"># to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart</span><br><span class="hljs-comment"># the server.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that if the AOF file will be found to be corrupted in the middle</span><br><span class="hljs-comment"># the server will still exit with an error. This option only applies when</span><br><span class="hljs-comment"># Redis will try to read more data from the AOF file but not enough bytes</span><br><span class="hljs-comment"># will be found.</span><br><span class="hljs-attribute">aof</span>-load-truncated yes<br><br><span class="hljs-comment"># When rewriting the AOF file, Redis is able to use an RDB preamble in the</span><br><span class="hljs-comment"># AOF file for faster rewrites and recoveries. When this option is turned</span><br><span class="hljs-comment"># on the rewritten AOF file is composed of two different stanzas:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   [RDB file][AOF tail]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;</span><br><span class="hljs-comment"># string and loads the prefixed RDB file, and continues loading the AOF</span><br><span class="hljs-comment"># tail.</span><br><span class="hljs-attribute">aof</span>-use-rdb-preamble yes<br><br><span class="hljs-comment">################################ LUA SCRIPTING  ###############################</span><br><br><span class="hljs-comment"># Max execution time of a Lua script in milliseconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If the maximum execution time is reached Redis will log that a script is</span><br><span class="hljs-comment"># still in execution after the maximum allowed time and will start to</span><br><span class="hljs-comment"># reply to queries with an error.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When a long running script exceeds the maximum execution time only the</span><br><span class="hljs-comment"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span><br><span class="hljs-comment"># used to stop a script that did not yet called write commands. The second</span><br><span class="hljs-comment"># is the only way to shut down the server in the case a write command was</span><br><span class="hljs-comment"># already issued by the script but the user doesn&#x27;t want to wait for the natural</span><br><span class="hljs-comment"># termination of the script.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set it to 0 or a negative value for unlimited execution without warnings.</span><br><span class="hljs-attribute">lua</span>-time-limit <span class="hljs-number">5000</span><br><br><span class="hljs-comment">################################ REDIS CLUSTER  ###############################</span><br><br><span class="hljs-comment"># Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are</span><br><span class="hljs-comment"># started as cluster nodes can. In order to start a Redis instance as a</span><br><span class="hljs-comment"># cluster node enable the cluster support uncommenting the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-enabled yes</span><br><br><span class="hljs-comment"># Every cluster node has a cluster configuration file. This file is not</span><br><span class="hljs-comment"># intended to be edited by hand. It is created and updated by Redis nodes.</span><br><span class="hljs-comment"># Every Redis Cluster node requires a different cluster configuration file.</span><br><span class="hljs-comment"># Make sure that instances running in the same system do not have</span><br><span class="hljs-comment"># overlapping cluster configuration file names.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-config-file nodes-6379.conf</span><br><br><span class="hljs-comment"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span><br><span class="hljs-comment"># for it to be considered in failure state.</span><br><span class="hljs-comment"># Most other internal time limits are multiple of the node timeout.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-node-timeout 15000</span><br><br><span class="hljs-comment"># A replica of a failing master will avoid to start a failover if its data</span><br><span class="hljs-comment"># looks too old.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># There is no simple way for a replica to actually have an exact measure of</span><br><span class="hljs-comment"># its &quot;data age&quot;, so the following two checks are performed:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1) If there are multiple replicas able to failover, they exchange messages</span><br><span class="hljs-comment">#    in order to try to give an advantage to the replica with the best</span><br><span class="hljs-comment">#    replication offset (more data from the master processed).</span><br><span class="hljs-comment">#    Replicas will try to get their rank by offset, and apply to the start</span><br><span class="hljs-comment">#    of the failover a delay proportional to their rank.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2) Every single replica computes the time of the last interaction with</span><br><span class="hljs-comment">#    its master. This can be the last ping or command received (if the master</span><br><span class="hljs-comment">#    is still in the &quot;connected&quot; state), or the time that elapsed since the</span><br><span class="hljs-comment">#    disconnection with the master (if the replication link is currently down).</span><br><span class="hljs-comment">#    If the last interaction is too old, the replica will not try to failover</span><br><span class="hljs-comment">#    at all.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform</span><br><span class="hljs-comment"># the failover if, since the last interaction with the master, the time</span><br><span class="hljs-comment"># elapsed is greater than:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   (node-timeout * replica-validity-factor) + repl-ping-replica-period</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># So for example if node-timeout is 30 seconds, and the replica-validity-factor</span><br><span class="hljs-comment"># is 10, and assuming a default repl-ping-replica-period of 10 seconds, the</span><br><span class="hljs-comment"># replica will not try to failover if it was not able to talk with the master</span><br><span class="hljs-comment"># for longer than 310 seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A large replica-validity-factor may allow replicas with too old data to failover</span><br><span class="hljs-comment"># a master, while a too small value may prevent the cluster from being able to</span><br><span class="hljs-comment"># elect a replica at all.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For maximum availability, it is possible to set the replica-validity-factor</span><br><span class="hljs-comment"># to a value of 0, which means, that replicas will always try to failover the</span><br><span class="hljs-comment"># master regardless of the last time they interacted with the master.</span><br><span class="hljs-comment"># (However they&#x27;ll always try to apply a delay proportional to their</span><br><span class="hljs-comment"># offset rank).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Zero is the only value able to guarantee that when all the partitions heal</span><br><span class="hljs-comment"># the cluster will always be able to continue.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-replica-validity-factor 10</span><br><br><span class="hljs-comment"># Cluster replicas are able to migrate to orphaned masters, that are masters</span><br><span class="hljs-comment"># that are left without working replicas. This improves the cluster ability</span><br><span class="hljs-comment"># to resist to failures as otherwise an orphaned master can&#x27;t be failed over</span><br><span class="hljs-comment"># in case of failure if it has no working replicas.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Replicas migrate to orphaned masters only if there are still at least a</span><br><span class="hljs-comment"># given number of other working replicas for their old master. This number</span><br><span class="hljs-comment"># is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica</span><br><span class="hljs-comment"># will migrate only if there is at least 1 other working replica for its master</span><br><span class="hljs-comment"># and so forth. It usually reflects the number of replicas you want for every</span><br><span class="hljs-comment"># master in your cluster.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Default is 1 (replicas migrate only if their masters remain with at least</span><br><span class="hljs-comment"># one replica). To disable migration just set it to a very large value.</span><br><span class="hljs-comment"># A value of 0 can be set but is useful only for debugging and dangerous</span><br><span class="hljs-comment"># in production.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-migration-barrier 1</span><br><br><span class="hljs-comment"># By default Redis Cluster nodes stop accepting queries if they detect there</span><br><span class="hljs-comment"># is at least an hash slot uncovered (no available node is serving it).</span><br><span class="hljs-comment"># This way if the cluster is partially down (for example a range of hash slots</span><br><span class="hljs-comment"># are no longer covered) all the cluster becomes, eventually, unavailable.</span><br><span class="hljs-comment"># It automatically returns available as soon as all the slots are covered again.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However sometimes you want the subset of the cluster which is working,</span><br><span class="hljs-comment"># to continue to accept queries for the part of the key space that is still</span><br><span class="hljs-comment"># covered. In order to do so, just set the cluster-require-full-coverage</span><br><span class="hljs-comment"># option to no.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-require-full-coverage yes</span><br><br><span class="hljs-comment"># This option, when set to yes, prevents replicas from trying to failover its</span><br><span class="hljs-comment"># master during master failures. However the master can still perform a</span><br><span class="hljs-comment"># manual failover, if forced to do so.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is useful in different scenarios, especially in the case of multiple</span><br><span class="hljs-comment"># data center operations, where we want one side to never be promoted if not</span><br><span class="hljs-comment"># in the case of a total DC failure.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-replica-no-failover no</span><br><br><span class="hljs-comment"># This option, when set to yes, allows nodes to serve read traffic while the</span><br><span class="hljs-comment"># the cluster is in a down state, as long as it believes it owns the slots. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is useful for two cases.  The first case is for when an application </span><br><span class="hljs-comment"># doesn&#x27;t require consistency of data during node failures or network partitions.</span><br><span class="hljs-comment"># One example of this is a cache, where as long as the node has the data it</span><br><span class="hljs-comment"># should be able to serve it. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The second use case is for configurations that don&#x27;t meet the recommended  </span><br><span class="hljs-comment"># three shards but want to enable cluster mode and scale later. A </span><br><span class="hljs-comment"># master outage in a 1 or 2 shard configuration causes a read/write outage to the</span><br><span class="hljs-comment"># entire cluster without this option set, with it set there is only a write outage.</span><br><span class="hljs-comment"># Without a quorum of masters, slot ownership will not change automatically. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-allow-reads-when-down no</span><br><br><span class="hljs-comment"># In order to setup your cluster make sure to read the documentation</span><br><span class="hljs-comment"># available at http://redis.io web site.</span><br><br><span class="hljs-comment">########################## CLUSTER DOCKER/NAT support  ########################</span><br><br><span class="hljs-comment"># In certain deployments, Redis Cluster nodes address discovery fails, because</span><br><span class="hljs-comment"># addresses are NAT-ted or because ports are forwarded (the typical case is</span><br><span class="hljs-comment"># Docker and other containers).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In order to make Redis Cluster working in such environments, a static</span><br><span class="hljs-comment"># configuration where each node knows its public address is needed. The</span><br><span class="hljs-comment"># following two options are used for this scope, and are:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># * cluster-announce-ip</span><br><span class="hljs-comment"># * cluster-announce-port</span><br><span class="hljs-comment"># * cluster-announce-bus-port</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Each instruct the node about its address, client port, and cluster message</span><br><span class="hljs-comment"># bus port. The information is then published in the header of the bus packets</span><br><span class="hljs-comment"># so that other nodes will be able to correctly map the address of the node</span><br><span class="hljs-comment"># publishing the information.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If the above options are not used, the normal Redis Cluster auto-detection</span><br><span class="hljs-comment"># will be used instead.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that when remapped, the bus port may not be at the fixed offset of</span><br><span class="hljs-comment"># clients port + 10000, so you can specify any port and bus-port depending</span><br><span class="hljs-comment"># on how they get remapped. If the bus-port is not set, a fixed offset of</span><br><span class="hljs-comment"># 10000 will be used as usually.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># cluster-announce-ip 10.1.1.5</span><br><span class="hljs-comment"># cluster-announce-port 6379</span><br><span class="hljs-comment"># cluster-announce-bus-port 6380</span><br><br><span class="hljs-comment">################################## SLOW LOG ###################################</span><br><br><span class="hljs-comment"># The Redis Slow Log is a system to log queries that exceeded a specified</span><br><span class="hljs-comment"># execution time. The execution time does not include the I/O operations</span><br><span class="hljs-comment"># like talking with the client, sending the reply and so forth,</span><br><span class="hljs-comment"># but just the time needed to actually execute the command (this is the only</span><br><span class="hljs-comment"># stage of command execution where the thread is blocked and can not serve</span><br><span class="hljs-comment"># other requests in the meantime).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># You can configure the slow log with two parameters: one tells Redis</span><br><span class="hljs-comment"># what is the execution time, in microseconds, to exceed in order for the</span><br><span class="hljs-comment"># command to get logged, and the other parameter is the length of the</span><br><span class="hljs-comment"># slow log. When a new command is logged the oldest one is removed from the</span><br><span class="hljs-comment"># queue of logged commands.</span><br><br><span class="hljs-comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span><br><span class="hljs-comment"># to one second. Note that a negative number disables the slow log, while</span><br><span class="hljs-comment"># a value of zero forces the logging of every command.</span><br><span class="hljs-attribute">slowlog</span>-log-slower-than <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># There is no limit to this length. Just be aware that it will consume memory.</span><br><span class="hljs-comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span><br><span class="hljs-attribute">slowlog</span>-max-len <span class="hljs-number">128</span><br><br><span class="hljs-comment">################################ LATENCY MONITOR ##############################</span><br><br><span class="hljs-comment"># The Redis latency monitoring subsystem samples different operations</span><br><span class="hljs-comment"># at runtime in order to collect data related to possible sources of</span><br><span class="hljs-comment"># latency of a Redis instance.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Via the LATENCY command this information is available to the user that can</span><br><span class="hljs-comment"># print graphs and obtain reports.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The system only logs operations that were performed in a time equal or</span><br><span class="hljs-comment"># greater than the amount of milliseconds specified via the</span><br><span class="hljs-comment"># latency-monitor-threshold configuration directive. When its value is set</span><br><span class="hljs-comment"># to zero, the latency monitor is turned off.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default latency monitoring is disabled since it is mostly not needed</span><br><span class="hljs-comment"># if you don&#x27;t have latency issues, and collecting data has a performance</span><br><span class="hljs-comment"># impact, that while very small, can be measured under big load. Latency</span><br><span class="hljs-comment"># monitoring can easily be enabled at runtime using the command</span><br><span class="hljs-comment"># &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.</span><br><span class="hljs-attribute">latency</span>-monitor-threshold <span class="hljs-number">0</span><br><br><span class="hljs-comment">############################# EVENT NOTIFICATION ##############################</span><br><br><span class="hljs-comment"># Redis can notify Pub/Sub clients about events happening in the key space.</span><br><span class="hljs-comment"># This feature is documented at http://redis.io/topics/notifications</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For instance if keyspace events notification is enabled, and a client</span><br><span class="hljs-comment"># performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two</span><br><span class="hljs-comment"># messages will be published via Pub/Sub:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># PUBLISH __keyspace@0__:foo del</span><br><span class="hljs-comment"># PUBLISH __keyevent@0__:del foo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># It is possible to select the events that Redis will notify among a set</span><br><span class="hljs-comment"># of classes. Every class is identified by a single character:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="hljs-comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="hljs-comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="hljs-comment">#  $     String commands</span><br><span class="hljs-comment">#  l     List commands</span><br><span class="hljs-comment">#  s     Set commands</span><br><span class="hljs-comment">#  h     Hash commands</span><br><span class="hljs-comment">#  z     Sorted set commands</span><br><span class="hljs-comment">#  x     Expired events (events generated every time a key expires)</span><br><span class="hljs-comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="hljs-comment">#  t     Stream commands</span><br><span class="hljs-comment">#  m     Key-miss events (<span class="hljs-doctag">Note:</span> It is not included in the &#x27;A&#x27; class)</span><br><span class="hljs-comment">#  A     Alias for g$lshzxet, so that the &quot;AKE&quot; string means all the events</span><br><span class="hljs-comment">#        (Except key-miss events which are excluded from &#x27;A&#x27; due to their</span><br><span class="hljs-comment">#         unique nature).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed</span><br><span class="hljs-comment">#  of zero or multiple characters. The empty string means that notifications</span><br><span class="hljs-comment">#  are disabled.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  Example: to enable list and generic events, from the point of view of the</span><br><span class="hljs-comment">#           event name, use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  notify-keyspace-events Elg</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class="hljs-comment">#             name __keyevent@0__:expired use:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  notify-keyspace-events Ex</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#  By default all notifications are disabled because most users don&#x27;t need</span><br><span class="hljs-comment">#  this feature and the feature has some overhead. Note that if you don&#x27;t</span><br><span class="hljs-comment">#  specify at least one of K or E, no events will be delivered.</span><br><span class="hljs-attribute">notify</span>-keyspace-events <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">############################### GOPHER SERVER #################################</span><br><br><span class="hljs-comment"># Redis contains an implementation of the Gopher protocol, as specified in</span><br><span class="hljs-comment"># the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Gopher protocol was very popular in the late &#x27;90s. It is an alternative</span><br><span class="hljs-comment"># to the web, and the implementation both server and client side is so simple</span><br><span class="hljs-comment"># that the Redis server has just 100 lines of code in order to implement this</span><br><span class="hljs-comment"># support.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># What do you do with Gopher nowadays? Well Gopher never *really* died, and</span><br><span class="hljs-comment"># lately there is a movement in order for the Gopher more hierarchical content</span><br><span class="hljs-comment"># composed of just plain text documents to be resurrected. Some want a simpler</span><br><span class="hljs-comment"># internet, others believe that the mainstream internet became too much</span><br><span class="hljs-comment"># controlled, and it&#x27;s cool to create an alternative space for people that</span><br><span class="hljs-comment"># want a bit of fresh air.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol</span><br><span class="hljs-comment"># as a gift.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># --- HOW IT WORKS? ---</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The Redis Gopher support uses the inline protocol of Redis, and specifically</span><br><span class="hljs-comment"># two kind of inline requests that were anyway illegal: an empty request</span><br><span class="hljs-comment"># or any request that starts with &quot;/&quot; (there are no Redis commands starting</span><br><span class="hljs-comment"># with such a slash). Normal RESP2/RESP3 requests are completely out of the</span><br><span class="hljs-comment"># path of the Gopher protocol implementation and are served as usually as well.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you open a connection to Redis when Gopher is enabled and send it</span><br><span class="hljs-comment"># a string like &quot;/foo&quot;, if there is a key named &quot;/foo&quot; it is served via the</span><br><span class="hljs-comment"># Gopher protocol.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># In order to create a real Gopher &quot;hole&quot; (the name of a Gopher site in Gopher</span><br><span class="hljs-comment"># talking), you likely need a script like the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   https://github.com/antirez/gopher2redis</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># --- SECURITY WARNING ---</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you plan to put Redis on the internet in a publicly accessible address</span><br><span class="hljs-comment"># to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.</span><br><span class="hljs-comment"># Once a password is set:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   1. The Gopher server (when enabled, not by default) will still serve</span><br><span class="hljs-comment">#      content via Gopher.</span><br><span class="hljs-comment">#   2. However other commands cannot be called before the client will</span><br><span class="hljs-comment">#      authenticate.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># So use the &#x27;requirepass&#x27; option to protect your instance.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To enable Gopher support uncomment the following line and set</span><br><span class="hljs-comment"># the option from no (the default) to yes.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># gopher-enabled no</span><br><br><span class="hljs-comment">############################### ADVANCED CONFIG ###############################</span><br><br><span class="hljs-comment"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="hljs-comment"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="hljs-comment"># threshold. These thresholds can be configured using the following directives.</span><br><span class="hljs-attribute">hash</span>-max-ziplist-entries <span class="hljs-number">512</span><br><span class="hljs-attribute">hash</span>-max-ziplist-value <span class="hljs-number">64</span><br><br><span class="hljs-comment"># Lists are also encoded in a special way to save a lot of space.</span><br><span class="hljs-comment"># The number of entries allowed per internal list node can be specified</span><br><span class="hljs-comment"># as a fixed maximum size or a maximum number of elements.</span><br><span class="hljs-comment"># For a fixed maximum size, use -5 through -1, meaning:</span><br><span class="hljs-comment"># -5: max size: 64 Kb  &lt;-- not recommended for normal workloads</span><br><span class="hljs-comment"># -4: max size: 32 Kb  &lt;-- not recommended</span><br><span class="hljs-comment"># -3: max size: 16 Kb  &lt;-- probably not recommended</span><br><span class="hljs-comment"># -2: max size: 8 Kb   &lt;-- good</span><br><span class="hljs-comment"># -1: max size: 4 Kb   &lt;-- good</span><br><span class="hljs-comment"># Positive numbers mean store up to _exactly_ that number of elements</span><br><span class="hljs-comment"># per list node.</span><br><span class="hljs-comment"># The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),</span><br><span class="hljs-comment"># but if your use case is unique, adjust the settings as necessary.</span><br><span class="hljs-attribute">list</span>-max-ziplist-size -<span class="hljs-number">2</span><br><br><span class="hljs-comment"># Lists may also be compressed.</span><br><span class="hljs-comment"># Compress depth is the number of quicklist ziplist nodes from *each* side of</span><br><span class="hljs-comment"># the list to *exclude* from compression.  The head and tail of the list</span><br><span class="hljs-comment"># are always uncompressed for fast push/pop operations.  Settings are:</span><br><span class="hljs-comment"># 0: disable all list compression</span><br><span class="hljs-comment"># 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,</span><br><span class="hljs-comment">#    going from either the head or tail&quot;</span><br><span class="hljs-comment">#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span><br><span class="hljs-comment">#    [head], [tail] will always be uncompressed; inner nodes will compress.</span><br><span class="hljs-comment"># 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-comment">#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,</span><br><span class="hljs-comment">#    but compress all nodes between them.</span><br><span class="hljs-comment"># 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span><br><span class="hljs-comment"># etc.</span><br><span class="hljs-attribute">list</span>-compress-depth <span class="hljs-number">0</span><br><br><span class="hljs-comment"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="hljs-comment"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="hljs-comment"># of 64 bit signed integers.</span><br><span class="hljs-comment"># The following configuration setting sets the limit in the size of the</span><br><span class="hljs-comment"># set in order to use this special memory saving encoding.</span><br><span class="hljs-attribute">set</span>-max-intset-entries <span class="hljs-number">512</span><br><br><span class="hljs-comment"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="hljs-comment"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="hljs-comment"># elements of a sorted set are below the following limits:</span><br><span class="hljs-attribute">zset</span>-max-ziplist-entries <span class="hljs-number">128</span><br><span class="hljs-attribute">zset</span>-max-ziplist-value <span class="hljs-number">64</span><br><br><span class="hljs-comment"># HyperLogLog sparse representation bytes limit. The limit includes the</span><br><span class="hljs-comment"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><br><span class="hljs-comment"># this limit, it is converted into the dense representation.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A value greater than 16000 is totally useless, since at that point the</span><br><span class="hljs-comment"># dense representation is more memory efficient.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The suggested value is ~ 3000 in order to have the benefits of</span><br><span class="hljs-comment"># the space efficient encoding without slowing down too much PFADD,</span><br><span class="hljs-comment"># which is O(N) with the sparse encoding. The value can be raised to</span><br><span class="hljs-comment"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><br><span class="hljs-comment"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span><br><span class="hljs-attribute">hll</span>-sparse-max-bytes <span class="hljs-number">3000</span><br><br><span class="hljs-comment"># Streams macro node max size / items. The stream data structure is a radix</span><br><span class="hljs-comment"># tree of big nodes that encode multiple items inside. Using this configuration</span><br><span class="hljs-comment"># it is possible to configure how big a single node can be in bytes, and the</span><br><span class="hljs-comment"># maximum number of items it may contain before switching to a new node when</span><br><span class="hljs-comment"># appending new stream entries. If any of the following settings are set to</span><br><span class="hljs-comment"># zero, the limit is ignored, so for instance it is possible to set just a</span><br><span class="hljs-comment"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span><br><span class="hljs-comment"># value.</span><br><span class="hljs-attribute">stream</span>-node-max-bytes <span class="hljs-number">4096</span><br><span class="hljs-attribute">stream</span>-node-max-entries <span class="hljs-number">100</span><br><br><span class="hljs-comment"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span><br><span class="hljs-comment"># order to help rehashing the main Redis hash table (the one mapping top-level</span><br><span class="hljs-comment"># keys to values). The hash table implementation Redis uses (see dict.c)</span><br><span class="hljs-comment"># performs a lazy rehashing: the more operation you run into a hash table</span><br><span class="hljs-comment"># that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the</span><br><span class="hljs-comment"># server is idle the rehashing is never complete and some more memory is used</span><br><span class="hljs-comment"># by the hash table.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default is to use this millisecond 10 times every second in order to</span><br><span class="hljs-comment"># actively rehash the main dictionaries, freeing memory when possible.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If unsure:</span><br><span class="hljs-comment"># use &quot;activerehashing no&quot; if you have hard latency requirements and it is</span><br><span class="hljs-comment"># not a good thing in your environment that Redis can reply from time to time</span><br><span class="hljs-comment"># to queries with 2 milliseconds delay.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but</span><br><span class="hljs-comment"># want to free memory asap when possible.</span><br><span class="hljs-attribute">activerehashing</span> yes<br><br><span class="hljs-comment"># The client output buffer limits can be used to force disconnection of clients</span><br><span class="hljs-comment"># that are not reading data from the server fast enough for some reason (a</span><br><span class="hljs-comment"># common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the</span><br><span class="hljs-comment"># publisher can produce them).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The limit can be set differently for the three different classes of clients:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># normal -&gt; normal clients including MONITOR clients</span><br><span class="hljs-comment"># replica  -&gt; replica clients</span><br><span class="hljs-comment"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The syntax of every client-output-buffer-limit directive is the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A client is immediately disconnected once the hard limit is reached, or if</span><br><span class="hljs-comment"># the soft limit is reached and remains reached for the specified number of</span><br><span class="hljs-comment"># seconds (continuously).</span><br><span class="hljs-comment"># So for instance if the hard limit is 32 megabytes and the soft limit is</span><br><span class="hljs-comment"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span><br><span class="hljs-comment"># if the size of the output buffers reach 32 megabytes, but will also get</span><br><span class="hljs-comment"># disconnected if the client reaches 16 megabytes and continuously overcomes</span><br><span class="hljs-comment"># the limit for 10 seconds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default normal clients are not limited because they don&#x27;t receive data</span><br><span class="hljs-comment"># without asking (in a push way), but just after a request, so only</span><br><span class="hljs-comment"># asynchronous clients may create a scenario where data is requested faster</span><br><span class="hljs-comment"># than it can read.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Instead there is a default limit for pubsub and replica clients, since</span><br><span class="hljs-comment"># subscribers and replicas receive data in a push fashion.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span><br><span class="hljs-attribute">client</span>-output-buffer-limit normal <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-attribute">client</span>-output-buffer-limit replica <span class="hljs-number">256</span>mb <span class="hljs-number">64</span>mb <span class="hljs-number">60</span><br><span class="hljs-attribute">client</span>-output-buffer-limit pubsub <span class="hljs-number">32</span>mb <span class="hljs-number">8</span>mb <span class="hljs-number">60</span><br><br><span class="hljs-comment"># Client query buffers accumulate new commands. They are limited to a fixed</span><br><span class="hljs-comment"># amount by default in order to avoid that a protocol desynchronization (for</span><br><span class="hljs-comment"># instance due to a bug in the client) will lead to unbound memory usage in</span><br><span class="hljs-comment"># the query buffer. However you can configure it here if you have very special</span><br><span class="hljs-comment"># needs, such us huge multi/exec requests or alike.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># client-query-buffer-limit 1gb</span><br><br><span class="hljs-comment"># In the Redis protocol, bulk requests, that are, elements representing single</span><br><span class="hljs-comment"># strings, are normally limited ot 512 mb. However you can change this limit</span><br><span class="hljs-comment"># here, but must be 1mb or greater</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># proto-max-bulk-len 512mb</span><br><br><span class="hljs-comment"># Redis calls an internal function to perform many background tasks, like</span><br><span class="hljs-comment"># closing connections of clients in timeout, purging expired keys that are</span><br><span class="hljs-comment"># never requested, and so forth.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Not all tasks are performed with the same frequency, but Redis checks for</span><br><span class="hljs-comment"># tasks to perform according to the specified &quot;hz&quot; value.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when</span><br><span class="hljs-comment"># Redis is idle, but at the same time will make Redis more responsive when</span><br><span class="hljs-comment"># there are many keys expiring at the same time, and timeouts may be</span><br><span class="hljs-comment"># handled with more precision.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The range is between 1 and 500, however a value over 100 is usually not</span><br><span class="hljs-comment"># a good idea. Most users should use the default of 10 and raise this up to</span><br><span class="hljs-comment"># 100 only in environments where very low latency is required.</span><br><span class="hljs-attribute">hz</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment"># Normally it is useful to have an HZ value which is proportional to the</span><br><span class="hljs-comment"># number of clients connected. This is useful in order, for instance, to</span><br><span class="hljs-comment"># avoid too many clients are processed for each background task invocation</span><br><span class="hljs-comment"># in order to avoid latency spikes.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Since the default HZ value by default is conservatively set to 10, Redis</span><br><span class="hljs-comment"># offers, and enables by default, the ability to use an adaptive HZ value</span><br><span class="hljs-comment"># which will temporary raise when there are many connected clients.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When dynamic HZ is enabled, the actual configured HZ will be used</span><br><span class="hljs-comment"># as a baseline, but multiples of the configured HZ value will be actually</span><br><span class="hljs-comment"># used as needed once more clients are connected. In this way an idle</span><br><span class="hljs-comment"># instance will use very little CPU time while a busy instance will be</span><br><span class="hljs-comment"># more responsive.</span><br><span class="hljs-attribute">dynamic</span>-hz yes<br><br><span class="hljs-comment"># When a child rewrites the AOF file, if the following option is enabled</span><br><span class="hljs-comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-comment"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-comment"># big latency spikes.</span><br><span class="hljs-attribute">aof</span>-rewrite-incremental-fsync yes<br><br><span class="hljs-comment"># When redis saves RDB file, if the following option is enabled</span><br><span class="hljs-comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span><br><span class="hljs-comment"># in order to commit the file to the disk more incrementally and avoid</span><br><span class="hljs-comment"># big latency spikes.</span><br><span class="hljs-attribute">rdb</span>-save-incremental-fsync yes<br><br><span class="hljs-comment"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span><br><span class="hljs-comment"># idea to start with the default settings and only change them after investigating</span><br><span class="hljs-comment"># how to improve the performances and how the keys LFU change over time, which</span><br><span class="hljs-comment"># is possible to inspect via the OBJECT FREQ command.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># There are two tunable parameters in the Redis LFU implementation: the</span><br><span class="hljs-comment"># counter logarithm factor and the counter decay time. It is important to</span><br><span class="hljs-comment"># understand what the two parameters mean before changing them.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis</span><br><span class="hljs-comment"># uses a probabilistic increment with logarithmic behavior. Given the value</span><br><span class="hljs-comment"># of the old counter, when a key is accessed, the counter is incremented in</span><br><span class="hljs-comment"># this way:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1. A random number R between 0 and 1 is extracted.</span><br><span class="hljs-comment"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span><br><span class="hljs-comment"># 3. The counter is incremented only if R &lt; P.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default lfu-log-factor is 10. This is a table of how the frequency</span><br><span class="hljs-comment"># counter changes with a different number of accesses with different</span><br><span class="hljs-comment"># logarithmic factors:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment"># | 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="hljs-comment"># +--------+------------+------------+------------+------------+------------+</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> The above table was obtained by running the following commands:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   redis-benchmark -n 1000000 incr foo</span><br><span class="hljs-comment">#   redis-cli object freq foo</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span><br><span class="hljs-comment"># to accumulate hits.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The counter decay time is the time, in minutes, that must elapse in order</span><br><span class="hljs-comment"># for the key counter to be divided by two (or decremented if it has a value</span><br><span class="hljs-comment"># less &lt;= 10).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span><br><span class="hljs-comment"># decay the counter every time it happens to be scanned.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># lfu-log-factor 10</span><br><span class="hljs-comment"># lfu-decay-time 1</span><br><br><span class="hljs-comment">########################### ACTIVE DEFRAGMENTATION #######################</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># What is active defragmentation?</span><br><span class="hljs-comment"># -------------------------------</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Active (online) defragmentation allows a Redis server to compact the</span><br><span class="hljs-comment"># spaces left between small allocations and deallocations of data in memory,</span><br><span class="hljs-comment"># thus allowing to reclaim back memory.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Fragmentation is a natural process that happens with every allocator (but</span><br><span class="hljs-comment"># less so with Jemalloc, fortunately) and certain workloads. Normally a server</span><br><span class="hljs-comment"># restart is needed in order to lower the fragmentation, or at least to flush</span><br><span class="hljs-comment"># away all the data and create it again. However thanks to this feature</span><br><span class="hljs-comment"># implemented by Oran Agra for Redis 4.0 this process can happen at runtime</span><br><span class="hljs-comment"># in an &quot;hot&quot; way, while the server is running.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Basically when the fragmentation is over a certain level (see the</span><br><span class="hljs-comment"># configuration options below) Redis will start to create new copies of the</span><br><span class="hljs-comment"># values in contiguous memory regions by exploiting certain specific Jemalloc</span><br><span class="hljs-comment"># features (in order to understand if an allocation is causing fragmentation</span><br><span class="hljs-comment"># and to allocate it in a better place), and at the same time, will release the</span><br><span class="hljs-comment"># old copies of the data. This process, repeated incrementally for all the keys</span><br><span class="hljs-comment"># will cause the fragmentation to drop back to normal values.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Important things to understand:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 1. This feature is disabled by default, and only works if you compiled Redis</span><br><span class="hljs-comment">#    to use the copy of Jemalloc we ship with the source code of Redis.</span><br><span class="hljs-comment">#    This is the default with Linux builds.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2. You never need to enable this feature if you don&#x27;t have fragmentation</span><br><span class="hljs-comment">#    issues.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 3. Once you experience fragmentation, you can enable this feature when</span><br><span class="hljs-comment">#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The configuration parameters are able to fine tune the behavior of the</span><br><span class="hljs-comment"># defragmentation process. If you are not sure about what they mean it is</span><br><span class="hljs-comment"># a good idea to leave the defaults untouched.</span><br><br><span class="hljs-comment"># Enabled active defragmentation</span><br><span class="hljs-comment"># activedefrag no</span><br><br><span class="hljs-comment"># Minimum amount of fragmentation waste to start active defrag</span><br><span class="hljs-comment"># active-defrag-ignore-bytes 100mb</span><br><br><span class="hljs-comment"># Minimum percentage of fragmentation to start active defrag</span><br><span class="hljs-comment"># active-defrag-threshold-lower 10</span><br><br><span class="hljs-comment"># Maximum percentage of fragmentation at which we use maximum effort</span><br><span class="hljs-comment"># active-defrag-threshold-upper 100</span><br><br><span class="hljs-comment"># Minimal effort for defrag in CPU percentage, to be used when the lower</span><br><span class="hljs-comment"># threshold is reached</span><br><span class="hljs-comment"># active-defrag-cycle-min 1</span><br><br><span class="hljs-comment"># Maximal effort for defrag in CPU percentage, to be used when the upper</span><br><span class="hljs-comment"># threshold is reached</span><br><span class="hljs-comment"># active-defrag-cycle-max 25</span><br><br><span class="hljs-comment"># Maximum number of set/hash/zset/list fields that will be processed from</span><br><span class="hljs-comment"># the main dictionary scan</span><br><span class="hljs-comment"># active-defrag-max-scan-fields 1000</span><br><br><span class="hljs-comment"># Jemalloc background thread for purging will be enabled by default</span><br><span class="hljs-attribute">jemalloc</span>-bg-thread yes<br><br><span class="hljs-comment"># It is possible to pin different threads and processes of Redis to specific</span><br><span class="hljs-comment"># CPUs in your system, in order to maximize the performances of the server.</span><br><span class="hljs-comment"># This is useful both in order to pin different Redis threads in different</span><br><span class="hljs-comment"># CPUs, but also in order to make sure that multiple Redis instances running</span><br><span class="hljs-comment"># in the same host will be pinned to different CPUs.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Normally you can do this using the &quot;taskset&quot; command, however it is also</span><br><span class="hljs-comment"># possible to this via Redis configuration directly, both in Linux and FreeBSD.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># You can pin the server/IO threads, bio threads, aof rewrite child process, and</span><br><span class="hljs-comment"># the bgsave child process. The syntax to specify the cpu list is the same as</span><br><span class="hljs-comment"># the taskset command:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set redis server/io threads to cpu affinity 0,2,4,6:</span><br><span class="hljs-comment"># server_cpulist 0-7:2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set bio threads to cpu affinity 1,3:</span><br><span class="hljs-comment"># bio_cpulist 1,3</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set aof rewrite child process to cpu affinity 8,9,10,11:</span><br><span class="hljs-comment"># aof_rewrite_cpulist 8-11</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set bgsave child process to cpu affinity 1,10,11</span><br><span class="hljs-comment"># bgsave_cpulist 1,10-11</span><br><br></code></pre></td></tr></table></figure><Vssue :title="$title" />]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xshell连接及docker、redis安装</title>
    <link href="/2020/10/11/2018-11-7-redis/"/>
    <url>/2020/10/11/2018-11-7-redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p>This is official blog theme.</p></blockquote><h1 id="Xshell连接及docker、redis安装"><a href="#Xshell连接及docker、redis安装" class="headerlink" title="Xshell连接及docker、redis安装"></a>Xshell连接及docker、redis安装</h1><h2 id="1-连接Xshell"><a href="#1-连接Xshell" class="headerlink" title="1.连接Xshell"></a>1.连接Xshell</h2><h3 id="ip-addr"><a href="#ip-addr" class="headerlink" title="ip addr"></a>ip addr</h3><p>查看本机ip</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/ip.png" alt="image"></p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/Inkedip_LI.jpg" alt="image"></p><h3 id="vi-x2F-etc-x2F-sysconfig-x2F-network-scripts-x2F-ifcfg-ens33"><a href="#vi-x2F-etc-x2F-sysconfig-x2F-network-scripts-x2F-ifcfg-ens33" class="headerlink" title="vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33"></a>vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</h3><p>ifcfg-xxxx，xxx与ip地址2： 相同</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/vi.png" alt="image"></p><p>a：进入插入模式</p><p>修改ONBOOT&#x3D;yes（开机启动网卡）</p><p>esc 之后 :wq 保存并退出</p><p>ip addr 2:中的inet就是ip地址</p><p>注：Linux 已修改ip地址（ONBOOT&#x3D;yes）,但是不显示ip地址</p><p>其实原因很简单，是因为你的（VMware DHCP Service）这个服务没有开，进入计算机管理–》服务和应用程序–》服务 找到VMware DHCP Service打开就行了</p><h2 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2.安装docker"></a>2.安装docker</h2><h3 id="sudo-yum-update"><a href="#sudo-yum-update" class="headerlink" title="sudo yum update"></a>sudo yum update</h3><p>确保 yum 包更新到最新。</p><h3 id="sudo-yum-install-y-yum-utils-device-mapper-persistent-data-lvm2"><a href="#sudo-yum-install-y-yum-utils-device-mapper-persistent-data-lvm2" class="headerlink" title="sudo yum install -y yum-utils device-mapper-persistent-data lvm2"></a>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</h3><p>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的。</p><h3 id="sudo-yum-config-manager-–add-repo-http-mirrors-aliyun-com-docker-ce-linux-centos-docker-ce-repo"><a href="#sudo-yum-config-manager-–add-repo-http-mirrors-aliyun-com-docker-ce-linux-centos-docker-ce-repo" class="headerlink" title="sudo yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo"></a>sudo yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a></h3><p>设置yum源，使用阿里云。</p><h3 id="sudo-yum-install-docker-ce"><a href="#sudo-yum-install-docker-ce" class="headerlink" title="sudo yum install docker-ce"></a>sudo yum install docker-ce</h3><p>安装docker。</p><h3 id="sudo-systemctl-start-docker"><a href="#sudo-systemctl-start-docker" class="headerlink" title="sudo systemctl start docker"></a>sudo systemctl start docker</h3><h3 id="sudo-systemctl-enable-docker"><a href="#sudo-systemctl-enable-docker" class="headerlink" title="sudo systemctl enable docker"></a>sudo systemctl enable docker</h3><p>启动并加入开机启动。</p><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)。</p><h2 id="3-docker安装redis"><a href="#3-docker安装redis" class="headerlink" title="3.docker安装redis"></a>3.docker安装redis</h2><h3 id="docker-search-redis"><a href="#docker-search-redis" class="headerlink" title="docker search redis"></a>docker search redis</h3><p>查看可用版本。</p><h3 id="docker-pull-redis-latest"><a href="#docker-pull-redis-latest" class="headerlink" title="docker pull redis:latest"></a>docker pull redis:latest</h3><p>拉取官方的最新版本的镜像。</p><h3 id="docker-image"><a href="#docker-image" class="headerlink" title="docker image"></a>docker image</h3><p> 列出本地镜像。查看是否已安装了 redis。</p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>显示当前正在运行的容器。</p><p><img src="https://zkept-1302605083.cos.ap-nanjing.myqcloud.com/docker%20ps.png" alt="image"></p><h3 id="docker-run-itd-–name-redis-test-p-6379-6379-redis"><a href="#docker-run-itd-–name-redis-test-p-6379-6379-redis" class="headerlink" title="docker run -itd –name redis-test -p 6379:6379 redis"></a>docker run -itd –name redis-test -p 6379:6379 redis</h3><h3 id="或者：docker-run-p-6379-6379-d-redis"><a href="#或者：docker-run-p-6379-6379-d-redis" class="headerlink" title="或者：docker run -p 6379:6379 -d redis"></a>或者：docker run -p 6379:6379 -d redis</h3><p>创建容器并运行。</p><h3 id="运行已存在容器：sudo-docker-start-“redis-test”"><a href="#运行已存在容器：sudo-docker-start-“redis-test”" class="headerlink" title="运行已存在容器：sudo docker start “redis-test”"></a>运行已存在容器：sudo docker start “redis-test”</h3><p>运行 redis 容器。</p><h3 id="docker-exec-it-redis-x2F-bin-x2F-bash"><a href="#docker-exec-it-redis-x2F-bin-x2F-bash" class="headerlink" title="docker exec -it redis &#x2F;bin&#x2F;bash"></a>docker exec -it redis &#x2F;bin&#x2F;bash</h3><p><strong>-it xxx</strong>   xxx与docker ps 的 names  相同</p><p>注意：&#x2F;bin之前有空格</p><h3 id="root-fcd32baa79ff-x2F-data-redis-cli"><a href="#root-fcd32baa79ff-x2F-data-redis-cli" class="headerlink" title="root@fcd32baa79ff:&#x2F;data# redis-cli"></a>root@fcd32baa79ff:&#x2F;data# redis-cli</h3><p>通过 redis-cli 连接测试使用 redis 服务。</p><h3 id="中文不乱码：–raw"><a href="#中文不乱码：–raw" class="headerlink" title="中文不乱码：–raw"></a>中文不乱码：–raw</h3><p><strong>root@fcd32baa79ff:&#x2F;data# redis-cli –raw</strong></p><h3 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h3><p>已登录：auth password</p><p>登录的同时验证：redis-cli -a password</p><Vssue :title="$title" />]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++：如何理解函数返回一个引用【未完】</title>
    <link href="/2020/04/15/2021-4-15-cpp_func_return_reference/"/>
    <url>/2020/04/15/2021-4-15-cpp_func_return_reference/</url>
    
    <content type="html"><![CDATA[<p>有如下函数，其返回了一个引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> &amp;<span class="hljs-title">ret_val</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个函数用来接收返回的引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 接收一个引用返回</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receive_refer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">ret_val</span>(i); <span class="hljs-comment">// int 接收</span><br>    cout &lt;&lt; a &lt;&lt; endl;  <span class="hljs-comment">// Output: 10</span><br>    a = <span class="hljs-number">50</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 10</span><br><br>    <span class="hljs-type">int</span> &amp;a1 = <span class="hljs-built_in">ret_val</span>(i);   <span class="hljs-comment">// int&amp; 接收</span><br>    a1 = <span class="hljs-number">50</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 50</span><br><br>    <span class="hljs-built_in">ret_val</span>(i) = <span class="hljs-number">555</span>;<br>    cout &lt;&lt; i &lt;&lt; endl;  <span class="hljs-comment">// Output: 555</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接收引用有两种方式：使用 int 接收，或者使用 int&amp; 接收，分别对应上面的 a 和 a1，其中 a 不能修改 i 的值，而 a1 可以。我的疑问是，既然返回值是一个引用，那么接收者不应该也得是一个引用吗，就好比一个函数返回的是 int 指针，那么接收者也必须是一个 int 指针，而不能是 int。</p><p>对应上面的指针版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">ret_val</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receive_</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> a = <span class="hljs-built_in">ret_val</span>(&amp;i);    <span class="hljs-comment">// 错误，不能用 int 接收指针</span><br>    <span class="hljs-type">int</span> *a1 = <span class="hljs-built_in">ret_val</span>(&amp;a);<br>    *a1 = <span class="hljs-number">50</span>;<br>    <span class="hljs-type">int</span> aa = *a1;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 交换 container/list 的值</title>
    <link href="/2020/02/24/2021-2-24-go-container-list-swap/"/>
    <url>/2020/02/24/2021-2-24-go-container-list-swap/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在 <strong>LeetCode 255.用队列实现栈</strong> 这道题里，需要用到两个队列来实现一个栈，并且在算法流程中，需要交换这两个队列的内容，例如：队列 A  &#x3D;&gt; [1, 2, 3]，队列 B &#x3D;&gt; [555]，交换后：A &#x3D;&gt; [555]，B &#x3D;&gt; [1, 2, 3]。</p><p>go 标准库中并没有提供队列的实现，但是提供了 container&#x2F;list 这样一个双向链表，所以可以用 list 来模拟一个队列，定义如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    Queue1 *list.List<span class="hljs-comment">// 队列 1</span><br>    Queue2 *list.List<span class="hljs-comment">// 队列 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>push</code> 方法中需要交换两个队列的内容：</p><h3 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-comment">// 在这里交换值</span><br>  this.Queue1, this.Queue2 = this.Queue2, this.Queue1<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是可以正确运行的，这里的交换语句让 Queue1 重新指向了另一个 list，Queue2 也同样如此，例如：Queue1 &#x3D;&gt; 0x0001，Queue2 &#x3D;&gt; 0x0013，交换后：Queue1 &#x3D;&gt; 0x0013，Queue2 &#x3D;&gt; 0x0001，这里仅仅是改变了结构体成员属性的值（指向），并没有对属性 list 内部进行更改。</p><h3 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h3><p>为了让代码更简洁一些，我尝试用两个变量保存 this.Queue1和 this.Queue2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>  q1 := this.Queue1<br>  q2 := this.Queue2<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-comment">// 在这里交换值</span><br>  q1, q2 = q2, q1<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码会出错，因为这里的交换的是仅仅两个变量 q1 和 q2 的值，并没有对结构体中的属性造成影响。</p><h3 id="写法3"><a href="#写法3" class="headerlink" title="写法3"></a>写法3</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>  q1 := this.Queue1<br>  q2 := this.Queue2<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-comment">// 在这里交换值</span><br>  *q1, *q2 = *q2, *q1<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 q1 和 q2 都是指针变量，所以可以通过 *<strong>取内容符</strong> 来交换值，就和交换两个指针参数值一样，看起来也没有任何问题，但是运行结果却诡异的出现了死循环，而且排查了许久都找不到原因。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>Struct ll</strong>  定义一个类似的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ll <span class="hljs-keyword">struct</span> &#123;<br>l1 *list.List<br>l2 *list.List<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>swap()</strong> 类似 <strong>方法三</strong> 中的取值交换方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(l1, l2 *list.List)</span></span> &#123;<br>*l1, *l2 = *l2, *l1<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>_print</strong> 定义一个输出函数用来友好输出链表，输出值的同时也输出地址值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">print</span><span class="hljs-params">(name <span class="hljs-type">string</span>, l *list.List)</span></span> &#123;<br>fmt.Print(name + <span class="hljs-string">&quot;: &quot;</span>)<br><span class="hljs-keyword">for</span> i := l.Front(); i != <span class="hljs-literal">nil</span>; i = i.Next() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v[%p] -&gt; \t&quot;</span>, i.Value, i)<br>&#125;<br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建两个 list</span><br>l1 := list.New()<br>l2 := list.New()<br><br><span class="hljs-comment">// 为两个链表添加值，l1: 1 -&gt; 2 -&gt; 3，l2: 666</span><br>l1.PushBack(<span class="hljs-number">1</span>)<br>l1.PushBack(<span class="hljs-number">2</span>)<br>l1.PushBack(<span class="hljs-number">3</span>)<br>l2.PushBack(<span class="hljs-number">666</span>)<br><br><span class="hljs-comment">// 输出交换前的值</span><br>fmt.Println(<span class="hljs-string">&quot;before: &quot;</span>)<br>_print(<span class="hljs-string">&quot;l1&quot;</span>, l1)<br>_print(<span class="hljs-string">&quot;l2&quot;</span>, l2)<br><br><span class="hljs-comment">// 交换函数</span><br>swap(l1, l2)<br><span class="hljs-comment">// 输出交换后的值</span><br>fmt.Println(<span class="hljs-string">&quot;after: &quot;</span>)<br>_print(<span class="hljs-string">&quot;l1&quot;</span>, l1)<br>_print(<span class="hljs-string">&quot;l2&quot;</span>, l2)<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">before</span>: <br><span class="hljs-attribute">l1</span>: <span class="hljs-number">1</span>[<span class="hljs-number">0</span>xc00009cde0] -&gt; <span class="hljs-number">2</span>[<span class="hljs-number">0</span>xc00009ce10] -&gt; <span class="hljs-number">3</span>[<span class="hljs-number">0</span>xc00009ce40] -&gt; <br><span class="hljs-attribute">l2</span>: <span class="hljs-number">666</span>[<span class="hljs-number">0</span>xc00009ce70] -&gt; <br><br><span class="hljs-attribute">after</span>: <br><span class="hljs-attribute">l1</span>: <span class="hljs-number">666</span>[<span class="hljs-number">0</span>xc00009ce70] -&gt; <br><span class="hljs-attribute">l2</span>: <span class="hljs-number">1</span>[<span class="hljs-number">0</span>xc00009cde0] -&gt; <span class="hljs-number">2</span>[<span class="hljs-number">0</span>xc00009ce10] -&gt; <span class="hljs-number">3</span>[<span class="hljs-number">0</span>xc00009ce40] -&gt; <br></code></pre></td></tr></table></figure><p>两个链表的值确实已经发生了改变，但是为什么在 <strong>方法 3</strong> 中会产生诡异的错误呢？继续尝试追加值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 交换完之后 pushback</span><br>fmt.Println(<span class="hljs-string">&quot;after swap pushback: &quot;</span>)<br>l2.PushBack(<span class="hljs-number">555</span>)<br>l1.PushBack(<span class="hljs-number">6</span>)<br><span class="hljs-comment">// 输出两个链表</span><br>_print(<span class="hljs-string">&quot;l1&quot;</span>, l1)<br>_print(<span class="hljs-string">&quot;l2&quot;</span>, l2)<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">after swap pushback: <br><span class="hljs-function"><span class="hljs-title">l1</span>: 666[0xc000104e70] -&gt;</span> <span class="hljs-number">6</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104ed0</span>] -&gt;</span> <span class="hljs-number">555</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104ea0</span>] -&gt;</span> &lt;<span class="hljs-function"><span class="hljs-title">nil</span>&gt;[0xc000104db0] -&gt;</span> <br><span class="hljs-function"><span class="hljs-title">l2</span>: 1[0xc000104de0] -&gt;</span> <span class="hljs-number">2</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104e10</span>] -&gt;</span> <span class="hljs-number">3</span>[<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xc000104e40</span>] -&gt;</span> <br></code></pre></td></tr></table></figure><p>上面的代码向 l1 尾部添加了 元素 6，向 l2 尾部添加元素 555，正确结果应该是：</p><p>l1:  666 -&gt; 6</p><p>l2:  1 -&gt; 2 -&gt; 3 -&gt; 555</p><p>但运行结果却十分诡异：</p><p>l1:  666 -&gt; 6 -&gt; 555 -&gt; nil</p><p>l2:  1 -&gt; 2 -&gt; 3</p><p>本来应该添加到 l2 的 555 被添加到了 l1，并且 l1 还多了一个 额外的 nil</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>结合源码进行了分析（不一定正确）</p><p><img src="https://zengh1.github.io/post-images/1618573823911.png"></p><p>至于为什么会出现 <strong>测试</strong> 中的诡异情况，发现自己水平有限，画图画的晕头转向，找不出一个合理的原因，只能草草归结于 <strong>list 的环形被破坏，导致产生无法预料的结果</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写法1 <code>this.Queue1, this.Queue2 = this.Queue2, this.Queue1</code>  只是交换了结构体属性 q1 和 q2 的指向，没有对 list 内部进行修改，而 写法3 <code>*this.Queue1, *this.Queue2 = *this.Queue2, *this.Queue1</code> 则是直接对 list 内部进行了修改，所以产生了无法预料的后果，这也充分说明了指针的危险性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go container/list 源码分析【未完】</title>
    <link href="/2020/02/24/2021-2-24-go-container-list-source-code/"/>
    <url>/2020/02/24/2021-2-24-go-container-list-source-code/</url>
    
    <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// List代表一个双向链表。List零值为一个空的、可用的链表。</span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">// 哨兵节点，连接链表的头节点和尾结点，root.next 连接的是第一个结点，root.prev 连接的是最后一// 个结点</span><br>  root Element <br>  <span class="hljs-comment">// 当前列表长度，不包括哨兵节点</span><br><span class="hljs-built_in">len</span>  <span class="hljs-type">int</span>     <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化或清空 list l。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Init() *List &#123;<br>l.root.next = &amp;l.root<br>l.root.prev = &amp;l.root<br>l.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> l<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> lazyInit() &#123;<br><span class="hljs-keyword">if</span> l.root.next == <span class="hljs-literal">nil</span> &#123;<br>l.Init()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// insert inserts e after at, increments l.len, and returns e.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> insert(e, at *Element) *Element &#123;<br>e.prev = at<br>e.next = at.next<br>e.prev.next = e<br>e.next.prev = e<br>e.list = l<br>l.<span class="hljs-built_in">len</span>++<br><span class="hljs-keyword">return</span> e<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> insertValue(v <span class="hljs-keyword">interface</span>&#123;&#125;, at *Element) *Element &#123;<br><span class="hljs-keyword">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PushBack inserts a new element e with value v at the back of list l and returns e.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> PushBack(v <span class="hljs-keyword">interface</span>&#123;&#125;) *Element &#123;<br>l.lazyInit()<br><span class="hljs-keyword">return</span> l.insertValue(v, l.root.prev)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><h3 id="Front"><a href="#Front" class="headerlink" title="Front()"></a>Front()</h3><p>获取链表的第一个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回列表 l 的第一个元素；如果列表为空，则返回nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Front() *Element &#123;<br><span class="hljs-keyword">if</span> l.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <span class="hljs-comment">// 这里可以看到是用 root.next 连接第一个结点</span><br><span class="hljs-keyword">return</span> l.root.next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Back"><a href="#Back" class="headerlink" title="Back()"></a>Back()</h3><p>获取链表的最后一个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回列表l的最后一个元素；如果列表为空，则返回nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List)</span></span> Back() *Element &#123;<br><span class="hljs-keyword">if</span> l.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>  <span class="hljs-comment">// 这里可以看到是用 root.prev 连接最后一个节点</span><br><span class="hljs-keyword">return</span> l.root.prev<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 发送 post 请求</title>
    <link href="/2020/01/24/2021-1-24-go-post-request/"/>
    <url>/2020/01/24/2021-1-24-go-post-request/</url>
    
    <content type="html"><![CDATA[<p>go 基础之使用原生 http 库发送 post 请求</p><span id="more"></span><h2 id="方式-1"><a href="#方式-1" class="headerlink" title="方式 1"></a>方式 1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 生成请求参数键值对</span><br>data := url.Values&#123;<span class="hljs-string">&quot;propId&quot;</span>: &#123;giftId&#125;, <span class="hljs-string">&quot;propCount&quot;</span>: &#123;count&#125;, <span class="hljs-string">&quot;roomId&quot;</span>: &#123;c.RoomId&#125;&#125;<br><span class="hljs-comment">// Encode() 编码成字符串，并包装成一个 io.Reader</span><br>body := strings.NewReader(data.Encode())<br><br><span class="hljs-comment">// 传到第三个参数</span><br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-string">&quot;https://www.douyu.com/japi/prop/donate/mainsite/v1&quot;</span>,<br>body)<br><br>client := http.Client&#123;&#125;<br>response, err := client.Do(req)<br></code></pre></td></tr></table></figure><h2 id="方式-2"><a href="#方式-2" class="headerlink" title="方式 2"></a>方式 2</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> r http.Request<br>r.ParseForm()<br>r.Form.Add(<span class="hljs-string">&quot;propId&quot;</span>, giftId)<br>r.Form.Add(<span class="hljs-string">&quot;propCount&quot;</span>, count)<br>r.Form.Add(<span class="hljs-string">&quot;roomId&quot;</span>, roomId)<br>body := strings.NewReader(r.Form.Encode())<br><br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-string">&quot;https://www.douyu.com/japi/prop/donate/mainsite/v1&quot;</span>,<br>body)<br><br>client := http.Client&#123;&#125;<br>response, err := client.Do(req)<br></code></pre></td></tr></table></figure><h2 id="方式-3"><a href="#方式-3" class="headerlink" title="方式 3"></a>方式 3</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直接拼接字符串</span><br>body := strings.NewReader(<span class="hljs-string">&quot;propId=268&amp;propCount=1&amp;roomId=9999&amp;bizExt=%7B%22yzxq%22%3A%7B%7D%7D&quot;</span>)<br>req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>,<br><span class="hljs-string">&quot;https://www.douyu.com/japi/prop/donate/mainsite/v1&quot;</span>,<br>body)<br><br>client := http.Client&#123;&#125;<br>response, err := client.Do(req)<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>上面的三种方法，只是创建请求参数键值对的方式不同，最后都是调用了 http.Client.Do() 方法，除此之外，go 还封装了一些 post 方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法 1</span><br>data := url.Values&#123;<span class="hljs-string">&quot;start&quot;</span>:&#123;<span class="hljs-string">&quot;0&quot;</span>&#125;, <span class="hljs-string">&quot;offset&quot;</span>:&#123;<span class="hljs-string">&quot;xxxx&quot;</span>&#125;&#125;<br>body := strings.NewReader(data.Encode())<br>resp, err := http.Post(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>, body)<br><br><span class="hljs-comment">// 方法 2</span><br><span class="hljs-keyword">var</span> r http.Request<br>r.ParseForm()<br>r.Form.Add(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>)<br>body := strings.NewReader(r.Form.Encode())<br>http.Post(<span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>, body)<br><br><span class="hljs-comment">// 方法 3</span><br>data := url.Values&#123;<span class="hljs-string">&quot;start&quot;</span>:&#123;<span class="hljs-string">&quot;0&quot;</span>&#125;, <span class="hljs-string">&quot;offset&quot;</span>:&#123;<span class="hljs-string">&quot;xxxx&quot;</span>&#125;&#125;<br><span class="hljs-comment">// PostForm 的默认 content-type 是 application/x-www-form-urlencoded</span><br>http.PostForm(<span class="hljs-string">&quot;xxxx&quot;</span>, data)<br><br><br></code></pre></td></tr></table></figure><h2 id="发送-json"><a href="#发送-json" class="headerlink" title="发送 json"></a>发送 json</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">bodyJson := <span class="hljs-string">`&#123;&quot;name&quot;:&quot;zhang3 by json&quot;, &quot;id&quot;:&quot;123 by json&quot;&#125;`</span><br>body := bytes.NewReader([]<span class="hljs-type">byte</span>(bodyJson))<br>req, err := http.NewRequest(http.MethodPost, __url__, body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-comment">// 设置 content-type 为 application/json</span><br>req.Header.Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>resp1, _ := http.DefaultClient.Do(req)<br><span class="hljs-keyword">defer</span> resp1.Body.Close()<br>fmt.Println(<span class="hljs-string">&quot;(2)&quot;</span>, <span class="hljs-type">string</span>(read(resp1.Body)))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++ 引用：如何理解&quot;引用被初始化后，不能再指向其他对象&quot;</title>
    <link href="/2020/01/11/2021-1-11-reference_c++/"/>
    <url>/2020/01/11/2021-1-11-reference_c++/</url>
    
    <content type="html"><![CDATA[<p>在 c++ 的引用规则中，有这么一条：<strong>一旦初始化完成 ，引用将和它的初始值对象一直绑定在一起（即不能再指向其他对象）</strong>。抱着初学者的好奇心态，我尝试改变引用的指向，写出了如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义两个 string 变量</span><br>std::string s = <span class="hljs-string">&quot;123&quot;</span>;<br>std::string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br><br><span class="hljs-comment">// 让 s1 引用 s</span><br>std::string &amp;s1 = s;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改前：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><span class="hljs-comment">// 修改 s1 的引用？</span><br>s1 = s2;  <br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改后：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br><span class="hljs-comment">// output</span><br>修改前：s1: <span class="hljs-number">123</span><br>修改后：s1: <span class="hljs-number">456</span><br><br></code></pre></td></tr></table></figure><p>这里我让 s1 重新指向 s2，并且从输出结果来看，s1 的值也确实被修改了，不对啊，规则中明明说好了不能修改的，怎么实际代码中可以？为了验证引用是否真的被修改，将三个变量的指针打印出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;指针 =&gt; s1: %p | s2: %p | s: %p \n&quot;</span>, &amp;s1, &amp;s2, &amp;s);<br><br><span class="hljs-comment">// output</span><br>指针 =&gt; s1: <span class="hljs-number">0x7ffee199e7c8</span> | s2: <span class="hljs-number">0x7ffee199e7b0</span> | s: <span class="hljs-number">0x7ffee199e7c8</span> <br></code></pre></td></tr></table></figure><p>s1 和 s3 是同一个地址，说明引用并未改变，所以并不是引用被修改了，而是我的理解出现了问题，代码中的 s1 &#x3D; s2，并不是让引用重新指向 s2，而是把值赋给了与引用绑定的对象（等同于 s &#x3D; s2），这里做一个简单验证就很好理解了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义两个 string 变量</span><br>std::string s = <span class="hljs-string">&quot;123&quot;</span>;<br>std::string s2 = <span class="hljs-string">&quot;456&quot;</span>;<br><br><span class="hljs-comment">// 让 s1 引用 s</span><br>std::string &amp;s1 = s;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改前：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><span class="hljs-comment">// 修改 s1 的引用？</span><br>s1 = s2;  <br><span class="hljs-comment">// 修改 s2 的值，如果 s1 的引用被修改为指向 s2，那么 s1 的值应该也会改为 &quot;666&quot;</span><br>s2 = <span class="hljs-string">&quot;666&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;修改后：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br><br><span class="hljs-comment">// output</span><br>修改前：s1: <span class="hljs-number">123</span><br>修改后：s1: <span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><p>s1 并没有被修改为 “666”，所以可以印证上面的说法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬链接和软链接</title>
    <link href="/2020/01/11/2021-1-19-soft-hard-link/"/>
    <url>/2020/01/11/2021-1-19-soft-hard-link/</url>
    
    <content type="html"><![CDATA[<p>Linux 的硬链接和软链接</p><span id="more"></span><h1 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h1><p>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)，可以通过 ls -li 查看每个文件的索引节点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span> -li<br>total 56<br> 8758859 -rw-r--r--  1 zz  staff   364 12 27 11:57 bufio_read.go<br> 7957721 -rw-r--r--  1 zz  staff   383 12 13 22:30 bufio_scann.go<br>10097171 -rw-r--r--  1 zz  staff   225  1  8 12:04 deferTest.go<br>10164017 -rw-r--r--  1 zz  staff   464  1  8 20:43 inToOut.go<br> 8751290 -rw-r--r--  1 zz  staff   276 12 26 22:13 scanfTest.go<br> 7173127 -rw-r--r--  1 zz  staff   338 12  2 14:45 t1.go<br> 7173519 -rw-r--r--@ 1 zz  staff  1520 12  2 14:59 test.go<br></code></pre></td></tr></table></figure><h1 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h1><p>基本命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ln</span> f1 f2  <span class="hljs-comment">#创建f1的一个硬连接文件f2</span><br></code></pre></td></tr></table></figure><p><strong>硬链接</strong>可以简单把它想成 C 语言中的指针，它指向了物理硬盘的一个区块，多个硬链接会指向同一个区块，（可以理解为 C 中的多个指针指向了同一块内存空间）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch f &amp;&amp; echo &quot;hello&quot; &gt; f   # 创建一个文件并向其写入内容<br>ln f hard_f                   # 创建 f 的第一条硬链接 hard_f<br>ln f hard_f1                  # 创建 f 的第二条硬链接 hard_f1<br><br>ll -i<br>10966044 -rw-r--r--  3 zz  staff     6B  1 19 11:52 f<br>10966044 -rw-r--r--  3 zz  staff     6B  1 19 11:52 hard_f<br>10966044 -rw-r--r--  3 zz  staff     6B  1 19 11:52 hard_f1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">两个硬链接的 inode index 与源文件相同</span><br></code></pre></td></tr></table></figure><p>因为指向的是同一个硬盘区块，所以通过硬链接更改文件内容时，会导致其他的硬链接及源文件也被更改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> f hard_f hard_f1     <span class="hljs-comment"># 输出三个文件的初始值</span><br>hello<br>hello<br>hello<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span> &gt; hard_f      <span class="hljs-comment"># 修改 hard_f 的内容</span><br><span class="hljs-built_in">cat</span> f hard_f hard_f1     <span class="hljs-comment"># 三个文件的值已经全部更改了</span><br>123<br>123<br>123<br></code></pre></td></tr></table></figure><p>事实上文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> f                   <span class="hljs-comment"># 删除源文件</span><br><span class="hljs-built_in">cat</span> hard_f hard_f1     <span class="hljs-comment"># 尝试输出两个链接文件的内容</span><br>123<br>123                    <span class="hljs-comment"># 硬链接文件可以正常输出</span><br><br></code></pre></td></tr></table></figure><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h1 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h1><p>基本命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ln</span> -s f1 soft<br></code></pre></td></tr></table></figure><p><strong>软链接</strong>也称之为符号连接（Symbolic Link），软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个<strong>文本文件</strong>，其中包含有另一文件的<strong>位置信息</strong>，在硬盘上有独立的区块，访问时替换自身路径。</p><p>与硬链接不同，软链接的 inode_index 与源文件是不同的，每个软链接的  inode_index 也不同，如下： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ln</span> -s f soft_f1<span class="hljs-comment"># 创建两个软链接</span><br><span class="hljs-built_in">ln</span> -s f soft_f2<br>ll -i<br>10973146 -rw-r--r--  1 zz  staff     4B  1 19 17:19 f<br>10973197 lrwxr-xr-x  1 zz  staff     1B  1 19 17:19 soft_f1 -&gt; f<br>10973203 lrwxr-xr-x  1 zz  staff     1B  1 19 17:20 soft_f2 -&gt; f<br></code></pre></td></tr></table></figure><p>软链接的显示形式也比较特殊，为 软链接文件 -&gt; 源文件。</p><p>删除源文件后，所有关联的的软链接文件仍然存在（因为两个是不同的文件），但指向的是一个无效的链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">rm</span> f<span class="hljs-comment"># 删除源文件</span><br><span class="hljs-built_in">cat</span> soft_f1 soft_f2<span class="hljs-comment"># 尝试输出两个软链接文件</span><br><span class="hljs-built_in">cat</span>: soft_f1: No such file or directory<span class="hljs-comment"># 无法输出内容：找不到文件</span><br><span class="hljs-built_in">cat</span>: soft_f2: No such file or directory<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>硬链接是指针，所有的硬链接都是指向同一个磁盘块。 删除一个指针不会真正删除文件，只有把所有的指针都删除才会真正删除文件。 软连接是另外一种类型的文件，保存的是它指向文件的全路径， 访问时会替换成绝对路径</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
