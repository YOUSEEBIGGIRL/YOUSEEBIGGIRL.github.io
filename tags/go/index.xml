<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on /dev/null</title>
    <link>/tags/go/</link>
    <description>Recent content in go on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 0000 &lt;a&gt;null&lt;/a&gt; 
</copyright>
    <lastBuildDate>Tue, 06 Sep 2022 02:28:52 +0000</lastBuildDate><atom:link href="/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一个 EOF 引发的低级错误</title>
      <link>/posts/eof_cuo_wu/</link>
      <pubDate>Tue, 06 Sep 2022 02:28:52 +0000</pubDate>
      
      <guid>/posts/eof_cuo_wu/</guid>
      <description>今天更新了一下之前写的 tcp server，结果测试的时候发现了一个十分诡异的 BUG：客户端这边发送完数据，进程都已经退出了，但是服务端却依然源源不断的接收到客户端发来的数据，而且数据包的大小都为 0，这个 BUG 花费了我大半天的时间，终于找到了问题所在，特此记录。</description>
    </item>
    
    <item>
      <title>一个 go nil pointer 错误记录</title>
      <link>/posts/go_nil_pointer/</link>
      <pubDate>Mon, 05 Sep 2022 00:51:45 +0000</pubDate>
      
      <guid>/posts/go_nil_pointer/</guid>
      <description>看看下面这段代码的运行结果是什么？
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net&amp;quot; ) func main() { lis, err := net.</description>
    </item>
    
    <item>
      <title>go binary 使用指南 </title>
      <link>/posts/go_binary/</link>
      <pubDate>Mon, 08 Aug 2022 20:35:52 +0000</pubDate>
      
      <guid>/posts/go_binary/</guid>
      <description>一个示例 demo：
package main import ( &amp;quot;bytes&amp;quot; &amp;quot;encoding/binary&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io&amp;quot; ) type I interface { Do() } type S struct { Id int64 Name [10]byte } func (s *S) Do() { fmt.</description>
    </item>
    
    <item>
      <title>为什么 go 需要 nil chan</title>
      <link>/posts/wei-shen-me-go-you-nil-chan/</link>
      <pubDate>Mon, 18 Jul 2022 22:35:52 +0000</pubDate>
      
      <guid>/posts/wei-shen-me-go-you-nil-chan/</guid>
      <description>如果没有调用 make 来对一个 chan 进行初始化，那么这个 chan 就是 nil chan。</description>
    </item>
    
    <item>
      <title>go mutex 原理</title>
      <link>/posts/go-mutex-yuan-ma/</link>
      <pubDate>Tue, 12 Jul 2022 22:09:40 +0000</pubDate>
      
      <guid>/posts/go-mutex-yuan-ma/</guid>
      <description>参考： https://www.bilibili.com/video/BV15V411n7fM?p=2&amp;amp;spm_id_from=pageDriver&amp;amp;vd_source=2ff613424b86c58a71ba91b7304ffe9b
总览 mutex 的数据结构：</description>
    </item>
    
    <item>
      <title>go chan 原理（人话版）</title>
      <link>/posts/go-chan-yuan-ma/</link>
      <pubDate>Sun, 26 Jun 2022 20:51:11 +0000</pubDate>
      
      <guid>/posts/go-chan-yuan-ma/</guid>
      <description>chan 原理（人话版） 说明：这里只是用大白话来阐述 chan 的大致原理，不保证严谨性，也不考虑一些繁枝细节（比如 sudog，gopark，goready），仅作为一个简单的参考理解，如果想深入理解 chan 的底层实现，请自行参阅其他博客</description>
    </item>
    
    <item>
      <title>go 熔断器 gobreaker 源码阅读</title>
      <link>/posts/gobreaker/</link>
      <pubDate>Sat, 11 Jun 2022 20:40:11 +0000</pubDate>
      
      <guid>/posts/gobreaker/</guid>
      <description>该文章仅作为本人笔记，不具备太大的参考价值
该文章着重记录源码，没有对熔断器这一概念做过多理念上的说明解释
该文章排版、思路较为混乱，后续可能会进行修改
示例 官方示例 官方示例有点太简单了，完全无法体会到 熔断 这一概念</description>
    </item>
    
    <item>
      <title>go 文件操作的&#34;坑&#34;之 Seek()</title>
      <link>/posts/go_seek/</link>
      <pubDate>Wed, 08 Jun 2022 01:03:35 +0000</pubDate>
      
      <guid>/posts/go_seek/</guid>
      <description>引子 最近买了块机械硬盘作为仓库盘，用硬盘盒连接到 mac，但是这块硬盘貌似有休眠机制（不确定），如果一段时间没有读写操作就会停转，等到需要操作时才会唤醒，唤醒会有比较明显的磁盘启动声音，并且需要等待 5s 左右才能使用。</description>
    </item>
    
    <item>
      <title>go gc 白话版</title>
      <link>/posts/go-gc/</link>
      <pubDate>Wed, 01 Jun 2022 22:15:39 +0000</pubDate>
      
      <guid>/posts/go-gc/</guid>
      <description>主流的垃圾回收算法 引用计数法 根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。
优点：简单直接，回收速度快 缺点：需要额外的空间存放计数，无法处理循环引用的情况； 标记清除法 标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。</description>
    </item>
    
    <item>
      <title>Go errgroup 使用</title>
      <link>/posts/errgroup/</link>
      <pubDate>Sat, 28 May 2022 23:55:35 +0000</pubDate>
      
      <guid>/posts/errgroup/</guid>
      <description>简介 errgroup 是 WaitGroup 的强化版，其在 WaitGroup 的基础上添加了错误处理的功能：如果一组 goroutine 中的某一个发生了错误，那么后续的所有 gorouine 都不会被执行。</description>
    </item>
    
    <item>
      <title>一段莫名阻塞的 reflect 代码</title>
      <link>/posts/block-code/</link>
      <pubDate>Fri, 13 May 2022 10:53:35 +0000</pubDate>
      
      <guid>/posts/block-code/</guid>
      <description>package main import ( &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) type I interface { Do() } type S struct{} func (s *S) Do() {} func EnforcePtr(obj interface{}) { v := reflect.</description>
    </item>
    
    <item>
      <title>GMP 面试题</title>
      <link>/posts/gmp-mian-shi-ti/</link>
      <pubDate>Wed, 26 Jan 2022 11:42:52 +0000</pubDate>
      
      <guid>/posts/gmp-mian-shi-ti/</guid>
      <description>Goroutine 阻塞的话，是不是对应的 M 也会阻塞 如果 G 被阻塞在某个系统调用上，那么不仅仅 G 会阻塞，执行 G 的 M 也会解绑 P，与 G 一起进入挂起状态。如果此时有空闲的 M,则 P 和与其绑定并继续执行其他的 G;如果没有空闲的 M,但还是有其他 G 需要去执行，那么会创建一个新 M。当系统调用返回后，阻塞在该系统调用上的 G 会尝试获取一个可用的 P,如果没有可用的 P,那么这个 G 会被标记为 runnable 并把它放入全局的 runqueue 中等待调度，之前的那个挂起的 M 将再次进入挂起状态。</description>
    </item>
    
    <item>
      <title>两个 main goroutine 操作一个 channel 会怎样</title>
      <link>/posts/liang-ge-main-goroutine-cao-zuo-yi-ge-channel-hui-zen-yang/</link>
      <pubDate>Sun, 08 Aug 2021 21:09:50 +0000</pubDate>
      
      <guid>/posts/liang-ge-main-goroutine-cao-zuo-yi-ge-channel-hui-zen-yang/</guid>
      <description>引子 定义一个全局变量 chan，然后创建两个 main goroutine，一个往全局 chan 里发送数据，一个从全局 chan 里读取数据，会发生什么？</description>
    </item>
    
    <item>
      <title>go map源码阅读</title>
      <link>/posts/go-map-yuan-ma-yue-du/</link>
      <pubDate>Thu, 29 Jul 2021 20:37:56 +0000</pubDate>
      
      <guid>/posts/go-map-yuan-ma-yue-du/</guid>
      <description>看看 map 这个重要数据结构在 go 中是如何实现的</description>
    </item>
    
    <item>
      <title>go container/heap 源码阅读</title>
      <link>/posts/go-containerheap-yuan-ma-yue-du/</link>
      <pubDate>Thu, 22 Jul 2021 14:16:49 +0000</pubDate>
      
      <guid>/posts/go-containerheap-yuan-ma-yue-du/</guid>
      <description>heap（堆），是一个用数组表示的完全二叉树，常用于构建优先队列，排序和快速找出一个集合中的最小值（或者最大值）。在 go 标准库下的 container 包中提供了这种数据结构。</description>
    </item>
    
    <item>
      <title>【两万字长文带你深入Go语言GC源码——腾讯技术工程】阅读笔记</title>
      <link>/posts/liang-wan-zi-chang-wen-dai-ni-shen-ru-go-yu-yan-gc-yuan-ma-teng-xun-ji-zhu-gong-cheng-yue-du-bi-ji/</link>
      <pubDate>Fri, 04 Jun 2021 21:29:45 +0000</pubDate>
      
      <guid>/posts/liang-wan-zi-chang-wen-dai-ni-shen-ru-go-yu-yan-gc-yuan-ma-teng-xun-ji-zhu-gong-cheng-yue-du-bi-ji/</guid>
      <description>作者：luozhiyun 博客：https://www.luozhiyun.com/archives/475 本文使用的 Go 的源码1.</description>
    </item>
    
    <item>
      <title>go：记一次 defer 错误</title>
      <link>/posts/goji-yi-ci-defer-cuo-wu/</link>
      <pubDate>Fri, 23 Apr 2021 21:27:02 +0000</pubDate>
      
      <guid>/posts/goji-yi-ci-defer-cuo-wu/</guid>
      <description>错误1： func test() error { if err := func1(); err !</description>
    </item>
    
    <item>
      <title>go：http.Request.Body 第二次读取为空 </title>
      <link>/posts/goiocopy-de-keng/</link>
      <pubDate>Sat, 17 Apr 2021 13:01:40 +0000</pubDate>
      
      <guid>/posts/goiocopy-de-keng/</guid>
      <description>有如下代码，先使用 io.Copy 将 request.Body copy 到 stdout 标准输出，再使用 io.</description>
    </item>
    
    <item>
      <title>go 字节数组错误：\u0001</title>
      <link>/posts/2021-3-13-byte-array/</link>
      <pubDate>Fri, 16 Apr 2021 19:48:34 +0000</pubDate>
      
      <guid>/posts/2021-3-13-byte-array/</guid>
      <description>在做 压缩字符串 这道题时，提交的输出结果十分诡异，如下：
输入：
[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;c&amp;rdquo;]</description>
    </item>
    
    <item>
      <title>go container/list 源码分析【未完】</title>
      <link>/posts/2021-2-24-go-container-list-source-code/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021-2-24-go-container-list-source-code/</guid>
      <description>List // List代表一个双向链表。List零值为一个空的、可用的链表。 type List struct { // 哨兵节点，连接链表的头节点和尾结点，root.</description>
    </item>
    
    <item>
      <title>go 交换 container/list 的值</title>
      <link>/posts/2021-2-24-go-container-list-swap/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021-2-24-go-container-list-swap/</guid>
      <description>场景 在 LeetCode 255.用队列实现栈 这道题里，需要用到两个队列来实现一个栈，并且在算法流程中，需要交换这两个队列的内容，例如：队列 A =&amp;gt; [1, 2, 3]，队列 B =&amp;gt; [555]，交换后：A =&amp;gt; [555]，B =&amp;gt; [1, 2, 3]。</description>
    </item>
    
    <item>
      <title>go 发送 post 请求</title>
      <link>/posts/2021-1-24-go-post-request/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/posts/2021-1-24-go-post-request/</guid>
      <description>go 基础之使用原生 http 库发送 post 请求</description>
    </item>
    
  </channel>
</rss>
