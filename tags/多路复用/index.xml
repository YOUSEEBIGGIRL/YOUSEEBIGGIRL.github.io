<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多路复用 on /dev/null</title>
    <link>/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
    <description>Recent content in 多路复用 on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 0000 &lt;a&gt;null&lt;/a&gt; 
</copyright>
    <lastBuildDate>Fri, 02 Sep 2022 12:32:45 +0000</lastBuildDate><atom:link href="/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>epoll 打断/唤醒</title>
      <link>/posts/epoll_zhong_duan/</link>
      <pubDate>Fri, 02 Sep 2022 12:32:45 +0000</pubDate>
      
      <guid>/posts/epoll_zhong_duan/</guid>
      <description>写这篇文章是因为最近在看 go netpoll 的源码，里面有一部分代码是创建一个管道，一开始没有搞懂用意何在，后来查阅了网上的文章，有说法是这个管道是为了打断 epoll_wait 的等待，将这个管道的 fd 添加到 epoll 中，如果想主动打断 epoll_wait，那么就往管道中写入数据，然后在 epoll_wait 处就会产生事件，终止阻塞。</description>
    </item>
    
    <item>
      <title>kqueue</title>
      <link>/posts/kqueue/</link>
      <pubDate>Sat, 28 May 2022 01:10:35 +0000</pubDate>
      
      <guid>/posts/kqueue/</guid>
      <description>一个 echo server 示例：
package main import ( &amp;quot;log&amp;quot; .</description>
    </item>
    
    <item>
      <title>epoll 的 LT 和 ET</title>
      <link>/posts/epoll-de-lt-he-et/</link>
      <pubDate>Fri, 23 Jul 2021 19:25:45 +0000</pubDate>
      
      <guid>/posts/epoll-de-lt-he-et/</guid>
      <description>Linux epoll 的条件触发( Level Trigger )和边缘触发( Edge Trigger )</description>
    </item>
    
    <item>
      <title>linux select 的错误使用案例</title>
      <link>/posts/linux-select-de-cuo-wu-shi-yong-an-li/</link>
      <pubDate>Sun, 18 Jul 2021 17:54:27 +0000</pubDate>
      
      <guid>/posts/linux-select-de-cuo-wu-shi-yong-an-li/</guid>
      <description>select 错误使用记录，加深对 select 的理解
错误的代码 有如下一个使用多路复用 select 实现的 echo（回响）服务器：</description>
    </item>
    
  </channel>
</rss>
