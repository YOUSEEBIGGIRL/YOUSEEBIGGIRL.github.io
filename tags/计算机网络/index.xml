<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机网络 on /dev/null</title>
    <link>/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
    <description>Recent content in 计算机网络 on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 0000 &lt;a&gt;null&lt;/a&gt; 
</copyright>
    <lastBuildDate>Tue, 02 Aug 2022 19:04:52 +0000</lastBuildDate><atom:link href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TCP 拥塞控制</title>
      <link>/posts/tcp_yong_se_kong_zhi/</link>
      <pubDate>Tue, 02 Aug 2022 19:04:52 +0000</pubDate>
      
      <guid>/posts/tcp_yong_se_kong_zhi/</guid>
      <description>发送方维护一个叫做 拥塞窗口 cwnd 的状态变量，其值 取决于网络的拥塞程度，并且 动态变化。</description>
    </item>
    
    <item>
      <title>TLS 握手流程</title>
      <link>/posts/tls_wo_shou/</link>
      <pubDate>Thu, 14 Jul 2022 14:30:52 +0000</pubDate>
      
      <guid>/posts/tls_wo_shou/</guid>
      <description>注：以下内容引用自 cloudflare 学习中心
TLS 握手有哪些步骤？ TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。</description>
    </item>
    
    <item>
      <title>输入 url 到浏览器显示网页，期间发生了什么？（未完）</title>
      <link>/posts/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/</link>
      <pubDate>Thu, 14 Jul 2022 14:30:52 +0000</pubDate>
      
      <guid>/posts/url_dao_xian_shi_wang_ye_fa_shen_le_shen_me/</guid>
      <description>从请求 URL 中获取请求域名，通过 DNS 获取域名对应的 IP 地址</description>
    </item>
    
    <item>
      <title>127.0.0.1，localhost，0.0.0.0 的区别（包含虚拟网卡相关操作）</title>
      <link>/posts/127.0.0.1_localhost_0.0.0.0/</link>
      <pubDate>Fri, 24 Jun 2022 20:50:11 +0000</pubDate>
      
      <guid>/posts/127.0.0.1_localhost_0.0.0.0/</guid>
      <description>127.0.0.1 127.0.0.1 是 回环地址，当报文的目的地址是回环地址时，依然会走一遍网络协议栈，但是不会经过物理网卡，而是经过一个名为 lo 的虚拟网卡（mac 上交 lo0），具体的流程是：</description>
    </item>
    
    <item>
      <title>SO_REUSEADDR 和 SO_REUSEPORT 实践</title>
      <link>/posts/so_reuseaddr-he-so_reuseport-shi-jian/</link>
      <pubDate>Thu, 10 Feb 2022 22:03:09 +0000</pubDate>
      
      <guid>/posts/so_reuseaddr-he-so_reuseport-shi-jian/</guid>
      <description>SO_REUSEADDR 该选项可以绑定处于 TIME_WAIT 状态的地址，实践： server 端：</description>
    </item>
    
    <item>
      <title>TCP CLOSE_WAIT 和 FIN_WAIT_2</title>
      <link>/posts/close_wait-he-fin_wait_2/</link>
      <pubDate>Wed, 02 Feb 2022 02:07:10 +0000</pubDate>
      
      <guid>/posts/close_wait-he-fin_wait_2/</guid>
      <description>问题记录 最近写了一个普通的 tcp demo，发现 server 的状态处于 CLOSE_WAIT，而 client 的状态处于 FIN_WAIT_2，为了排查这个问题，特此写了这篇文章作为记录，这也</description>
    </item>
    
    <item>
      <title>计算机网络面试题</title>
      <link>/posts/ji-suan-ji-wang-luo-mian-shi-ti/</link>
      <pubDate>Fri, 28 Jan 2022 23:45:48 +0000</pubDate>
      
      <guid>/posts/ji-suan-ji-wang-luo-mian-shi-ti/</guid>
      <description>TCP 相关 1. 说说 TIME_WAIT 及其作用 当一端 主动 断开连接并发送最后一次挥手后，该端状态变为 TIME_WAIT ，此时会等待 2 MSL （MSL 是 Maximum Segment Lifetime，译为“报文最大生存时间”，可为 30s，1min 或 2min。） 作用：</description>
    </item>
    
    <item>
      <title>可靠传输的实现机制 —— 停止-等待协议SW（Stop-and-Wait）</title>
      <link>/posts/ke-kao-chuan-shu-de-shi-xian-ji-zhi-ting-zhi-deng-dai-xie-yi-swstop-and-wait/</link>
      <pubDate>Fri, 30 Jul 2021 18:16:47 +0000</pubDate>
      
      <guid>/posts/ke-kao-chuan-shu-de-shi-xian-ji-zhi-ting-zhi-deng-dai-xie-yi-swstop-and-wait/</guid>
      <description>何为停等协议 首先假设有这样一个简单的可靠传输协议，主机 A 发送数据分组给 主机 B，由于网络传输过程中可能会出现数据损坏，所以主机 B会进行校验和检测，如果数据完整则发送 ACK，否则发送 NAK，如果收到 ACK，则可以继续发送下一个数据分组（如果有），收到 NAK 则重新发送当前数据分组。</description>
    </item>
    
  </channel>
</rss>
